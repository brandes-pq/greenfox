<?xml-model href='http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng' schematypens='http://relaxng.org/ns/structure/1.0'?><?xml-model href='http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng' type='application/xml' schematypens='http://purl.oclc.org/dsdl/schematron'?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0">
    <info>
        <title>Greenfox – a schema language for validating file systems</title>
        <author>
            <personname>Hans-Juergen Rennau</personname>
            <email>hans-juergen.rennau@parsqube.de</email>
            <personblurb>
                <para/>
            </personblurb>
            <affiliation>
                <orgname>parsQube GmbH</orgname>
            </affiliation>
        </author>
        <keywordset>
            <keyword>Validation, SHACL, XSD, JSON Schema, Schematron</keyword>
        </keywordset>
        <abstract>
            <para>Greenfox is a schema language for validating file systems. One key feature is an
                abstract validation model inspired by the SHACL language. Another key feature is a
                view of the file system which is based on the XDM data model and thus supports a set
                of powerful expression languages (XPath, foxpath, XQuery). Using their expressions
                as basic building blocks, the schema language unifies navigation within and between
                resources and access to the structured contents of files with different mediatypes.
            </para>
        </abstract>
    </info>
    <section xml:id="introduction">
        <title>Introduction</title>
        <para>How to validate data against expectations? Major options are visual inspection,
            programatic checking and validation against a schema document (e.g. XSD, RelaxNG,
            Schematron, JSON Schema) or a schema graph (e.g. SHACL). Schema validation is in many
            scenarios the superior approach, as it is automated and declarative. But there are also
            limitations worth considering when thinking about validation in general. </para>
        <para>First, schema languages describe instances of a particular format or mediatype only
            (e.g. XML, JSON, RDF), whereas typical projects involve a mixture of mediatypes.
            Therefore schema validation tends to describe the state of resources which are pieces
            from a jigsaw puzzle, and the question arises how to integrate the results into a
            coherent whole. </para>
        <para>Second, several schema languages of key importance are grammar based and therefore do
            not support “incremental validation” – starting with a minimum of constraints, and
            adding more along the way. We cannot use XSD, RelaxNG or JSON Schema in order to express
            some very specific key expectation, without saying many things about the document as a
            whole, which may be a task requiring disproportional effort. Rule based schema languages
            (like Schematron) do support incremental validation, but they are inappropriate for
            comprehensive validation as accomplished by grammar based languages.</para>
        <para>As a consequence, schema validation enables isolated acts of resource validation, but
            it cannot accomplish the integration of validation results. Put differently, schema
            validation may contribute to, but cannot accomplish, system validation. The situation
            might change in an interesting way if we had a schema language for validating <emphasis
                role="ital">file system contents</emphasis> – arbitrary trees of files and folders.
            This simple abstraction suffices to accommodate any software project, and it can
            accommodate system representations of very large complexity. </para>
        <para>This document describes an early version of <emphasis role="bold">greenfox</emphasis>,
            a schema language for validating file system contents. By implication, it can also be
            viewed as a schema language for the validation of <emphasis role="ital"
                >systems</emphasis>. Such a claim presupposes that a meaningful reflection of system
            properties, state and behaviour can be represented by a collection of data (log data,
            measurement results, test results, configurations, …) distributed over a set of files
            arranged in a tree of folders. It might then sometimes be possible to translate
            meaningful definitions of system validity into constraints on file system contents. At
            other times it may not be possible, for example if the assessment of validity requires a
            tracking of realtime data.</para>
        <para>The notion of system validation implies that extensibility must be a key feature of
            the language. The language must not only offer a scope of expressiveness which is
            immediately useful. It must at the same time serve as a <emphasis role="ital"
                >framework</emphasis>, within which current capabilities, future extensions and
            third-party contributions are uniform parts of a coherent whole. The approach we took is
            a generalization of the key concepts underlying SHACL [x], a validation language for RDF
            data. These concepts serve as the building blocks of a simple metamodel of validation,
            which offers guidance for extension work.</para>
        <para>Validation relies on the key operations of navigation and comparison. File system
            validation must accomplish them in the face of divers mediatypes and the necessity to
            combine navigation within as well as between resources. In response to this challenge,
            greenfox is based on a <emphasis role="ital">unified data model</emphasis> (XDM) [x] and
            a <emphasis role="ital">unified navigation model</emphasis> (foxpath/XPath) [x] [x] [x]
            [x] built upon it. </para>
        <para>Validation produces results, and the more complex the system, the more important it
            may become to produce results in a form which combines maximum precision with optimal
            conditions for integration with other resources. This goal is best served by a <emphasis
                role="ital">vocabulary</emphasis> for expressing validation results and schema
            contents in a way which does not require any context for being understood. We choose an
            RDF based definition of validation schema and validation results, combined with a
            bidirectional mapping between RDF and more intuitive representations, XML and JSON. For
            practical purposes, we assume the XML representation to be the form most frequently
            used.</para>
        <para>Before providing a more detailed overview of the greenfox language, a detailed example
            should give a first impression of how the language can be used.</para>
    </section>
    <section>
        <title>Getting started with greenfox</title>
        <para>This section illustrates the development of a greenfox schema designed for validating
            a file system tree against a set of expections. Such a validation can also be viewed as
            validation of the system “behind” the file system tree, represented by its
            contents.</para>
        <section>
            <title>The system – system S</title>
            <para>Consider <emphasis role="bold">system S</emphasis> – an imaginary system which is
                a collection of web services. We are going to validate a <emphasis role="ital">file
                    system representation</emphasis> which is essentially a set of test results,
                accompanied by resources supporting validation (XSDs, codelists and data about
                expected response messages). The following listing shows a file system tree which is
                a representation of system S, as observed at a certain point in time:</para>
            <programlisting><![CDATA[
system-s
. resources
. . codelists
. . . codelist-foo-article.xml
. . xsd
. . . schema-foo-article.xsd
. testcases
. . test-t1
. . . config
. . . . msg-config.xml
. . . input
. . . . getFooRQ*.xml
. . . output
. . . . getFooRS*.xml
. . +test-t2   (contents: see test-t1)
. . usecases
. . . usecase-u1
. . . . usecase-u1a
. . . . . +test-t3   (contents: see test-t1)]]></programlisting>
            <para>The concrete file system tree must be distinguished from the expected file system
                tree, which is described by the following rules.</para>
            <table xml:id="table-1">
                <title>Rules defining "validity" of the considered file system.</title>
                <titleabbrev xml:id="table-1-shorttitle">Validity rules</titleabbrev>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="2*"/>
                    <colspec colname="c2" colnum="2" colwidth="4*"/>
                    <colspec colname="c3" colnum="3" colwidth="11*"/>
                    <thead>
                        <row>
                            <entry align="left">File or folder</entry>
                            <entry align="left">File path</entry>
                            <entry align="left">Expectation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">resources/codelists</entry>
                            <entry align="left">Contains one or more codelist files</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">resources/codelists/*</entry>
                            <entry align="left">A codelist file; name not constrained; must be an
                                XML document containing <code>&lt;codelist></code> elements with a
                                @name attribute and <code>&lt;entry></code> children</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">resources/xsd</entry>
                            <entry align="left">Contains one or more XSDs describing services
                                messages</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">resources/xsd/*</entry>
                            <entry align="left">An XSD schema file; name not constrained</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*</entry>
                            <entry align="left">A test case folder, containing <code>input</code>,
                                    <code>xoutput</code> and <code>config</code> folders; apart from
                                these only optional <code>log-*</code> files are allowed </entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*/config</entry>
                            <entry align="left">Test case config folder, containing file
                                    <code>msg-config.csv</code></entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">.//test-*/config/msg-config.csv</entry>
                            <entry align="left">A CSV file with three columns: request file name,
                                response file name, expected return code</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*/input</entry>
                            <entry align="left">Test case input folder, containg request
                                messages</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">.//test-*/input/*</entry>
                            <entry align="left">A file representing a request message; name
                                extension <code>.xml</code> or <code>.json</code>; mediatype
                                corresponding to name extension</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*/output</entry>
                            <entry align="left">Test case output folder, containing response
                                messages</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">.//test-*/output/*</entry>
                            <entry align="left">A file representing a response message; name
                                extension <code>.xml</code> or <code>.json</code>; mediatype
                                corresponding to name extension</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>The number and location of testcase folders (<code>test-*</code>) are
                unconstrained. This means that the testcase folders may be grouped and wrapped in
                any way, although they must not be nested. So the use of a <code>testcases</code>
                folder wrapping all testcase folders - and the use of <code>usecase*</code> folders
                adding additional substructure - is allowed, but must not be expected. The placing
                of XSDs in folder <code>resources/xsd</code>, on the other hand, is obligatory, and
                likewise the placing of codelist documents in folder
                    <code>resources/codelists</code>. The names of XSD and codelist files are not
                constrained. </para>
            <para>Structural expectations include also a conditional constraint:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>For every request message, there must be a response message with a name
                        obtained by replacing in the request file name <code>RQ</code> with
                            <code>RS</code> (e.g. <code>getFooRQ.*</code> and
                            <code>getFooRS.*</code>)</para>
                </listitem>
            </itemizedlist>
            <para>Besides the structural expectations, there are also content-related expectations: </para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>For every response message in XML format, there is exactly one XSD against
                        which it can be validated</para>
                </listitem>
                <listitem>
                    <para>Every response message in XML format is valid against the appropriate
                        XSD</para>
                </listitem>
                <listitem>
                    <para>Response message items (XML elements or JSON fields) with name
                            <code>fooValue</code> must be found in the codelist with name
                            <code>foo-article</code></para>
                </listitem>
                <listitem>
                    <para>Response message return codes must be as configured by the corresponding
                        row in <code>msg-config.csv</code> (applies to XML and JSON responses
                        alike)</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Building a greenfox schema "system S"</title>
            <para>Now we create a greenfox schema which enables us to validate the file system
                against these expectations. An initial version only checks the existence of
                non-empty XSD and codelists folders:</para>
            <programlisting><![CDATA[
<greenfox greenfoxURI="http://www.greenfox.org/ns/schema-examples/system-s"
          xmlns="http://www.greenfox.org/ns/schema">
    
  <domain path="\tt\greenfox\resources\example-system\system-s" 
          name="system-s">    
        
      <!-- *** System root folder shape *** -->
      <folder foxpath="." id="systemRootFolderShape">
            
        <!-- *** XSD folder shape -->
        <folder foxpath=".\\resources\xsd" id="xsdFolderShape">
            <targetSize msg="No XSD folder found" count="1"/>
            <file foxpath="*.xsd" id="xsdFileShape">
                <targetSize msg="No XSDs found" minCount="1"/>
            </file>
        </folder>                

        <!-- *** Codelist folder shape -->
        <folder foxpath=".\\resources\codelists" id="codelistFolderShape">
            <targetSize msg="No codelist folder found" count="1"/>
            <file foxpath="*[is-xml(.)]" id="codelistFileShape">
                <targetSize msg="No codelist files found" minCount="1"/>
            </file>
        </folder          
      </folder>                
  </domain>    
</greenfox>]]></programlisting>
            <para>The <code>&lt;domain></code> element represents the root folder of a file system
                tree to be validated. The folder is identified by a mandatory @path
                attribute.</para>
            <para>A <code>&lt;folder></code> element describes a set of folders selected by a target
                declaration. Here, the target declaration is a foxpath expression, given by a
                @foxpath attribute. Foxpath [2] [3] [4] is an extended version of XPath 3.0 which
                supports file system navigation, node tree navigation and a mixing of file system
                and node tree navigation within a single path expression. Note that file system
                navigaton steps are connected by a backslash operator, rather than a slash, which is
                used for node tree navigation steps. The foxpath expression is evaluated in the
                context of a folder selected by the target declaration of the <emphasis role="ital"
                    >containing</emphasis>
                <code>&lt;folder></code> element (or <code>&lt;domain></code>, if there is no
                containing <code>&lt;folder></code>). Evaluation “in the context of a folder” means
                that the initial context item is the file path of that folder, so that relative file
                system path expressions are resolved in this context (see [3], [4] for details). For
                example, the expression</para>
            <programlisting>  .\\resources\xsd</programlisting>
            <para>resolves to the <code>xsd</code> folders contained by a <code>resources</code>
                folder found at any depth under the context folder, <code>system-s</code>.
                Similarly, a <code>&lt;file></code> element describes the set of files selected by
                its target declaration, which is a foxpath expression evaluated in the context of a
                folder selected by the parent <code>&lt;folder></code>’s target declaration. </para>
            <para>A <code>&lt;folder></code> element represents a <emphasis role="bold">folder
                    shape</emphasis>, which is a set of <emphasis role="bold">constraints</emphasis>
                applying to a <emphasis role="bold">target</emphasis>. The target is a (possibly
                empty) set of folders, selected by a <emphasis role="bold">target
                    declaration</emphasis>, e.g. a foxpath expression. The constraints of a folder
                shape are declared by child elements of the shape element.</para>
            <para>Likewise, a <code>&lt;file></code> element represents a <emphasis role="bold">file
                    shape</emphasis>, defining a set of constraints applying to a target, which is a
                set of files selected by a target declaration. Folder shapes and file shapes are
                collectively called <emphasis role="bold">resource shapes</emphasis>.</para>
            <para>The expected number of folders or files belonging to the target of a shape can be
                expressed by declaring a <emphasis role="bold">constraint</emphasis>. A constraint
                has a kind (identified by the <emphasis role="bold">constraint component
                    IRI</emphasis>) and a set of arguments passed to the <emphasis role="bold"
                    >constraint parameters</emphasis>. For every kind of constraint, a
                characteristic set of mandatory and optional constraint parameters is defined in
                terms of name, type and cardinality. In a schema document, a constraint is either
                declared by a <emphasis role="ital">constraint element</emphasis> or by <emphasis
                    role="ital">constraint attributes</emphasis> attached to an element representing
                a set of constraints or a shape. Here, we declare a <code>TargetSize</code>
                constraint, which is represented by a <code>&lt;targetSize></code> child element of
                a file or folder shape. The element has three optional attributes, @minCount,
                @maxCount and @count, representing three different constraints. A constraint can be
                thought of as a function which consumes constraint parameter values and a <emphasis
                    role="ital">resource value</emphasis>, representing the resource being
                validated; and which returns a validation result. Here, the resource value is the
                number of target resources selected, and the constraint parameter
                    <code>minCount</code> is set to the value “1”. If the constraint is violated,
                the validation result is a <code>&lt;gx:red></code> element which contains the
                message (if any) specified by @msg on the constraint element, along with a set of
                information items identifying the violating resource (@filePath), the constraint
                (@constraintComp and @constraintID) and its parameter values (@minCount). Example
                result:</para>
            <programlisting><![CDATA[
<gx:red msg="No XSDs found"             
    filePath="C:/tt/greenfox/resources/example-system/system-s/resources/xsd"
    constraintComp="targetMinCount" 
    constraintID="TargetSize_2-minCount" 
    resourceShapeID="xsdFileShape" 
    minCount="1" 
    actCount="0" 
    targetFoxpath="*.xsd"/>]]></programlisting>
            <para>In a second step we extend our schema with a folder shape whose target consists of
                    <emphasis role="ital">all testcase folders in the system</emphasis>:</para>
            <programlisting><![CDATA[<!-- *** Testcase folder shape *** -->
<folder foxpath=".\\test-*[input][output][config]" id="testcaseFolderShape">
  <targetSize msg="No testcase folders found" minCount="1"/>
  <folderContent 
       closedMsg="Testcase member(s) other than input/output/config, log-*." 
       closed="true">
    <memberFolders names="input, output, config"/>
    <memberFiles names="log-*" minCount="0" maxCount="*"/>
  </folderContent>
    …
</folder>]]></programlisting>
            <para>The target includes all folders found at any depth under the current context
                folder (<code>system-s</code>), matching the name pattern <code>test-*</code> and
                having (at least) three members <code>input</code>, <code>output</code> and
                    <code>config</code>. The <code>&lt;targetSize></code> constraint checks that the
                system contains at least one such folder. The <code>&lt;folderContent></code>
                constraint is checked for each folder in the target, thus for each testcase folder.
                The constraint disallows any additional members except for optional files matching
                    <code>log-*</code>, of which any number is allowed (note the @minCount and
                @maxCount attributes).</para>
            <para>We proceed with a file shape which targets the <code>msg-config.csv</code> file in
                the config folder of the test case:</para>
            <programlisting><![CDATA[<!-- *** msg config file shape -->
  <file foxpath="config\msg-config.csv" id="msgConfigFileShape" ...>
    <targetSize msg="Config file missing" count="1"/>
    ...
  </file>]]></programlisting>
            <para>For any testcase folder which does not contain a file
                    <code>config/msg-config.csv</code>, a violation of the <code>targetSize</code>
                constraint will be reported.</para>
            <para>We want to be more specific: to constrain the <emphasis role="ital">file
                    contents</emphasis>. The file must be a CSV file, and the third column (which
                according to the header row is called <code>returnCode</code>) must contain a value
                which is <code>OK</code> or <code>NOFIND</code> or matches the pattern
                    <code>ERROR_*</code>. We add attributes to the <code>&lt;file></code> element
                which specify how to <emphasis role="bold">parse the CSV file into an XML
                    representation</emphasis> (@mediatype, @csv.separator, @csv.header). As with
                other non-XML mediatypes (e.g. JSON or HTML), an XML view enables us to leverage
                XPath and <emphasis role="ital">express</emphasis> a selection of content items,
                preparing the data material for meaningful and complex validation. </para>
            <para>We insert into the file shape an <code>&lt;xpath></code> element which describes a
                selection of content items and defines a constrait which these items must satisfy
                (expressed by the <code>&lt;in></code> child element): </para>
            <programlisting><![CDATA[<!-- *** msg config file shape -->
<file foxpath="config\msg-config.csv" id="msgConfigFileShape" 
      mediatype="csv" csv.separator="," csv.withHeader="yes">
  ...
  <!-- *** Check - configured return codes ok? -->
  <xpath expr="//returnCode"
         inMsg="Config file contains unknown return code">
    <in>
      <eq>OK</eq>
      <eq>NOFIND</eq>
      <like>ERROR_*</like>
    </in>                                
  </xpath>                    
</file>]]></programlisting>
            <para>The item selection is defined by an XPath expression (provided by @expr), and the
                constraint is specified by the &lt;in> child element: an item must either be equal
                to one of the strings “OK” or “NOFIND”, or it must match the glob pattern “ERROR_*”. </para>
            <para>It is important to understand that the XPath expression is evaluated in the
                context of the <emphasis role="bold">document node</emphasis> of the document
                obtained by parsing the file. Here comes an example of a conformant message
                definition file:</para>
            <programlisting><![CDATA[request,response,returnCode
getFooRQ1.xml,getFooRS1.xml,OK
getFooRQ2.xml,getFooRS2.xml,NOFIND
getFooRQ3.xml,getFooRS3.xml,ERROR_SYSTEM]]></programlisting>
            <para>while this example violates the <code>xpath-in</code> constraint:</para>
            <programlisting><![CDATA[request,response,returnCode
getFooRQ1.xml,getFooRS1.xml,OK
getFooRQ2.xml,getFooRS2.xml,NOFIND
getFooRQ3.xml,getFooRS3.xml,ERROR-SYSTEM]]></programlisting>
            <para>According to the conceptual framework of greenfox, the <code>&lt;xpath></code>
                element does not, as one might expect, represent a constraint, but a <emphasis
                    role="bold">value shape</emphasis>. A value shape is a container combining a
                single <emphasis role="bold">value mapper</emphasis> with a set of constraints: the
                value mapper maps the focus resource to a value (“resource value”), which is
                validated against each one of the constraints. Greenfox supports two kinds of value
                mapper – XPath expression and foxpath expression, and accordingly there are two
                variants of a value shape – <emphasis role="bold">XPath value shape</emphasis>
                (represented by an <code>&lt;xpath></code> element) and <emphasis role="bold"
                    >Foxpath value shape</emphasis> (<code>&lt;foxpath></code>). See section “Schema
                building blocks” for detailed information about value shapes.</para>
            <para>We proceed to check <emphasis role="ital">request message files</emphasis>: for
                each such file, there must be a response file in the output folder, with a name
                derived from the request file name (replacing the last occurrence of substring “RQ”
                with “RS”). This is a constraint which does not depend on file contents, but on file
                system contents found “around” the focus resource. A check requires navigation of
                the file system, rather than file contents. We solve the problem with a Foxpath
                value shape:</para>
            <programlisting><![CDATA[<!-- *** Request file shape *** -->
<file foxpath="input\(*.xml, *.json)" id="requestFileShape">
  ...
  <!-- *** Check - request with response ? -->
  <foxpath 
      expr="..\..\output\*\file-name(.)"
      containsXPathMsg="Request without response"      
      containsXPath="$fileName ! 
                     replace(., '(.*)RQ(.*)$', '$1RS$2')"/>]]></programlisting>
            <para>A Foxpath value shape combines a foxpath expression (@expr) with a set of
                constraints. The expression maps the focus resource to a value, which is validated
                against all constraints. Here we have an expression which maps the focus resource to
                a list of file names found in the <code>output</code> folder. A single constraint,
                represented by the @containsXPath attribute, requires the expression value to
                contain the value of an XPath expression, which maps the request file name to the
                response file name. The constraint is satisfied if and only if the response file is
                present in the <code>output</code> folder.</para>
            <para>As with XPath value shapes, it is important to be aware of the evaluation context.
                We have already seen that in an XPath value shape the initial context item is the
                    <emphasis role="ital">document node</emphasis> obtained by parsing the text of
                the focus resource into an XML representation. In a Foxpath value shape the initial
                context item is the <emphasis role="ital">file path</emphasis> of the focus
                resource, which here is the file path of a request file. The foxpath expression
                starts with two steps along the parent axis (<code>..\..</code>) which lead to the
                enclosing <code>testcase</code> folder, from which navigation to the response files
                and their mapping to file names is trivial: </para>
            <programlisting><![CDATA[  ..\..\output\*\file-name(.)]]></programlisting>
            <para>A Foxpath value shape does not require the focus resource to be parsed into a
                document, as the context is a file path, rather than a document node. Therefore, a
                Foxpath value shape can also be used in a folder shape. We use this possibility in
                order to constrain the <code>codelists</code> folder to contain
                    <code>&lt;codelist></code> elements with a @name attribute and at least one
                    <code>&lt;entry></code> child:</para>
            <programlisting><![CDATA[<!-- *** Codelist folder shape -->
<folder foxpath=".\\resources\codelists" id="codelistFolderShape">
    ...
    <!-- *** Check - folder contains codelists? -->
    <foxpath expr="*.xml/codelist[entry]/@name"  
             minCoutMsg="Codelist folder without codelists"
             minCount="1"/>
    ...
</folder>]]></programlisting>
            <para>Note the aggregative view enabled by the foxpath language: we do not bother with
                individual files but perform a “mixed” navigation, starting with file system
                navigation to all *.xml files, continuing within their collected content (<code>…
                    /codelist[entry]/@name</code>), arriving at @name attributes on non-empty
                    <code>&lt;codelist></code> elements.</para>
            <para>Now we turn to the <emphasis role="ital">response message files</emphasis>. They
                must be “fresh”, that is, have a timestamp of last modification which is after a
                limit timestamp provided by a call parameter of the system validation. This is
                accomplised by a <code>lastModified</code> constraint, which references the
                parameter value. Besides, response files must not be empty (<code>fileSize</code>
                constraint):</para>
            <programlisting><![CDATA[<!-- *** Response file shape *** -->                
<file foxpath="output\(*.xml, *.json)" mediatype="xml-or-json">
    ...                    
    <!-- *** Check - response fresh? *** -->
    <lastModified ge="${lastModified}"
                  geMsg="Stale output file"/>

    <!-- *** Check - response non-empty? *** -->
    <fileSize gt="0" 
              gtMsg="Empty output file"/>
    ...
</file>]]></programlisting>
            <para>The placeholder <code>${lastModified}</code> is substituted by the value passed to
                the greenfox processor as input parameter and declared in the schema as a <emphasis
                    role="ital">context parameter</emphasis>:</para>
            <programlisting><![CDATA[<greenfox ... >
  <!-- *** External context *** -->
  <context>
    <field name="lastModified"/>
  </context>    
  ...
</greenfox>]]></programlisting>
            <para>We have several expecations related to the contents of response files. If the
                response is an XML document (rather than JSON), it must be valid valid against some
                XSD found in the XSD folder. XSD validation is triggered by an <code>xsdValid</code>
                constraint, with a foxpath expression locating the XSD(s) to be used:</para>
            <programlisting><![CDATA[<!-- *** Response file shape *** -->                
<file foxpath="output\(*.xml, *.json)" mediatype="xml-or-json">
    ...
    <!-- *** Check - schema valid? (only if XML) -->
    <ifMediatype eq="xml">
        <xsdValid msg="Response msg not XSD valid" 
                  xsdFoxpath="$domain\resources\xsd\\*.xsd"/>  
    </ifMediatype>
</file>]]></programlisting>
            <para>It is not necessary to specify an individual XSD – the greenfox processor inspects
                all XSDs matching the expression and selects for each file to be validated the
                appropriate XSD. This is achieved by comparing name and namespace of the root
                element with local name and target namespace of all element declarations found in
                the XSDs selected by the foxpath expression. If not exactly one element declaration
                is found, an error is reported, otherwise XSD validation is performed. Note the
                variable reference <code>$domain</code>, which can be referenced in any XPath or
                foxpath expression and which provides the file path of the domain folder. </para>
            <para>The next condition to be checked is that certain values from the response
                (selected by XPath <code>//*:fooValue</code>) are found in a particular codelist.
                Here we use an XPath value shape which contains an <code>ExprValueEqFoxpath</code>
                constraint, represented by the @eqFoxpath attribute:</para>
            <programlisting><![CDATA[<!-- *** Response file shape *** -->                
<file foxpath="output\(*.xml, *.json)" mediatype="xml-or-json">
    ...
   <!-- *** Check - known article number? -->
   <xpath expr="//*:fooValue"
          eqFoxpathMsg="Unknown foo article number"   
          eqFoxpath="$domain\\codelists\*.xml
                     /codelist[@name eq 'foo-article']/entry/@code"/>
 
   </xpath>
</file>]]></programlisting>
            <para>As always with an XPath value shape, the XPath expression (@expr) selects the
                content items to be checked. The <code>ExprValueEqFoxpath</code> constraint works as
                follows: it evaluates the foxpath expression provided by constraint parameter
                    <code>eqFoxpath</code> and checks that every item of the value to be checked
                also occurs in the value of the foxpath expression. As here the foxpath expression
                returns all entries of the appropriate codelist, the constraint is satisfied if and
                only if every <code>fooValue</code> element in the response contains a string found
                in the codelist.</para>
            <para>Note that this value shape works properly for both, XML and JSON responses. Due to
                the @mediatype annotation on the file shape, which is set to
                    <code>xml-or-json</code>, the greenfox processor first attempts to parse the
                file as an XML document. If this does not succeed, it attempts to parse the file as
                a JSON document and transform it into an equivalent XML representation. In either
                case, the XPath expression is evaluated in the context of the document node of the
                resulting XDM node tree. In such cases one has to make sure, of course, that the
                XPath expression can be used in both structures, original XML and XML capturing the
                JSON content, which is the case in our example.</para>
            <para>As a last constraint, we want to check the return code of a response. The expected
                value can be retrieved from the message config file, a CSV file in the
                    <code>config</code> folder: it is the value found in the third column (named
                    <code>returnCode</code>) of the row in which the second column (named
                    <code>response</code>) contains the file name of the response file. We use a
                Foxpath value shape with an expression fetching the expected return value from the
                CSV file. This is accomplished by a mixed navigation, starting with file system
                navigation leading to the CSV file, then drilling down into the file and fetching
                the item of interest. The value against which to compare is retrieved by a trivial
                XPath expression (@eqXPath):</para>
            <programlisting><![CDATA[<!-- *** Response file shape *** -->                
<file foxpath="output\(*.xml, *.json)" mediatype="xml-or-json">
    ...
    <!-- *** Check - return code expected? *** -->
    <foxpath expr="..\..\config\msg-config.csv\csv-doc(., ',', 'yes')
                   //record[response eq $fileName]/returnCode"
             eqXPathMsg="Return code not the configured value"                   
             eqXPath="//*:returnCode"/>
    </foxpath>
</file>]]></programlisting>
            <para>The complete schema is shown in the appendix A1. To summarize, we have developed a
                schema which constrains the presence and contents of folders, the presence and
                contents of files, and relationships between contents of different files, in some
                cases belonging to different mediatypes. The devlopment of the schema demanded
                familiarity with XPath, but no programming skills beyond that. </para>
        </section>
    </section>
    <section>
        <title>RDFe example</title>
        <para>This section introduces RDFe by building an example in several steps.</para>
        <section>
            <title>Getting started</title>
            <para>Consider an XML document describing drugs (contents taken from drugbank <xref
                    linkend="drugbank"/>):</para>
            <programlisting><![CDATA[
<drugs xmlns="http://www.drugbank.ca">
  <drug type="biotech" created="2005-06-13" updated="2018-07-02">
    <drugbank-id primary="true">DB00001</drugbank-id>
    <drugbank-id>BTD00024</drugbank-id>
    <drugbank-id>BIOD00024</drugbank-id>
    <name>Lepirudin</name>
    <!-- more content here -->
    <pathways>
      <pathway>
        <!-- more content here -->
        <enzymes>
          <uniprot-id>P00734</uniprot-id>
          <uniprot-id>P00748</uniprot-id>
          <uniprot-id>P02452</uniprot-id>
          <!-- more content follows -->
        </enzymes>
      </pathway>
    </pathways>
    <!-- more content here -->
  </drug>
  <!-- more drugs here -->
</drugs>]]></programlisting>
            <para>We want to map parts of these descriptions to an RDF representation. First goals: </para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>Assign an IRI to each drug</para>
                </listitem>
                <listitem>
                    <para>Construct triples describing the drug</para>
                </listitem>
            </itemizedlist>
            <para>The details are outlined in the table below. Within XPath expressions, variable
                $drug references the XML element representing the resource.</para>
            <table xml:id="table-101">
                <title>A simple model deriving RDF resource descriptions from XML data.</title>
                <titleabbrev xml:id="table-101-shorttitle"
                    >Example-mappings-property-xpath</titleabbrev>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="2*"/>
                    <colspec colname="c2" colnum="2" colwidth="2*"/>
                    <colspec colname="c3" colnum="3" colwidth="6*"/>
                    <thead>
                        <row>
                            <entry align="left" namest="c1" nameend="c3" rowsep="0" colsep="0"
                                >Resource IRI expression (XPath)</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry colsep="0"/>
                            <entry align="left" namest="c2" nameend="c3"
                                >$drug/db:drugbank-id[@primary = 'true']/concat('drug:', .)</entry>
                        </row>
                    </tbody>
                </tgroup>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="2*"/>
                    <colspec colname="c2" colnum="2" colwidth="2*"/>
                    <colspec colname="c3" colnum="3" colwidth="6*"/>
                    <thead>
                        <row>
                            <entry align="left">Property IRI</entry>
                            <entry align="left">Property type</entry>
                            <entry align="left">Property value expression (XPath)</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry align="left">rdf:type</entry>
                            <entry align="left">xs:string</entry>
                            <entry align="left">'ont:drug'</entry>
                        </row>
                        <row>
                            <entry align="left">ont:name</entry>
                            <entry align="left">xs:string</entry>
                            <entry align="left">$drug/name</entry>
                        </row>
                        <row>
                            <entry align="left">ont:updated</entry>
                            <entry align="left">xs:date</entry>
                            <entry align="left">$drug/@updated</entry>
                        </row>
                        <row>
                            <entry align="left">ont:drugbank-id</entry>
                            <entry align="left">xs:string</entry>
                            <entry align="left">$drug/db:drugbank-id[@primary = 'true']</entry>
                        </row>
                        <row>
                            <entry align="left">ont:drugbank-altid</entry>
                            <entry align="left">xs:string</entry>
                            <entry align="left">$drug/db:drugbank-id[not(@primary = 'true')]</entry>
                        </row>
                        <row>
                            <entry align="left">ont:enzyme</entry>
                            <entry align="left">IRI</entry>
                            <entry align="left">$drug//db:enzymes/db:uniprot-id/concat('uniprot:',
                                .)</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>This model is easily translated into an RDFe document, also called a <emphasis
                    role="bold">semantic map:</emphasis></para>
            <programlisting><![CDATA[<re:semanticMap iri="http://example.com/semap/drugbank/"
                targetNamespace="http://www.drugbank.ca"
                targetName="drugs"
                xmlns:re="http://www.rdfe.org/ns/model"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:db="http://www.drugbank.ca">
    
  <re:namespace iri="http://example.com/resource/drug/" prefix="drug"/>
  <re:namespace iri="http://example.com/ontology/drugbank/" prefix="ont"/>
  <re:namespace iri="http://www.w3.org/2000/01/rdf-schema#" prefix="rdfs"/>    
  <re:namespace iri="http://bio2rdf.org/uniprot:" prefix="uniprot"/>
    
  <re:resource modelID="drug" 
               assertedTargetNodes="/db:drugs/db:drug" 
               targetNodeNamespace="http://www.drugbank.ca"
               targetNodeName="drug"
               iri="db:drugbank-id[@primary = 'true']/concat('drug:', .)" 
               type="ont:drug">
    <re:property iri="rdfs:label" 
                 value="db:name" 
                 type="xs:string"/>        
    <re:property iri="ont:updated" 
                 value="@updated" 
                 type="xs:date"/>
    <re:property iri="ont:drugbank-id" 
                 value="db:drugbank-id[@primary = 'true']" 
                 type="xs:string"/>
    <re:property iri="ont:drugbank-alt-id" 
                 value="db:drugbank-id[not(@primary = 'true')]"  
                 type="xs:string"/>
    <re:property iri="ont:enzyme" 
                 value=".//db:enzymes/db:uniprot-id/concat('uniprot:', .)" 
                 type="#iri"/>
  </re:resource>
    
</re:semanticMap>]]></programlisting>
            <para>The triples are generated by an <emphasis role="bold">RDFe processor</emphasis>,
                to which we pass the XML document and the semantic map. Command line
                invocation:</para>
            <programlisting>  shax "rdfe?dox=drugs.xml,semap=drugbank.rdfe.xml"</programlisting>
            <para>The result is a set of RDF triples in Turtle <xref linkend="turtle"/>
                syntax:</para>
            <programlisting><![CDATA[@prefix drug: <http://example.com/resource/drug/> .
@prefix ont: <http://example.com/ontology/drugbank/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix uniprot: <http://bio2rdf.org/uniprot:> .

drug:DB00001 
        rdf:type            ont:drug ;
        rdfs:label          "Lepirudin" ;
        ont:updated         "2018-07-02"^^xs:date ;
        ont:drugbank-id     "DB00001" ;
        ont:drugbank-alt-id "BTD00024" ;
        ont:drugbank-alt-id "BIOD00024" ;
        ont:enzyme          uniprot:P00734 ;
        ont:enzyme          uniprot:P00748 ;
        ont:enzyme          uniprot:P02452 ;
             …
drug:DB00002 
        rdf:type ont:drug ; 
             …
drug:DB00003 
        rdf:type ont:drug ;
             …
…]]></programlisting>
            <para>Some explanations should enable a basic understanding of how the semantic map
                controls the output. The basic building block of a semantic map is a <emphasis
                    role="bold">resource model</emphasis>. It defines how to construct the triples
                describing a resource represented by an XML node:</para>
            <programlisting><![CDATA[<re:resource modelID="drug" 
             assertedTargetNodes="/db:drugs/db:drug" 
             iri="db:drugbank-id[@primary eq 'true']/concat('drug:', .)" 
             type="ont:drug">
  <re:property iri="rdfs:label" 
    value="db:name" 
    type="xs:string"/>        
  <!-- more property models here -->
</re:resource> 
]]></programlisting>
            <para>The @iri attribute on <code>&lt;resource></code> provides an XPath expression
                yielding the resource IRI. The expression is evaluated <emphasis role="ital">in the
                    context of the XML node representing the resource</emphasis>. Note how the
                expression language XPath is used in order to describe the IRI as a concatenation of
                a literal prefix and a data-dependent suffix. Every node returned by the expression
                in @assertedTargetNodes, evaluated <emphasis role="ital">in the context of the input
                    document</emphasis>, is mapped to a resource description as specified by this
                resource model element.</para>
            <para>Each <code>&lt;property></code> child element adds to the resource model a
                    <emphasis role="bold">property model</emphasis>. It describes how to construct
                triples with a particular property IRI. The property IRI is given by @iri, and the
                property values are obtained by evaluating the expression in @value, <emphasis
                    role="ital">using the node representing the resource as context node</emphasis>.
                (In our example, the value expressions are evaluated in the context of a
                    <code>&lt;drug></code> element.) As the examples show, the XPath language may be
                used freely, for example combining navigation with other operations like
                concatenation. The datatype of the property values is specified by the @type
                attribute on <code>&lt;property></code>. The special value <code>#iri</code> signals
                that the value is an IRI, rather than a typed literal. Another special value,
                    <code>#resource</code>, will be explained in the following section.</para>
        </section>
        <section xml:id="linking-resources">
            <title>Linking resources</title>
            <para>Our drug document references articles:</para>
            <programlisting><![CDATA[<drugs xmlns="http://www.drugbank.ca">
  <drug type="biotech" created="2005-06-13" updated="2018-07-02">
    <drugbank-id primary="true">DB00001</drugbank-id>
   <!-- more content here -->
    <general-references>
      <articles>
        <article>
          <pubmed-id>16244762</pubmed-id>
          <citation>
            Smythe MA, Stephens JL, Koerber JM, Mattson JC: A c…</citation>
        </article>
        <!-- more articles here -->
      </articles>
    </general-references>
   <!-- more content here -->
</drugs>
]]></programlisting>
            <para>RDF is about connecting resources, and therefore our RDF data will be more
                valuable if the description of a drug references <emphasis role="Ital">article
                    IRIs</emphasis> which give access to <emphasis role="ital">article resource
                    descriptions</emphasis> - rather than including properties with literal values
                which represent properties of the article in question, like its title and authors. </para>
            <para>Assume we have access to a document describing articles:</para>
            <programlisting><![CDATA[<articles>
  <article>
    <pubmed-id>16244762</pubmed-id>
    <url>https://doi.org/10.1177/107602960501100403</url>
    <doi>10.1177/107602960501100403</doi>
    <authors>
      <author>Smythe MA</author>
      <author>Stephens JL</author>
      <author>Koerber JM</author>
      <author>Mattson JC</author>            
    </authors>
    <title>A comparison of lepirudin and argatroban outcomes</title>
    <keywords>
      <keyword>Argatroban</keyword>
      <keyword>Lepirudin</keyword>
      <keyword>Direct thrombin inhibitors</keyword>
    </keywords>
    <citation>Smythe MA, Stephens JL, Koerber JM, Mattson JC: A ...</citation>
    <abstract> Although both argatroban and lepirudin are used ...</abstract>
  </article>
  <!—more articles here -->
</articles>
]]></programlisting>
            <para>We write a second semantic map for this document about articles:</para>
            <programlisting><![CDATA[<re:semanticMap  iri="http://example.com/semap/articles/"
                 targetNamespace="" targetName="articles" …>
  <re:namespace iri="http://example.com/resource/article/" prefix="art"/>
  <!-- more namespace descriptors here -->
  <re:resource modelID="article" iri="pubmed-id/concat('art:', .)"
               targetNodeNamespace=""
               targetNodeName="article"
               type="ont:article">        
   <re:property iri="ont:doi" value="doi" type="xs:string"/>        
   <re:property iri="ont:url" value="url" type="xs:string"/>
   <re:property iri="ont:author" value=".//author" list="true" type="xs:string"/>
   <re:property iri="ont:title" value="title" type="xs:string"/>        
   <re:property iri="ont:keyword" value="keywords/keyword" type="xs:string"/>
   <re:property iri="ont:abstract" value="abstract" type="xs:string"/>
   <re:property iri="ont:citation" value="citation" type="xs:string"/>
  </re:resource>
</re:semanticMap/>
]]></programlisting>
            <para>and we extend the resource model of a drug by a property <emphasis role="ital"
                    >referencing the article resource</emphasis>, relying on its XML representation
                provided by an <code>&lt;article></code> element:</para>
            <programlisting><![CDATA[<re:property iri="ont:ref-article" 
  value="for $id in .//db:article/db:pubmed-id return 
         doc('/ress/drugbank/articles.xml')//article[pubmed-id eq $id]" 
  type="#resource"/>
]]></programlisting>
            <para>The value expression fetches the values of <code>&lt;pubmed-id></code> children of
                    <code>&lt;article></code> elements contained by the <code>&lt;drug></code>
                element, and it uses these values in order to navigate to the corresponding
                    <code>&lt;article></code> element <emphasis role="ital">in a different
                    document</emphasis>. This document need not be provided by the initial input –
                documents can be discovered during processing. While the items obtained from the
                value expression are <code>&lt;article></code>
                <emphasis role="ital">elements</emphasis>, the triple objects must be article
                    <emphasis role="ital">IRIs</emphasis> giving access to article <emphasis
                    role="ital">resource descriptions</emphasis>. Therefore two things must be
                accomplished: first, the output must include triples describing the referenced
                articles; second, the <code>ont:ref-article</code> property of a drug must have an
                object which is the article IRI used as the subject of triples describing this
                article. The article IRI, as well as the triples describing the article are obtained
                by applying the <emphasis role="ital">article resource model</emphasis> to the
                article element. All this is accomplished by the RDFe processor whenever it detects
                the property type <code>#resource</code>. Our output is extended accordingly:</para>
            <programlisting>drug:DB00001 a ont:drug ;
   rdfs:label        "Lepirudin" ;
   …
   ont:ref-article   <emphasis role="bold">art:16244762</emphasis> ;
        …
<emphasis role="bold">art:16244762</emphasis> a ont:article ;
   ont:abstract  "Although both argatroban and lepirudin are used for ..." ;
   ont:author    "Stephens JL" , "Koerber JM" , "Mattson JC" , "Smythe MA" ;
   ont:citation  "Smythe MA, Stephens JL, Koerber JM, Mattson JC: A com … " ;
   ont:doi       "10.1177/107602960501100403" ;
   ont:keyword   "Argatroban" , "Lepirudin" , "Direct thrombin inhibitors" ;
   ont:title     "A comparison of lepirudin and argatroban outcomes" ;
   ont:url       "https://doi.org/10.1177/107602960501100403" .
</programlisting>
        </section>
        <section>
            <title>Adding a dynamic context</title>
            <para>The property model which we just added to the resource model for drugs contains a
                “difficult” value expression – an expression which is challenging to write, to read
                and to maintain:</para>
            <programlisting><![CDATA[  for $id in .//db:article/db:pubmed-id return 
  doc('/products/drugbank/articles.xml')//article[pubmed-id eq $id]"
]]></programlisting>
            <para>We can simplify the expression by defining a <emphasis role="bold">dynamic
                    context</emphasis> and referencing a context variable. A
                    <code>&lt;context></code> element represents the <emphasis role="ital"
                    >constructor</emphasis> of a dynamic context:</para>
            <programlisting><![CDATA[<re:semanticMap  iri="http://example.com/semap/drugbank/" …>
  ...
  <re:context>
    <re:var name="articlesURI" value="'/products/drugbank/articles.xml'"/>
    <re:var name="articlesDoc" value="doc($articlesURI)"/>
  </re:context>
      …
</re:semanticMap>
]]></programlisting>
            <para>The values of context variables are specified by XPath expressions. Their
                evaluation context is the root element of an input document, so that variable values
                may reflect document contents. A context constructor is evaluated once for each
                input document. The context variables are available in any expression within the
                semantic map containing the context constructor (excepting expressions in preceding
                siblings of the <code>&lt;var></code> element defining the variable). Now we can
                simplify our expression to</para>
            <programlisting>  for $id in .//db:article/db:pubmed-id return 
  <emphasis role="bold">$articlesDoc</emphasis>//article[pubmed-id eq $id]
</programlisting>
            <para>As a context constructor may also define <emphasis role="ital"
                    >functions</emphasis>, we may further simplify the value expression by turning
                the navigation to the appropriate <code>&lt;article></code> element into a function.
                The function is defined by a <code>&lt;fun></code> child element of
                    <code>&lt;context></code>. We define a function with a single formal parameter,
                which is a pubmed ID:</para>
            <programlisting><![CDATA[<re:context>
  <re:var name="articlesURI" value="'/products/drugbank/articles.xml'"/>
  <re:var name="articlesDoc" value="doc($articlesURI)"/>
  <re:fun name="getArticleElem" params="id"
          code="$articlesDoc//article[pubmed-id eq $id]"/>
  </re:function>            
</re:context>]]></programlisting>
            <para>Expressions in this semantic map can reference the function by the name
                    <code>getArticleElem</code>. A new version of the value expression is
                this:</para>
            <programlisting>  .//db:article/db:pubmed-id/<emphasis role="bold">$getArticleElem</emphasis>(.)</programlisting>
            <para>For each input document a distinct instance of the context is constructed, using
                the document root as context node. This means that the context may reflect the
                contents of the input document. The following example demonstrates the possibility:
                in order to avoid repeated navigation to the <code>&lt;article></code> elements, we
                introduce a dictionary which maps all Pubmed IDs used in the input document to
                    <code>&lt;article></code> elements:</para>
            <programlisting><![CDATA[  <re:var name="articleElemDict" 
          value="map:merge(distinct-values(//db:article/db:pubmed-id)
                           ! map:entry(., $getArticleElem(.)))"/>]]></programlisting>
            <para>An updated version of the value expression takes advantage of the
                dictionary:</para>
            <programlisting>  .//db:article/db:pubmed-id/<emphasis role="bold">$articleElemDict</emphasis>(.)</programlisting>
            <para>The dictionary contains only those Pubmed IDs which are actually used in a
                particular input document. For each input document, a distinct instance of the
                dictionary is constructed, which is bound to the context variable
                    <code>$articleElemDict</code> whenever data from that document are
                evaluated.</para>
        </section>
    </section>
    <section xml:id="rdfe-language">
        <title>RDFe language</title>
        <para>RDFe is an XML language for defining the mapping of XML documents to RDF triples. A
            mapping is described by one or more RDFe documents. An RDFe document has a
                <code>&lt;semanticMap></code> root element. All elements are in the namespace
                <code>http://www.rdfe.org/ns/model</code> and all attributes are in no namespace.
            Document contents are constrained by an XSD (found here: <xref linkend="shax"/>,
                <code>xsd</code> folder). The following treesheet representation <xref
                linkend="location-trees"/>
            <xref linkend="xsdplus"/> of the schema uses the pseudo type <code>re:XPATH</code> in
            order to indicate that a string must be a valid XPath expression, version 3.1 or
            higher.</para>
        <programlisting><emphasis role="bold">semanticMap</emphasis>
. @iri . ... ... ... ... ... ty: xs:anyURI
. @targetNamespace . ... ... ty: Union({xs:anyURI}, {xs:string: len=0}, 
                                       {xs:string: enum=(*)})
. @targetName .. ... ... ... ty: Union({xs:NCName}, {xs:string: enum=(*)})
. <emphasis role="bold">targetAssertion</emphasis>* . ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . @expr? . ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. <emphasis role="bold">import</emphasis>*
. . @href .. ... ... ... ... ty: xs:anyURI
. <emphasis role="bold">namespace</emphasis>*
. . @iri ... ... ... ... ... ty: xs:anyURI
. . @prefix  ... ... ... ... ty: xs:NCName
. <emphasis role="bold">context</emphasis>?
. . _choice_*
. . 1 <emphasis role="bold">var</emphasis> .. ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . 1 . @name .. ... ... ... ty: xs:NCName
. . 1 . @value?  ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . 2 <emphasis role="bold">fun</emphasis> .. ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . 2 . @name .. ... ... ... ty: xs:NCName
. . 2 . @params? ... ... ... ty: xs:string: pattern=#(\i\c*(\s*,\s*\i\c*)?)?#
. . 2 . @as? ... ... ... ... ty: xs:Name
. . 2 . @code? . ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. <emphasis role="bold">resource</emphasis>*
. . @modelID ... ... ... ... ty: xs:NCName
. . @assertedTargetNodes? .. ty: <emphasis role="ital">re:XPATH</emphasis>
. . @iri? .. ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . @type? . ... ... ... ... ty: List(xs:Name)
. . @targetNodeNamespace? .. ty: Union({xs:anyURI}, {xs:string: len=0}, 
                                       {xs:string: enum=(*)})
. . @targetNodeName? ... ... ty: Union({xs:NCName}, {xs:string: enum=(*)})
. . targetNodeAssertion* ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . . @expr? ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . <emphasis role="bold">property</emphasis>*
. . . @iri . ... ... ... ... ty: xs:anyURI
. . . @value ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . . @type? ... ... ... ... ty: Union({xs:Name}, 
                                       {xs:string: enum=(#iri|#resource)})
. . . @list? ... ... ... ... ty: xs:boolean
. . . @objectModelID? .. ... ty: xs:Name
. . . @card? ... ... ... ... ty: xs:string: pattern=#[?*+]|\d+(-(\d+)?)?|-\d+#
. . . @reverse?  ... ... ... ty: xs:boolean
. . . @lang? ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . . <emphasis role="bold">valueItemCase</emphasis>*
. . . . @test .. ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . . . @iri? .. ... ... ... ty: xs:anyURI
. . . . @value?  ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . . . @type? . ... ... ... ty: Union({xs:Name}, 
                                       {xs:string: enum=(#iri|#resource)})
. . . . @list? . ... ... ... ty: xs:boolean
. . . . @objectModelID?  ... ty: xs:Name
. . . . @lang? . ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
</programlisting>
    </section>
    <section>
        <title>RDFe model components</title>
        <para>This section summarizes the main components of an RDFe based mapping model. Details of
            the XML representation can be looked up in the treesheet representation shown in the
            preceding section.</para>
        <section>
            <title>Semantic extension</title>
            <para>A <emphasis role="bold">semantic extension</emphasis> is a set of one or more
                semantic maps, together defining a mapping of XML documents to a set of RDF triples.
                A semantic extension comprises all semantic maps explicitly provided as input for an
                instance of RDFe processing, as well as all maps directly or indirectly imported by
                these (see below).</para>
        </section>
        <section>
            <title>Semantic map</title>
            <para>A <emphasis role="bold">semantic map</emphasis> is a specification how to map a
                class of XML documents (defined in terms of target document constraints) to a set of
                RDF triples. It is represented by a <code>&lt;semanticMap></code> element and
                comprises the components summarized below.</para>
            <table xml:id="table-2">
                <title>Semantic map components and their XML representation.</title>
                <titleabbrev xml:id="table-2-shorttitle"
                    >model-components-and-their-xml-representation</titleabbrev>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="2*"/>
                    <colspec colname="c2" colnum="2" colwidth="2.5*"/>
                    <colspec colname="c3" colnum="3" colwidth="2*"/>
                    <thead>
                        <row>
                            <entry align="left" namest="c1" nameend="c2">Model component</entry>
                            <entry align="left">XML representation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry namest="c1" nameend="c2">Semantic map IRI</entry>
                            <entry align="left">@iri</entry>
                        </row>
                        <row>
                            <entry rowsep="0" colsep="0" namest="c1" nameend="c1">Target document
                                constraint</entry>
                            <entry rowsep="1" colsep="1" namest="c2" nameend="c2"/>
                            <entry rowsep="1" colsep="0" namest="c3" nameend="c3"/>
                        </row>
                        <row>
                            <entry rowsep="0"/>
                            <entry align="left">Target document namespace</entry>
                            <entry align="left">@targetNamespace</entry>
                        </row>
                        <row>
                            <entry rowsep="0"/>
                            <entry align="left">Target document local name</entry>
                            <entry align="left">@targetName</entry>
                        </row>
                        <row>
                            <entry/>
                            <entry align="left">Target assertions</entry>
                            <entry align="left">&lt;targetAssertion></entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Semantic map imports</entry>
                            <entry align="left">&lt;import></entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">RDF namespace bindings</entry>
                            <entry align="left">&lt;namespace></entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Context constructor</entry>
                            <entry align="left">&lt;context></entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Resource models</entry>
                            <entry align="left">&lt;resource></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>A <emphasis role="ital">semantic map IRI</emphasis> identifies a semantic map
                unambiguously. The map IRI should be independent of the document URI.</para>
            <para>The <emphasis role="ital">target document constraint</emphasis> is a set of
                conditions met by any XML document to which the semantic map may be applied. The
                constraint enables a decision whether resource models from the semantic map can be
                used in order to map nodes from a given XML document to RDF resource descriptions. A
                target document assertion is an XPath expression, to be evaluated in the context of
                a document root. A typical use of target document assertions is a check of the API
                or schema version indicated by an attribute of the input document.</para>
            <para>A semantic map may <emphasis role="ital">import</emphasis> other semantic maps.
                Import is transitive, so that any map reachable through a chain of imports is
                treated as imported. Imported maps are added to the semantic extension, and no
                distinction is made between imported maps and those which have been explicitly
                supplied as input.</para>
            <para><emphasis role="ital">RDF namespace bindings</emphasis> define prefixes used in
                the output for representing IRI values in compact form. Note that they are <emphasis
                    role="ital">not</emphasis> used for resolving namespace prefixes used in XML
                names and XPath expressions. During evaluation, XML prefixes are always resolved
                according to the in-scope namespace bindings established by namespace declarations
                    (<code>xmlns</code>).</para>
            <para><emphasis role="ital">Context constructor</emphasis> and <emphasis role="ital"
                    >resource models</emphasis> are described in subsequent sections.</para>
        </section>
        <section xml:id="resource-model">
            <title>Resource model</title>
            <para>A <emphasis role="bold">resource model</emphasis> is a set of rules how to
                construct triples describing a resource which is viewed as represented by a given
                XML node. A resource model is represented by a <code>&lt;resource></code> element
                and comprises the components summarized below.</para>
            <table xml:id="table-3">
                <title>Resource model components and their XML representation.</title>
                <titleabbrev xml:id="table-3-shorttitle"
                    >resource-model-components-and-their-xml-representation</titleabbrev>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="2*"/>
                    <colspec colname="c2" colnum="2" colwidth="2.5*"/>
                    <colspec colname="c3" colnum="3" colwidth="2*"/>
                    <thead>
                        <row>
                            <entry align="left" namest="c1" nameend="c2">Model component</entry>
                            <entry align="left">XML representation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry namest="c1" nameend="c2">Resource model ID</entry>
                            <entry align="left">@modelID</entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Resource IRI expression</entry>
                            <entry align="left">@iri</entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Target node assertion</entry>
                            <entry align="left">@assertedTargetNodes</entry>
                        </row>
                        <row>
                            <entry rowsep="0" colsep="0" namest="c1" nameend="c1">Target node
                                constraint</entry>
                            <entry rowsep="1" colsep="1" namest="c2" nameend="c2"/>
                            <entry rowsep="1" colsep="0" namest="c3" nameend="c3"/>
                        </row>
                        <row>
                            <entry rowsep="0"/>
                            <entry align="left">Target node namespace</entry>
                            <entry align="left">@targetNodeNamespace</entry>
                        </row>
                        <row>
                            <entry rowsep="0"/>
                            <entry align="left">Target node local name</entry>
                            <entry align="left">@targetNodeName</entry>
                        </row>
                        <row>
                            <entry/>
                            <entry align="left">Target node assertions</entry>
                            <entry align="left">&lt;targetNodeAssertion></entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Resource type IRIs</entry>
                            <entry align="left">@type</entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Property models</entry>
                            <entry align="left">&lt;property></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>The <emphasis role="ital">resource model ID</emphasis> is used for purposes of
                cross reference. A resource model has an implicit resource model IRI obtained by
                appending the resource model ID to the semantic map IRI (with a hash character (“#”)
                inserted in between if the semantic map IRI does not end with “/” or “#”).</para>
            <para>The <emphasis role="ital">resource IRI expression</emphasis> yields the IRI of the
                resource. The expression is evaluated using as context item the XML node used as
                target of the resource model.</para>
            <para>A <emphasis role="ital">target node assertion</emphasis> is an expression to be
                evaluated in the context of each input document passed to an instance of RDFe
                processing. The expression yields a sequence of nodes which MUST be mapped to RDF
                descriptions. Note that the processing result is not limited to these resource
                descriptions, as further descriptions may be triggered as explained in <xref
                    linkend="linking-resources"/>.</para>
            <para>A <emphasis role="ital">target node constraint</emphasis> is a set of conditions
                which is evaluated when selecting the resource model which is appropriate for a
                given XML node. It is used in particular when a property model treats XML nodes
                returned by a value expression as representations of an RDF description (for details
                see <xref linkend="linking-resources"/>).</para>
            <para><emphasis role="ital">Resource type IRIs</emphasis> identify the RDF types of the
                resource (<code>rdf:type</code> property values). The types are specified as literal
                IRI values.</para>
            <para><emphasis role="ital">Property models</emphasis> are explained in the following
                section. </para>
        </section>
        <section xml:id="property-model">
            <title>Property model</title>
            <para>A <emphasis role="bold">property model</emphasis> is represented by a
                    <code>&lt;property></code> child element of a <code>&lt;resource></code>
                element. The following table summarizes the major model components.</para>
            <table xml:id="table-4">
                <title>Property model components and their XML representation.</title>
                <titleabbrev xml:id="table-4-shorttitle"
                    >property-model-components-and-their-xml-representation</titleabbrev>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="3*"/>
                    <colspec colname="c2" colnum="2" colwidth="1*"/>
                    <thead>
                        <row>
                            <entry align="left">Model component</entry>
                            <entry align="left">XML representation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry align="left">Property IRI</entry>
                            <entry align="left">@iri</entry>
                        </row>
                        <row>
                            <entry align="left">Object value expression</entry>
                            <entry align="left">@value</entry>
                        </row>
                        <row>
                            <entry align="left">Object type (IRI or token)</entry>
                            <entry align="left">@type</entry>
                        </row>
                        <row>
                            <entry align="left">Object language tag</entry>
                            <entry align="left">@lang</entry>
                        </row>
                        <row>
                            <entry align="left">Object resource model (IRI or ID)</entry>
                            <entry align="left">@objectModelID</entry>
                        </row>
                        <row>
                            <entry align="left">RDF list flag</entry>
                            <entry align="left">@list</entry>
                        </row>
                        <row>
                            <entry align="left">Reverse property flag</entry>
                            <entry align="left">@reverse</entry>
                        </row>
                        <row>
                            <entry align="left">Conditional settings</entry>
                            <entry align="left">&lt;valueItemCase></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>The <emphasis role="ital">property IRI</emphasis> defines the IRI of the property.
                It is specified as a literal value.</para>
            <para>The <emphasis role="ital">object value expression</emphasis> yields XDM items
                    <xref linkend="xdm31"/> which are mapped to RDF terms in accordance with the
                settings of the property model, e.g. the object type. For each term a triple is
                constructed, using the term as object, a subject IRI obtained from the IRI
                expression of the containing resource model, and a property IRI as specified.</para>
            <para>The <emphasis role="ital">object type</emphasis> controls the mapping of the XDM
                items obtained from the object value expression to RDF terms used as triple objects.
                The object type can be an XSD data type, the token <code>#iri</code> denoting a
                resource IRI, or the token <code>#resource</code>. The latter token signals that the
                triple object is the subject IRI used by the resource description obtained for the
                value item, which must be a node. The resource description is the result of applying
                to the value node an appropriate resource model, which is either explicitly
                specified (@objectModelID) or determined by matching the node against the target
                node constraints of the available resource models.</para>
            <para>The <emphasis role="ital">language tag</emphasis> is used to turn the object value
                into a language-tagged string.</para>
            <para>The <emphasis role="ital">object resource model</emphasis> is evaluated in
                conjunction with object type <code>#resource</code>. It identifies a resource model
                to be used when mapping value nodes yielded by the object value expression to
                resource descriptions.</para>
            <para>The <emphasis role="ital">RDF list flag</emphasis> indicates whether or not the
                RDF terms obtained from the object value expression are arranged as an RDF list
                (default: no).</para>
            <para>The <emphasis role="ital">reverse flag</emphasis> can indicate that the items
                obtained from the object value expression represent the subjects, rather than
                objects, of the triples to be constructed, in which case the target node of the
                containing resource model becomes the triple object. </para>
            <para><emphasis role="ital">Conditional settings</emphasis> is a container for settings
                (e.g. property IRI or object type IRI) applied only to those value items which meet
                a condition. The condition is expressed by an XPath expression which references the
                value item as an additional context variable (<code>rdfe:value</code>). </para>
        </section>
        <section xml:id="construct-constructor">
            <title>Context constructor</title>
            <para>Using RDFe, the construction of RDF triples is based on the evaluation of XPath
                expressions. Evaluation can be supported by an <emphasis role="bold">evaluation
                    context</emphasis> consisting of variables and functions accessible within the
                expression. The context is obtained from a <emphasis role="ital">context
                    constructor</emphasis> represented by a <code>&lt;context></code> element. A
                distinct instance of the context is constructed for each XML document containing a
                node which is used as context node by an expression from the semantic map defining
                the context. The context constructor is a collection of variable and function
                constructors. Variable constructors associate a name with an XQuery expression
                providing the value. Function constructors associate a name with an XQuery function
                defined in terms of parameter names, return value type and an expression providing
                the function value. As the expressions used by the variable and function
                constructors are evaluated in the context of the root element of the document in
                question, variable values as well as function behaviour may reflect the contents of
                the document. Variable values may have any type defined by the XDM data model,
                version 3.1 <xref linkend="xdm31"/> (sequences of items which may be atom, node,
                map, array or function). Context functions are called within expressions like normal
                functions, yet provide behaviour defined by the semantic map and possibly dependent
                on document contents.</para>
        </section>
    </section>
    <section>
        <title>Evaluation</title>
        <para>Semantic maps are evaluated by an <emphasis role="bold">RDFe processor</emphasis>.
            This section describes the processing in an informal way. See also <xref
                linkend="appendix-formal-definition"/>.</para>
        <section>
            <title>Input / Ouput</title>
            <para>Processing input is</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>An initial set of XML documents</para>
                </listitem>
                <listitem>
                    <para>A set of semantic map documents</para>
                </listitem>
            </itemizedlist>
            <para>Processing output is a set of RDF triples, usually designed to express semantic
                content of the XML documents.</para>
            <para>The set of <emphasis role="bold">contributing semantic maps</emphasis> consists of
                the set explicitly supplied, as well as all semantic maps directly or indirectly
                imported by them.</para>
            <para>The set of <emphasis role="bold">contributing XML documents</emphasis> is not
                limited to the <emphasis role="ital">initial</emphasis> input documents, as
                expressions used to construct triples my access other documents by derefencing URIs
                found in documents or semantic maps. This is an example of navigation into a
                document which may not have been part of the initial set of input documents: </para>
            <programlisting><![CDATA[ <re:property iri="ont:country" type="#resource" 
              value="country/@href/doc(.)//country"/>]]></programlisting>
            <para>RDFe thus supports a linked data view.</para>
        </section>
        <section xml:id="hybrid-triples">
            <title>Hybrid triples and preliminary resource description</title>
            <para>Understanding the processing of semantic maps is facilitated by the auxiliary
                concepts of a “hybrid triple” and a “preliminary resource description”. When a
                property model uses the type specification <code>#resource</code>, the nodes
                obtained from the object value expression of the property model are viewed as
                    <emphasis role="ital">XML nodes representing resources</emphasis>, and the
                triple objects are the <emphasis role="ital">IRIs of these resources</emphasis>. The
                resource is identified by the combined identities of XML node and resource model to
                be used in order to map the node to a resource description. When this resource has
                already been described in an earlier phase of the evaluation, the IRI is available
                and the triple can be constructed. If the resource description has not yet been
                created, the IRI is still unknown and the triple cannot yet be constructed. In this
                situation, a <emphasis role="bold">hybrid triple</emphasis> is constructed, using
                the pair of XML node and resource model ID as object. A hybrid triple is a
                preliminary representation of the triple eventually to be constructed. A resource
                description is called <emphasis role="bold">preliminary</emphasis> or <emphasis
                    role="bold">final</emphasis>, dependent on whether or not it contains hybrid
                triples. A preliminary description is turned into a final description by creating
                for each hybrid triple a resource description and replacing the hybrid triple object
                by the subject IRI used by that description. The resource description created for
                the hybrid triple object may itself contain hybrid triples, but in any case it
                provides the IRI required to finalize the hybrid triple currently processed. If the
                new resource description is preliminary, it will be finalized in the same way, by
                creating for each hybrid triple yet another resource description which also provides
                the required IRI. In general, the finalization of preliminary resource descriptions
                is a recursive processing which ends when any new resource descriptions are
                final.</para>
        </section>
        <section>
            <title>Asserted target nodes</title>
            <para>The scope of processing is controlled by the <emphasis role="bold">asserted
                    resource descriptions</emphasis>, the set of resource descriptions which MUST be
                constructed, given a set of semantic maps and an <emphasis role="ital"
                    >initial</emphasis> set of XML documents. Such a description is identified by an
                XML node representing the resource and a resource model ID identifying the model to
                be used for mapping the node to an RDF description. (Note that for a single XML node
                more than one mapping may be defined, that is, more than one resource model may
                accept the same XML node as a target.) The <emphasis role="bold">asserted target
                    nodes</emphasis> of a resource model are the XML nodes to which the resource
                model must be applied in order to create all asserted resource descriptions
                involving this resource model.</para>
            <para>Any <emphasis role="bold">additional resource descriptions</emphasis> are only
                constructed if they are required in order to construct an asserted resource
                description. An additional resource description is required if without this
                description another description (asserted or itself additional) would be
                preliminary, that is, contain hybrid triples. As the discovery of required resource
                descriptions may entail the discovery of further required resource descriptions, the
                discovery process is recursive, as explained in <xref linkend="hybrid-triples"
                />.</para>
            <para>The asserted target nodes of a resource model are determined by the <emphasis
                    role="bold">target node assertion</emphasis> of the resource model, an
                expression evaluated in the context of each <emphasis role="ital">initial</emphasis>
                XML document. Note that the target node assertion is not applied to XML documents
                which do not belong to the initial set of XML documents. Such additional documents
                contribute only additional resource descriptions, no asserted resource descriptions.
                Initial documents, on the other hand, may contribute asserted and/or additional
                descriptions.</para>
        </section>
        <section>
            <title>Processing steps</title>
            <para>The processing of semantic maps can now be described as a sequence of
                steps:</para>
            <orderedlist spacing="compact">
                <listitem>
                    <para>For each resource model identify its asserted target nodes.</para>
                </listitem>
                <listitem>
                    <para>For each asserted target node create a resource description (preliminary
                        or final).</para>
                </listitem>
                <listitem>
                    <orderedlist spacing="compact">
                        <listitem>
                            <para>Map any hybrid triple object to a new resource description</para>
                        </listitem>
                        <listitem>
                            <para>Replace the hybrid triple object by the IRI provided by the new
                                resource description</para>
                        </listitem>
                    </orderedlist>
                </listitem>
                <listitem>
                    <para>If any resource descriptions created in (3) contain hybrid triples, repeat
                        (3)</para>
                </listitem>
                <listitem>
                    <para>The result is the set of all RDF triples created in steps (2) and
                        (3).</para>
                </listitem>
            </orderedlist>
            <para>For a formal definition of the processing see <xref
                    linkend="appendix-formal-definition"/>.</para>
        </section>
    </section>
    <section>
        <title>RDFe for non-XML resources</title>
        <para>The core capability of the XPath language is the navigation of XDM node trees, and
            this navigation is the “engine” of RDFe. The W3C recommendations defining XPath 3.1
                (<xref linkend="xpath31"/> and <xref linkend="xpathfunctions31"/>) do not define
            functions parsing HTML and CSV, and the function defined to parse JSON into node trees
                (<code>fn:json-to-xml</code>) uses a generic vocabulary which makes navigation
            awkward. Implementation-defined XPath extension functions, on the other hand, which
            parse JSON, HTML and CSV into navigation-friendly node trees are common (e.g. BaseX
                <xref linkend="basex"/> functions <code>json:parse</code>, <code>html:parse</code>
            and <code>csv:parse</code>). An RDFe processor may offer <emphasis role="bold"
                >implementation-defined support</emphasis> for such functions and, by implication,
            also enable the mapping of non-XML resources to RDF triples.</para>
    </section>
    <section>
        <title>Conformance</title>
        <para>An <emphasis role="bold">RDFe processor</emphasis> translates an initial set of XML
            documents and a set of semantic maps to a set of RDF triples.</para>
        <section>
            <title>Minimal conformance</title>
            <para>Minimal conformance requires a processing as described in this paper. It includes
                support for <emphasis role="bold">XPath 3.1 expressions</emphasis> in any place of a
                semantic map where an XPath expression is expected:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>targetAssertion/@expr</para>
                </listitem>
                <listitem>
                    <para>targetNodeAssertion/@expr</para>
                </listitem>
                <listitem>
                    <para>var/@value</para>
                </listitem>
                <listitem>
                    <para>fun/@code</para>
                </listitem>
                <listitem>
                    <para>resource/@iri</para>
                </listitem>
                <listitem>
                    <para>resource/@assertedTargetNodes</para>
                </listitem>
                <listitem>
                    <para>property/@value</para>
                </listitem>
                <listitem>
                    <para>property/@lang</para>
                </listitem>
                <listitem>
                    <para>valueItemCase/@test</para>
                </listitem>
                <listitem>
                    <para>valueItemCase/@value</para>
                </listitem>
                <listitem>
                    <para>valueItemCase/@lang</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Optional feature: XQuery Expressions Feature</title>
            <para>If an implementation provides the <emphasis role="bold">XQuery Expressions
                    Feature</emphasis>, it must support XQuery 3.1 <xref linkend="xquery31"/>
                expressions in any place of a semantic map where an XPath expression is
                expected.</para>
        </section>
        <section>
            <title>Implementation-defined extension functions</title>
            <para>An implementation may support implementation-defined XPath extension functions.
                These may in particular enable the parsing of non-XML resources into XDM node trees
                and thus support the RDFe-defined mapping of non-XML resources to RDF
                triples.</para>
        </section>
    </section>
    <section>
        <title>Implementation</title>
        <para>An implementation of an RDFe processor is available on github <xref linkend="shax"/>
                (<code>https://github.com/hrennau/shax</code>). The processor is provided as a
            command line tool (<code>shax.bat</code>, <code>shax.sh</code>). Example call:</para>
        <programlisting>shax rdfe?dox=drug*.xml,semap=drugbank.*rdfe.xml</programlisting>
        <para>The implementation is written in XQuery and requires the use of the BaseX <xref
                linkend="basex"/> XQuery processor. It supports the XQuery Expressions Feature and
            all XPath extension functions defined by BaseX. This includes functions for parsing
            JSON, HTML and CSV into node trees (<code>json:parse</code>, <code>html:parse</code>,
                <code>csv:parse</code>). The implementation can therefore be used for mapping any
            mixture of XML, JSON, HTML and CSV resources to an RDF graph.</para>
    </section>
    <section>
        <title>Discussion</title>
        <para>The purpose of RDFe is straightforward: to support the mapping of XML data to RDF
            data. Why should one want to do this? In a “push scenario”, XML data are the primary
            reality, and RDF is a means to augment it by an additional representation. In a “pull
            scenario”, an RDF model comes first, and XML is a data source used for populating the
            model. Either way, the common denominator is information content which may be
            represented in alternative ways, as a tree or as a graph. The potential usefulness of
            RDFe (and other tools for mapping between tree and graph, like RDFa <xref linkend="rdfa"
            />, JSON-LD <xref linkend="jsonld"/> and GraphQL <xref linkend="graphql"/>) depends on
            the possible benefits of switching between the two models. Such benefits emerge from the
            complementary character of these alternatives. </para>
        <para>A tree representation offers an optimal reduction of complexity, paying the price of a
            certain arbitrariness. The reduction of complexity is far more obvious than the
            arbitrariness. Tree structure decouples amount and complexity of information. A
            restaurant menu, for example, is a tree, with inner nodes like starters, main courses,
            desserts and beverages, perhaps further inner nodes (meat, fish, vegetarian, etc.) and
            leaf nodes which are priced offerings. Such representation fits the intended usage so
            well that it looks natural. But when integrating the menu data from all restaurants in a
            town - how to arrange intermediate nodes like location, the type of restaurant, price
            category, ratings, …? It may also make sense to pull the menu items out of the menus,
            grouping by name of the dish.</para>
        <para>A graph representation avoids arbitrariness by reducing information to an essence
            consisting of resources, properties and relationships – yet pays the price of a certain
            unwieldiness. Graph data are more difficult to understand and to use. If switching
            between tree and graph were an effortless operation, what could be gained by “seeing” in
            a tree the graph which it represents, and by “seeing” in a graph the trees which it can
            become? </para>
        <figure xml:id="magritte-clairvoacne">
            <title>La clairvoyance, Rene Magritte, 1936</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/magritte-la-clairvoyance.jpg" scalefit="1" width="100%"
                    />
                </imageobject>
                <caption>
                    <para>
                        <emphasis role="italic">A painting suggesting a thorough consideration of
                            the relationship between XML and RDF.</emphasis>
                    </para>
                </caption>
            </mediaobject>
        </figure>
        <para>Think of two XML documents, one representing <code>&lt;painter></code> as child
            element of <code>&lt;painting></code>, the other representing <code>&lt;painting></code>
            as child element of <code>&lt;painter></code>. From a tree-only perspective they are
            stating different facts; from a graph-in-tree perspective, they are representing the
                <emphasis role="ital">same information</emphasis>, which is about painters,
            paintings and a relationship between the two. Such intuitive insight may be <emphasis
                role="ital">inferred</emphasis> by a machine if machine-readable instructions for
            translating both documents into RDF are available. Interesting opportunities for data
            integration and quality control seem to emerge. A document-to-document transformation,
            for example, may be checked for semantic consistency. </para>
        <para>If the potential of using tree and graph quasi-simultaneously has hardly been
            explored, so far, a major reason <emphasis role="ital">may</emphasis> be the high
            “resistence” which hinders a flow of information between the two models. RDFe addresses
            one half of this problem, the direction tree-to-graph. RDFe is meant to complement
            approaches dealing with the other half, e.g. GraphQL <xref linkend="graphql"/>.</para>
        <para>RDFe is committed to XPath as <emphasis role="ital">the</emphasis> language for
            expressing mappings within a forest of information. The conclusion that RDFe is
            restricted to dealing with XML data would be a misunderstanding, due to oversight that
            any tree structure (e.g. JSON and any table format) can be parsed into an XDM node tree
            and thus become accessible to XPath navigation. Another error would be to think that
            RDFe is restricted to connecting information <emphasis role="ital">within</emphasis>
            documents, as XPath offers excellent support for inter-document navigation (see also the
            example given in <xref linkend="linking-resources"/>). Contrary to widespread views,
            XPath may be understood and used as a universal language for tree navigation - and RDFe
            might accordingly serve as a general language for mapping information forest to RDF
            graph.</para>
    </section>
    <appendix xml:id="appendix-formal-definition">
        <title>Processing semantic maps - formal definition</title>
        <para>The processing of semantic maps is based on the building block of an <emphasis
                role="bold">RDFe expression (rdfee)</emphasis>. An rdfee is a pair consisting of an
                <emphasis role="bold">XML node</emphasis> and a <emphasis role="bold">resource
                model</emphasis>: <programlisting>  rdfee ::= (xnode, rmodel)</programlisting> The
            XML node is viewed as representing a resource, and the resource model defines how to
            translate the XML node into an RDF resource description. An rdfee is an expression which
            can be resolved to a set of tripels.</para>
        <para>Resource models are contained by a <emphasis role="bold">semantic map</emphasis>. A
            set of semantic maps is called a <emphasis role="bold">semantic extension
                (SE)</emphasis>. A semantic extension is a function which maps a set of XML
            documents to a (possibly empty) set of RDF triples:</para>
        <programlisting>  triple* = SE(document+)</programlisting>
        <para>The mapping is defined by the following rules, expressed in pseudo-code. </para>
        <section>
            <title>Section 1: Top-level rule</title>
            <programlisting><emphasis role="bold">triples</emphasis>(docs, semaps) ::=
    for rdfee in <emphasis role="underline">rdfees</emphasis>(docs, semaps):
        <emphasis role="underline">rdfee-triples</emphasis>(rdfee, semaps)
</programlisting>
        </section>
        <section>
            <title>Section 2: Resolving an rdfee to a set of triples</title>
            <programlisting><emphasis role="bold">rdfee-triples</emphasis>(rdfee, semaps) ::=
    for pmodel in <emphasis role="underline">pmodels</emphasis>(rdfee.rmodel),
    for value in <emphasis role="underline">values</emphasis>(pmodel, rdfee.xnode):
    (	
        <emphasis role="underline">resource-iri</emphasis>(rdfee.rmodel, rdfee.xnode), 
        <emphasis role="underline">property-iri</emphasis>(pmodel, rdfee.xnode), 
        <emphasis role="underline">triple-object</emphasis>(value, pmodel, semaps)
    )

<emphasis role="bold">values</emphasis>(pmodel, xnode) ::=
    <emphasis role="underline">xpath</emphasis>(pmodel/@value, xnode, <emphasis role="underline">containing-semap</emphasis>(pmodel))

<emphasis role="bold">resource-iri</emphasis>(rmodel, xnode) ::=
    <emphasis role="underline">xpath</emphasis>(rmodel/@iri, xnode, <emphasis role="underline">containing-semap</emphasis>(rmodel))

<emphasis role="bold">property-iri</emphasis>(pmodel, xnode) ::=
    <emphasis role="underline">xpath</emphasis>(pmodel/@iri, xnode, <emphasis role="underline">containing-semap</emphasis>(pmodel))

<emphasis role="bold">triple-object</emphasis>(value, pmodel, semaps) ::=
    if <emphasis role="underline">object-type</emphasis>(value, pmodel) = "#resource":
        <emphasis role="underline">resource-iri</emphasis>(<emphasis role="underline">rmodel-for-xnode</emphasis>(value, pmodel), value)
    else:
        <emphasis role="underline">rdf-value</emphasis>(value, <emphasis role="underline">object-type</emphasis>(value, pmodel))

<emphasis role="bold">rmodel-for-xnode</emphasis>(xnode, pmodel, semaps) ::=
    if pmodel/@objectModelID:
        <emphasis role="underline">rmodel</emphasis>(pmodel/@objectModelID, semaps)
    else:
        <emphasis role="underline">best-matching-rmodel-for-xnode</emphasis>(xnode, semaps)

<emphasis role="bold">best-matching-rmodel-for-xnode</emphasis>(xnode, semaps):
[Returns the rmodel which is matched by xnode and, if several rmodels  
are matched, is deemed the best match; rules for “best match” may evolve; 
current implementation treats the number of target node constraints as a 
measure of priority – the better match is the rmodel with a greater number 
of constraints; an explicit @priority à la XSLT is considered a future 
option.]

<emphasis role="bold">object-type</emphasis>(value, pmodel):
[Returns the type to be used for a value obtained from the value expression; 
value provided by pmodel/@type or by pmodel/valueItemCase/@type.]

<emphasis role="bold">rdf-value</emphasis>(value, type):
[Returns a literal with lexical form = string(value), datatype = type.]
</programlisting>
        </section>
        <section>
            <title>Section 3: Resolving input documents to a set of rdfees</title>
            <programlisting><emphasis role="bold">rdfees</emphasis>(docs, semaps) ::=	
	for rdfee in <emphasis role="underline">asserted-rdfees</emphasis>(docs, semaps):
        rdfee,
        <emphasis role="underline">required-rdfees</emphasis>(rdfee, semaps)

<emphasis role="ital">Sub section: asserted rdfees</emphasis>

<emphasis role="bold">asserted-rdfees</emphasis>(docs, semaps) ::=	
    for doc in docs,
    for semap in semaps:
        if <emphasis role="underline">doc-matches-semap</emphasis>(doc, semap):
            for rmodel in <emphasis role="underline">rmodels</emphasis>(semap),
            for xnode in <emphasis role="underline">asserted-target-nodes</emphasis>(rmodel, doc):
                (xnode, rmodel)

<emphasis role="bold">asserted-target-nodes</emphasis>(rmodel, doc) ::=	
    xpath(rmodel/@assertedTargetNodes, doc, <emphasis role="underline">containing-semap</emphasis>(rmodel))

<emphasis role="ital">Sub section: required rdfees</emphasis>

<emphasis role="bold">required-rdfees</emphasis>(rdfee, semaps) ::=
    for pmodel in <emphasis role="underline">pmodels</emphasis>(rdfee.rmodel),
    for value in <emphasis role="underline">values</emphasis>(pmodel, rdfee.xnode):
        <emphasis role="underline">required-rdfee</emphasis>(value, pmodel, semaps)

<emphasis role="bold">required-rdfee</emphasis>(xnode, pmodel, semaps) ::=
    if <emphasis role="underline">object-type</emphasis>(xnode, pmodel) = "#resource": 
        let rmodel ::= <emphasis role="underline">rmodel-for-xnode</emphasis>(value, pmodel, semaps),
        let required-rdfee ::= (xnode, rmodel):
            required-rdfee,
            <emphasis role="underline">required-rdfees</emphasis>(required-rdfee, semaps )
</programlisting>
        </section>
        <section>
            <title>Section 4: auxilliary rules</title>
            <programlisting><emphasis role="bold">doc-matches-semap</emphasis>(doc, semap):
[Returns true if doc matches the target document constraints of semap.]

<emphasis role="bold">xnode-matches-rmodel</emphasis>(xnode, rmodel):
[Returns true if xnode matches the target node constraints of rmodel.]

<emphasis role="bold">rmodel</emphasis>(rmodelID, semaps) ::=
[Returns the rmodel with an ID matching rmodelID.]

<emphasis role="bold">rmodels</emphasis>(semap) ::= semap//resource

<emphasis role="bold">pmodels</emphasis>(rmodel) ::= rmodel/property

<emphasis role="bold">containing-doc</emphasis>(xnode) ::= xnode/root()

<emphasis role="bold">containing-semap</emphasis>(semapNode) ::= semapNode/ancestor-or-self::semanticMap

<emphasis role="bold">xpath</emphasis>(xpath-expression, contextNode, semap) ::=
[Value of xpath-expression, evaluated as XPath expression using contextNode 
as context node and a dynamic context including all in-scope variables from 
the dynamic context constructed for the combination of the document 
containing contextNode and semap.]
</programlisting>
        </section>
    </appendix>
    <bibliography>
        <biblioentry xml:id="basex">
            <abbrev>1</abbrev>
            <title>BaseX</title>
            <date>2019</date>
            <publisher>
                <publishername>BaseX GmbH</publishername>
            </publisher>
            <biblioid class="uri">http:// basex.org</biblioid>
        </biblioentry>
        <biblioentry xml:id="drugbank">
            <abbrev>2</abbrev>
            <title>DrugBank 5.0: a major update to the DrugBank database for 2018.</title>
            <date>2017</date>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>DS</firstname>
                        <surname>Wishart</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>YD</firstname>
                        <surname>Feunang</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>AC</firstname>
                        <surname>Guo</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>EJ</firstname>
                        <surname>Lo</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>A</firstname>
                        <surname>Marcu</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>JR</firstname>
                        <surname>Grant</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>T</firstname>
                        <surname>Sajed</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>D</firstname>
                        <surname>Johnson</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>C</firstname>
                        <surname>Li</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Z</firstname>
                        <surname>Sayeeda</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>N</firstname>
                        <surname>Assempour</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>I</firstname>
                        <surname>Iynkkaran</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Y</firstname>
                        <surname>Liu</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>A</firstname>
                        <surname>Maciejewski</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>N</firstname>
                        <surname>Gale</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>A</firstname>
                        <surname>Wilson</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>L</firstname>
                        <surname>Chin</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>R</firstname>
                        <surname>Cummings</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>D</firstname>
                        <surname>Le</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>A</firstname>
                        <surname>Pon</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>C</firstname>
                        <surname>Knox</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>M</firstname>
                        <surname>Wilson</surname>
                    </personname>
                </author>
            </authorgroup>
            <publisher>
                <publishername>Nucleic Acids Res. 2017 Nov 8.</publishername>
            </publisher>
            <biblioid class="uri">https://www.drugbank.ca/</biblioid>
            <biblioid class="doi">10.1093/nar/gkx1037</biblioid>
        </biblioentry>
        <biblioentry xml:id="graphql">
            <abbrev>3</abbrev>
            <title>GraphQL</title>
            <date>2017</date>
            <publisher>
                <publishername>Facebook Inc.</publishername>
            </publisher>
            <biblioid class="uri">http://graphql.org/</biblioid>
        </biblioentry>
        <biblioentry xml:id="jsonld">
            <abbrev>4</abbrev>
            <title>JSON-LD 1.0. A JSON-based Serialization for Linked Data</title>
            <date>2014</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/json-ld/</biblioid>
        </biblioentry>
        <biblioentry xml:id="location-trees">
            <abbrev>5</abbrev>
            <title>Location trees enable XSD based tool development.</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2017</date>
            <biblioid class="uri"
                >http://xmllondon.com/2017/xmllondon-2017-proceedings.pdf</biblioid>
        </biblioentry>
        <biblioentry xml:id="rdfa">
            <abbrev>6</abbrev>
            <title>RDFa Core 1.1 – Third Edition.</title>
            <date>2015</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/rdfa-core/</biblioid>
        </biblioentry>
        <biblioentry xml:id="turtle">
            <abbrev>7</abbrev>
            <title>RDF 1.1 Turtle</title>
            <date>2014</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/turtle/</biblioid>
        </biblioentry>
        <biblioentry xml:id="shax">
            <abbrev>8</abbrev>
            <title>A SHAX processor, transforming SHAX models into SHACL, XSD and JSON
                Schema.</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2017</date>
            <biblioid class="uri">https://github.com/hrennau/shax</biblioid>
        </biblioentry>
        <biblioentry xml:id="xpath31">
            <abbrev>9</abbrev>
            <title>XML Path Language (XPath) 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xpathfunctions31">
            <abbrev>10</abbrev>
            <title>XPath and XQuery Functions and Operators 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-functions-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xdm31">
            <abbrev>11</abbrev>
            <title>XQuery and XPath Data Model 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-datamodel-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xquery31">
            <abbrev>12</abbrev>
            <title>XQuery 3.1: An XML Query Language</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xquery-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xsdplus">
            <abbrev>13</abbrev>
            <title>xsdplus - a toolkit for XSD based tool development</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2017</date>
            <biblioid class="uri">https://github.com/hrennau/xsdplus</biblioid>
        </biblioentry>
    </bibliography>
</article>
