<?xml-model href='http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng' schematypens='http://relaxng.org/ns/structure/1.0'?><?xml-model href='http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng' type='application/xml' schematypens='http://purl.oclc.org/dsdl/schematron'?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0">
    <info>
        <title>RDFe – expression-based mapping of XML documents to RDF triples</title>
        <author>
            <personname>Hans-Juergen Rennau</personname>
            <email>hans-juergen.rennau@parsqube.de</email>
            <personblurb>
                <para/>
            </personblurb>
            <affiliation>
                <orgname>parsQube GmbH</orgname>
            </affiliation>
        </author>
        <keywordset>
            <keyword>RDF, XML, RDFa, RDFe, Linked Data</keyword>
        </keywordset>
        <abstract>
            <para>RDFe is an XML language for mapping XML documents to RDF triples. The name suffix
                “e” stands for expression and hints at the key concept, which is the use of XPath
                expressions mapping semantic relationships between RDF subjects and objects to
                structural relationships between XML nodes. More precisely, RDF properties are
                represented by XPath expressions evaluated in the context of an XML node which
                represents the triple subject and yielding XDM value items which represent the
                triple object. The expressiveness of XPath version 3.1 enables the semantic
                interpretation of XML resources of any structure and content. Required XPath
                expressions can be simplified by the definition of a dynamic context whose variables
                and functions are referenced by the expressions. Semantic relationships can be
                across document boundaries, and new XML document URIs can be discovered in the
                content of input documents, so that RDFe is capable of gleaning linked data. As
                XPath extension functions may support the parsing of non-XML resources (JSON, CSV,
                HTML), RDFe can also be used for mapping mixtures of XML and non-XML resources to
                RDF graphs.</para>
        </abstract>
    </info>
    <section xml:id="introduction">
        <title>Introduction</title>
        <para>XML is an ideal data source for the construction of RDF triples: information is
            distributed over named items which are arranged in trees identified by document URIs. We
            are dealing with a forest of information in which every item can be unambiguously
            addressed and viewed as connected to any other item (as well as sets of items) by a
            structural relationship which may be precisely and succinctly expressed using the XPath
            language <xref linkend="xpath31"/>. XPath creates an unrivalled inter-connectivity of
            information pervading any set of XML documents of any content and size. RDF triples
            describing a resource thus may be obtained by (1) selecting within the XML forest an XML
            node serving as the representation of the resource, (2) mapping each property IRI to an
            XPath expression reaching out into the forest and returning the nodes representing the
            property values. To unleash this potential, a model is needed for translating <emphasis
                role="ital">semantic relationships</emphasis> between RDF subject and object into
                <emphasis role="ital">structural relationships</emphasis> between XML nodes
            representing subject and object. The model should focus on <emphasis role="ital"
                >expressions</emphasis> as the basic units defining a mapping – not on names, as
            done by JSON-LD <xref linkend="jsonld"/>, and not on additional markup as done by RDFa
                <xref linkend="rdfa"/>. This paper proproses RDFe, an expression-based model for
            mapping XML to RDF.</para>
    </section>
    <section>
        <title>RDFe example</title>
        <para>This section introduces RDFe by building an example in several steps.</para>
        <section>
            <title>Getting started</title>
            <para>Consider an XML document describing drugs (contents taken from drugbank <xref
                    linkend="drugbank"/>):</para>
            <programlisting><![CDATA[
<drugs xmlns="http://www.drugbank.ca">
  <drug type="biotech" created="2005-06-13" updated="2018-07-02">
    <drugbank-id primary="true">DB00001</drugbank-id>
    <drugbank-id>BTD00024</drugbank-id>
    <drugbank-id>BIOD00024</drugbank-id>
    <name>Lepirudin</name>
    <!-- more content here -->
    <pathways>
      <pathway>
        <!-- more content here -->
        <enzymes>
          <uniprot-id>P00734</uniprot-id>
          <uniprot-id>P00748</uniprot-id>
          <uniprot-id>P02452</uniprot-id>
          <!-- more content follows -->
        </enzymes>
      </pathway>
    </pathways>
    <!-- more content here -->
  </drug>
  <!-- more drugs here -->
</drugs>]]></programlisting>
            <para>We want to map parts of these descriptions to an RDF representation. First goals: </para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>Assign an IRI to each drug</para>
                </listitem>
                <listitem>
                    <para>Construct triples describing the drug</para>
                </listitem>
            </itemizedlist>
            <para>The details are outlined in the table below. Within XPath expressions, variable
                $drug references the XML element representing the resource.</para>
            <table xml:id="table-1">
                <title>A simple model deriving RDF resource descriptions from XML data.</title>
                <titleabbrev xml:id="table-1-shorttitle"
                    >Example-mappings-property-xpath</titleabbrev>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="2*"/>
                    <colspec colname="c2" colnum="2" colwidth="2*"/>
                    <colspec colname="c3" colnum="3" colwidth="6*"/>
                    <thead>
                        <row>
                            <entry align="left" namest="c1" nameend="c3" rowsep="0" colsep="0"
                                >Resource IRI expression (XPath)</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry colsep="0"/>
                            <entry align="left" namest="c2" nameend="c3"
                                >$drug/db:drugbank-id[@primary = 'true']/concat('drug:', .)</entry>
                        </row>
                    </tbody>
                </tgroup>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="2*"/>
                    <colspec colname="c2" colnum="2" colwidth="2*"/>
                    <colspec colname="c3" colnum="3" colwidth="6*"/>
                    <thead>
                        <row>
                            <entry align="left">Property IRI</entry>
                            <entry align="left">Property type</entry>
                            <entry align="left">Property value expression (XPath)</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry align="left">rdf:type</entry>
                            <entry align="left">xs:string</entry>
                            <entry align="left">'ont:drug'</entry>
                        </row>
                        <row>
                            <entry align="left">ont:name</entry>
                            <entry align="left">xs:string</entry>
                            <entry align="left">$drug/name</entry>
                        </row>
                        <row>
                            <entry align="left">ont:updated</entry>
                            <entry align="left">xs:date</entry>
                            <entry align="left">$drug/@updated</entry>
                        </row>
                        <row>
                            <entry align="left">ont:drugbank-id</entry>
                            <entry align="left">xs:string</entry>
                            <entry align="left">$drug/db:drugbank-id[@primary = 'true']</entry>
                        </row>
                        <row>
                            <entry align="left">ont:drugbank-altid</entry>
                            <entry align="left">xs:string</entry>
                            <entry align="left">$drug/db:drugbank-id[not(@primary = 'true')]</entry>
                        </row>
                        <row>
                            <entry align="left">ont:enzyme</entry>
                            <entry align="left">IRI</entry>
                            <entry align="left">$drug//db:enzymes/db:uniprot-id/concat('uniprot:',
                                .)</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>This model is easily translated into an RDFe document, also called a <emphasis
                    role="bold">semantic map:</emphasis></para>
            <programlisting><![CDATA[<re:semanticMap iri="http://example.com/semap/drugbank/"
                targetNamespace="http://www.drugbank.ca"
                targetName="drugs"
                xmlns:re="http://www.rdfe.org/ns/model"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:db="http://www.drugbank.ca">
    
  <re:namespace iri="http://example.com/resource/drug/" prefix="drug"/>
  <re:namespace iri="http://example.com/ontology/drugbank/" prefix="ont"/>
  <re:namespace iri="http://www.w3.org/2000/01/rdf-schema#" prefix="rdfs"/>    
  <re:namespace iri="http://bio2rdf.org/uniprot:" prefix="uniprot"/>
    
  <re:resource modelID="drug" 
               assertedTargetNodes="/db:drugs/db:drug" 
               targetNodeNamespace="http://www.drugbank.ca"
               targetNodeName="drug"
               iri="db:drugbank-id[@primary = 'true']/concat('drug:', .)" 
               type="ont:drug">
    <re:property iri="rdfs:label" 
                 value="db:name" 
                 type="xs:string"/>        
    <re:property iri="ont:updated" 
                 value="@updated" 
                 type="xs:date"/>
    <re:property iri="ont:drugbank-id" 
                 value="db:drugbank-id[@primary = 'true']" 
                 type="xs:string"/>
    <re:property iri="ont:drugbank-alt-id" 
                 value="db:drugbank-id[not(@primary = 'true')]"  
                 type="xs:string"/>
    <re:property iri="ont:enzyme" 
                 value=".//db:enzymes/db:uniprot-id/concat('uniprot:', .)" 
                 type="#iri"/>
  </re:resource>
    
</re:semanticMap>]]></programlisting>
            <para>The triples are generated by an <emphasis role="bold">RDFe processor</emphasis>,
                to which we pass the XML document and the semantic map. Command line
                invocation:</para>
            <programlisting>  shax "rdfe?dox=drugs.xml,semap=drugbank.rdfe.xml"</programlisting>
            <para>The result is a set of RDF triples in Turtle <xref linkend="turtle"/>
                syntax:</para>
            <programlisting><![CDATA[@prefix drug: <http://example.com/resource/drug/> .
@prefix ont: <http://example.com/ontology/drugbank/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix uniprot: <http://bio2rdf.org/uniprot:> .

drug:DB00001 
        rdf:type            ont:drug ;
        rdfs:label          "Lepirudin" ;
        ont:updated         "2018-07-02"^^xs:date ;
        ont:drugbank-id     "DB00001" ;
        ont:drugbank-alt-id "BTD00024" ;
        ont:drugbank-alt-id "BIOD00024" ;
        ont:enzyme          uniprot:P00734 ;
        ont:enzyme          uniprot:P00748 ;
        ont:enzyme          uniprot:P02452 ;
             …
drug:DB00002 
        rdf:type ont:drug ; 
             …
drug:DB00003 
        rdf:type ont:drug ;
             …
…]]></programlisting>
            <para>Some explanations should enable a basic understanding of how the semantic map
                controls the output. The basic building block of a semantic map is a <emphasis
                    role="bold">resource model</emphasis>. It defines how to construct the triples
                describing a resource represented by an XML node:</para>
            <programlisting><![CDATA[<re:resource modelID="drug" 
             assertedTargetNodes="/db:drugs/db:drug" 
             iri="db:drugbank-id[@primary eq 'true']/concat('drug:', .)" 
             type="ont:drug">
  <re:property iri="rdfs:label" 
    value="db:name" 
    type="xs:string"/>        
  <!-- more property models here -->
</re:resource> 
]]></programlisting>
            <para>The @iri attribute on <code>&lt;resource></code> provides an XPath expression
                yielding the resource IRI. The expression is evaluated <emphasis role="ital">in the
                    context of the XML node representing the resource</emphasis>. Note how the
                expression language XPath is used in order to describe the IRI as a concatenation of
                a literal prefix and a data-dependent suffix. Every node returned by the expression
                in @assertedTargetNodes, evaluated <emphasis role="ital">in the context of the input
                    document</emphasis>, is mapped to a resource description as specified by this
                resource model element.</para>
            <para>Each <code>&lt;property></code> child element adds to the resource model a
                    <emphasis role="bold">property model</emphasis>. It describes how to construct
                triples with a particular property IRI. The property IRI is given by @iri, and the
                property values are obtained by evaluating the expression in @value, <emphasis
                    role="ital">using the node representing the resource as context node</emphasis>.
                (In our example, the value expressions are evaluated in the context of a
                    <code>&lt;drug></code> element.) As the examples show, the XPath language may be
                used freely, for example combining navigation with other operations like
                concatenation. The datatype of the property values is specified by the @type
                attribute on <code>&lt;property></code>. The special value <code>#iri</code> signals
                that the value is an IRI, rather than a typed literal. Another special value,
                    <code>#resource</code>, will be explained in the following section.</para>
        </section>
        <section xml:id="linking-resources">
            <title>Linking resources</title>
            <para>Our drug document references articles:</para>
            <programlisting><![CDATA[<drugs xmlns="http://www.drugbank.ca">
  <drug type="biotech" created="2005-06-13" updated="2018-07-02">
    <drugbank-id primary="true">DB00001</drugbank-id>
   <!-- more content here -->
    <general-references>
      <articles>
        <article>
          <pubmed-id>16244762</pubmed-id>
          <citation>
            Smythe MA, Stephens JL, Koerber JM, Mattson JC: A c…</citation>
        </article>
        <!-- more articles here -->
      </articles>
    </general-references>
   <!-- more content here -->
</drugs>
]]></programlisting>
            <para>RDF is about connecting resources, and therefore our RDF data will be more
                valuable if the description of a drug references <emphasis role="Ital">article
                    IRIs</emphasis> which give access to <emphasis role="ital">article resource
                    descriptions</emphasis> - rather than including properties with literal values
                which represent properties of the article in question, like its title and authors. </para>
            <para>Assume we have access to a document describing articles:</para>
            <programlisting><![CDATA[<articles>
  <article>
    <pubmed-id>16244762</pubmed-id>
    <url>https://doi.org/10.1177/107602960501100403</url>
    <doi>10.1177/107602960501100403</doi>
    <authors>
      <author>Smythe MA</author>
      <author>Stephens JL</author>
      <author>Koerber JM</author>
      <author>Mattson JC</author>            
    </authors>
    <title>A comparison of lepirudin and argatroban outcomes</title>
    <keywords>
      <keyword>Argatroban</keyword>
      <keyword>Lepirudin</keyword>
      <keyword>Direct thrombin inhibitors</keyword>
    </keywords>
    <citation>Smythe MA, Stephens JL, Koerber JM, Mattson JC: A ...</citation>
    <abstract> Although both argatroban and lepirudin are used ...</abstract>
  </article>
  <!—more articles here -->
</articles>
]]></programlisting>
            <para>We write a second semantic map for this document about articles:</para>
            <programlisting><![CDATA[<re:semanticMap  iri="http://example.com/semap/articles/"
                 targetNamespace="" targetName="articles" …>
  <re:namespace iri="http://example.com/resource/article/" prefix="art"/>
  <!-- more namespace descriptors here -->
  <re:resource modelID="article" iri="pubmed-id/concat('art:', .)"
               targetNodeNamespace=""
               targetNodeName="article"
               type="ont:article">        
   <re:property iri="ont:doi" value="doi" type="xs:string"/>        
   <re:property iri="ont:url" value="url" type="xs:string"/>
   <re:property iri="ont:author" value=".//author" list="true" type="xs:string"/>
   <re:property iri="ont:title" value="title" type="xs:string"/>        
   <re:property iri="ont:keyword" value="keywords/keyword" type="xs:string"/>
   <re:property iri="ont:abstract" value="abstract" type="xs:string"/>
   <re:property iri="ont:citation" value="citation" type="xs:string"/>
  </re:resource>
</re:semanticMap/>
]]></programlisting>
            <para>and we extend the resource model of a drug by a property <emphasis role="ital"
                    >referencing the article resource</emphasis>, relying on its XML representation
                provided by an <code>&lt;article></code> element:</para>
            <programlisting><![CDATA[<re:property iri="ont:ref-article" 
  value="for $id in .//db:article/db:pubmed-id return 
         doc('/ress/drugbank/articles.xml')//article[pubmed-id eq $id]" 
  type="#resource"/>
]]></programlisting>
            <para>The value expression fetches the values of <code>&lt;pubmed-id></code> children of
                    <code>&lt;article></code> elements contained by the <code>&lt;drug></code>
                element, and it uses these values in order to navigate to the corresponding
                    <code>&lt;article></code> element <emphasis role="ital">in a different
                    document</emphasis>. This document need not be provided by the initial input –
                documents can be discovered during processing. While the items obtained from the
                value expression are <code>&lt;article></code>
                <emphasis role="ital">elements</emphasis>, the triple objects must be article
                    <emphasis role="ital">IRIs</emphasis> giving access to article <emphasis
                    role="ital">resource descriptions</emphasis>. Therefore two things must be
                accomplished: first, the output must include triples describing the referenced
                articles; second, the <code>ont:ref-article</code> property of a drug must have an
                object which is the article IRI used as the subject of triples describing this
                article. The article IRI, as well as the triples describing the article are obtained
                by applying the <emphasis role="ital">article resource model</emphasis> to the
                article element. All this is accomplished by the RDFe processor whenever it detects
                the property type <code>#resource</code>. Our output is extended accordingly:</para>
            <programlisting>drug:DB00001 a ont:drug ;
   rdfs:label        "Lepirudin" ;
   …
   ont:ref-article   <emphasis role="bold">art:16244762</emphasis> ;
        …
<emphasis role="bold">art:16244762</emphasis> a ont:article ;
   ont:abstract  "Although both argatroban and lepirudin are used for ..." ;
   ont:author    "Stephens JL" , "Koerber JM" , "Mattson JC" , "Smythe MA" ;
   ont:citation  "Smythe MA, Stephens JL, Koerber JM, Mattson JC: A com … " ;
   ont:doi       "10.1177/107602960501100403" ;
   ont:keyword   "Argatroban" , "Lepirudin" , "Direct thrombin inhibitors" ;
   ont:title     "A comparison of lepirudin and argatroban outcomes" ;
   ont:url       "https://doi.org/10.1177/107602960501100403" .
</programlisting>
        </section>
        <section>
            <title>Adding a dynamic context</title>
            <para>The property model which we just added to the resource model for drugs contains a
                “difficult” value expression – an expression which is challenging to write, to read
                and to maintain:</para>
            <programlisting><![CDATA[  for $id in .//db:article/db:pubmed-id return 
  doc('/products/drugbank/articles.xml')//article[pubmed-id eq $id]"
]]></programlisting>
            <para>We can simplify the expression by defining a <emphasis role="bold">dynamic
                    context</emphasis> and referencing a context variable. A
                    <code>&lt;context></code> element represents the <emphasis role="ital"
                    >constructor</emphasis> of a dynamic context:</para>
            <programlisting><![CDATA[<re:semanticMap  iri="http://example.com/semap/drugbank/" …>
  ...
  <re:context>
    <re:var name="articlesURI" value="'/products/drugbank/articles.xml'"/>
    <re:var name="articlesDoc" value="doc($articlesURI)"/>
  </re:context>
      …
</re:semanticMap>
]]></programlisting>
            <para>The values of context variables are specified by XPath expressions. Their
                evaluation context is the root element of an input document, so that variable values
                may reflect document contents. A context constructor is evaluated once for each
                input document. The context variables are available in any expression within the
                semantic map containing the context constructor (excepting expressions in preceding
                siblings of the <code>&lt;var></code> element defining the variable). Now we can
                simplify our expression to</para>
            <programlisting>  for $id in .//db:article/db:pubmed-id return 
  <emphasis role="bold">$articlesDoc</emphasis>//article[pubmed-id eq $id]
</programlisting>
            <para>As a context constructor may also define <emphasis role="ital"
                    >functions</emphasis>, we may further simplify the value expression by turning
                the navigation to the appropriate <code>&lt;article></code> element into a function.
                The function is defined by a <code>&lt;fun></code> child element of
                    <code>&lt;context></code>. We define a function with a single formal parameter,
                which is a pubmed ID:</para>
            <programlisting><![CDATA[<re:context>
  <re:var name="articlesURI" value="'/products/drugbank/articles.xml'"/>
  <re:var name="articlesDoc" value="doc($articlesURI)"/>
  <re:fun name="getArticleElem" params="id"
          code="$articlesDoc//article[pubmed-id eq $id]"/>
  </re:function>            
</re:context>]]></programlisting>
            <para>Expressions in this semantic map can reference the function by the name
                    <code>getArticleElem</code>. A new version of the value expression is
                this:</para>
            <programlisting>  .//db:article/db:pubmed-id/<emphasis role="bold">$getArticleElem</emphasis>(.)</programlisting>
            <para>For each input document a distinct instance of the context is constructed, using
                the document root as context node. This means that the context may reflect the
                contents of the input document. The following example demonstrates the possibility:
                in order to avoid repeated navigation to the <code>&lt;article></code> elements, we
                introduce a dictionary which maps all Pubmed IDs used in the input document to
                    <code>&lt;article></code> elements:</para>
            <programlisting><![CDATA[  <re:var name="articleElemDict" 
          value="map:merge(distinct-values(//db:article/db:pubmed-id)
                           ! map:entry(., $getArticleElem(.)))"/>]]></programlisting>
            <para>An updated version of the value expression takes advantage of the
                dictionary:</para>
            <programlisting>  .//db:article/db:pubmed-id/<emphasis role="bold">$articleElemDict</emphasis>(.)</programlisting>
            <para>The dictionary contains only those Pubmed IDs which are actually used in a
                particular input document. For each input document, a distinct instance of the
                dictionary is constructed, which is bound to the context variable
                    <code>$articleElemDict</code> whenever data from that document are
                evaluated.</para>
        </section>
    </section>
    <section xml:id="rdfe-language">
        <title>RDFe language</title>
        <para>RDFe is an XML language for defining the mapping of XML documents to RDF triples. A
            mapping is described by one or more RDFe documents. An RDFe document has a
                <code>&lt;semanticMap></code> root element. All elements are in the namespace
                <code>http://www.rdfe.org/ns/model</code> and all attributes are in no namespace.
            Document contents are constrained by an XSD (found here: <xref linkend="shax"/>,
                <code>xsd</code> folder). The following treesheet representation <xref
                linkend="location-trees"/>
            <xref linkend="xsdplus"/> of the schema uses the pseudo type <code>re:XPATH</code> in
            order to indicate that a string must be a valid XPath expression, version 3.1 or
            higher.</para>
        <programlisting><emphasis role="bold">semanticMap</emphasis>
. @iri . ... ... ... ... ... ty: xs:anyURI
. @targetNamespace . ... ... ty: Union({xs:anyURI}, {xs:string: len=0}, 
                                       {xs:string: enum=(*)})
. @targetName .. ... ... ... ty: Union({xs:NCName}, {xs:string: enum=(*)})
. <emphasis role="bold">targetAssertion</emphasis>* . ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . @expr? . ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. <emphasis role="bold">import</emphasis>*
. . @href .. ... ... ... ... ty: xs:anyURI
. <emphasis role="bold">namespace</emphasis>*
. . @iri ... ... ... ... ... ty: xs:anyURI
. . @prefix  ... ... ... ... ty: xs:NCName
. <emphasis role="bold">context</emphasis>?
. . _choice_*
. . 1 <emphasis role="bold">var</emphasis> .. ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . 1 . @name .. ... ... ... ty: xs:NCName
. . 1 . @value?  ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . 2 <emphasis role="bold">fun</emphasis> .. ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . 2 . @name .. ... ... ... ty: xs:NCName
. . 2 . @params? ... ... ... ty: xs:string: pattern=#(\i\c*(\s*,\s*\i\c*)?)?#
. . 2 . @as? ... ... ... ... ty: xs:Name
. . 2 . @code? . ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. <emphasis role="bold">resource</emphasis>*
. . @modelID ... ... ... ... ty: xs:NCName
. . @assertedTargetNodes? .. ty: <emphasis role="ital">re:XPATH</emphasis>
. . @iri? .. ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . @type? . ... ... ... ... ty: List(xs:Name)
. . @targetNodeNamespace? .. ty: Union({xs:anyURI}, {xs:string: len=0}, 
                                       {xs:string: enum=(*)})
. . @targetNodeName? ... ... ty: Union({xs:NCName}, {xs:string: enum=(*)})
. . targetNodeAssertion* ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . . @expr? ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . <emphasis role="bold">property</emphasis>*
. . . @iri . ... ... ... ... ty: xs:anyURI
. . . @value ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . . @type? ... ... ... ... ty: Union({xs:Name}, 
                                       {xs:string: enum=(#iri|#resource)})
. . . @list? ... ... ... ... ty: xs:boolean
. . . @objectModelID? .. ... ty: xs:Name
. . . @card? ... ... ... ... ty: xs:string: pattern=#[?*+]|\d+(-(\d+)?)?|-\d+#
. . . @reverse?  ... ... ... ty: xs:boolean
. . . @lang? ... ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . . <emphasis role="bold">valueItemCase</emphasis>*
. . . . @test .. ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . . . @iri? .. ... ... ... ty: xs:anyURI
. . . . @value?  ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
. . . . @type? . ... ... ... ty: Union({xs:Name}, 
                                       {xs:string: enum=(#iri|#resource)})
. . . . @list? . ... ... ... ty: xs:boolean
. . . . @objectModelID?  ... ty: xs:Name
. . . . @lang? . ... ... ... ty: <emphasis role="ital">re:XPATH</emphasis>
</programlisting>
    </section>
    <section>
        <title>RDFe model components</title>
        <para>This section summarizes the main components of an RDFe based mapping model. Details of
            the XML representation can be looked up in the treesheet representation shown in the
            preceding section.</para>
        <section>
            <title>Semantic extension</title>
            <para>A <emphasis role="bold">semantic extension</emphasis> is a set of one or more
                semantic maps, together defining a mapping of XML documents to a set of RDF triples.
                A semantic extension comprises all semantic maps explicitly provided as input for an
                instance of RDFe processing, as well as all maps directly or indirectly imported by
                these (see below).</para>
        </section>
        <section>
            <title>Semantic map</title>
            <para>A <emphasis role="bold">semantic map</emphasis> is a specification how to map a
                class of XML documents (defined in terms of target document constraints) to a set of
                RDF triples. It is represented by a <code>&lt;semanticMap></code> element and
                comprises the components summarized below.</para>
            <table xml:id="table-2">
                <title>Semantic map components and their XML representation.</title>
                <titleabbrev xml:id="table-2-shorttitle"
                    >model-components-and-their-xml-representation</titleabbrev>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="2*"/>
                    <colspec colname="c2" colnum="2" colwidth="2.5*"/>
                    <colspec colname="c3" colnum="3" colwidth="2*"/>
                    <thead>
                        <row>
                            <entry align="left" namest="c1" nameend="c2">Model component</entry>
                            <entry align="left">XML representation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry namest="c1" nameend="c2">Semantic map IRI</entry>
                            <entry align="left">@iri</entry>
                        </row>
                        <row>
                            <entry rowsep="0" colsep="0" namest="c1" nameend="c1">Target document
                                constraint</entry>
                            <entry rowsep="1" colsep="1" namest="c2" nameend="c2"/>
                            <entry rowsep="1" colsep="0" namest="c3" nameend="c3"/>
                        </row>
                        <row>
                            <entry rowsep="0"/>
                            <entry align="left">Target document namespace</entry>
                            <entry align="left">@targetNamespace</entry>
                        </row>
                        <row>
                            <entry rowsep="0"/>
                            <entry align="left">Target document local name</entry>
                            <entry align="left">@targetName</entry>
                        </row>
                        <row>
                            <entry/>
                            <entry align="left">Target assertions</entry>
                            <entry align="left">&lt;targetAssertion></entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Semantic map imports</entry>
                            <entry align="left">&lt;import></entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">RDF namespace bindings</entry>
                            <entry align="left">&lt;namespace></entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Context constructor</entry>
                            <entry align="left">&lt;context></entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Resource models</entry>
                            <entry align="left">&lt;resource></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>A <emphasis role="ital">semantic map IRI</emphasis> identifies a semantic map
                unambiguously. The map IRI should be independent of the document URI.</para>
            <para>The <emphasis role="ital">target document constraint</emphasis> is a set of
                conditions met by any XML document to which the semantic map may be applied. The
                constraint enables a decision whether resource models from the semantic map can be
                used in order to map nodes from a given XML document to RDF resource descriptions. A
                target document assertion is an XPath expression, to be evaluated in the context of
                a document root. A typical use of target document assertions is a check of the API
                or schema version indicated by an attribute of the input document.</para>
            <para>A semantic map may <emphasis role="ital">import</emphasis> other semantic maps.
                Import is transitive, so that any map reachable through a chain of imports is
                treated as imported. Imported maps are added to the semantic extension, and no
                distinction is made between imported maps and those which have been explicitly
                supplied as input.</para>
            <para><emphasis role="ital">RDF namespace bindings</emphasis> define prefixes used in
                the output for representing IRI values in compact form. Note that they are <emphasis
                    role="ital">not</emphasis> used for resolving namespace prefixes used in XML
                names and XPath expressions. During evaluation, XML prefixes are always resolved
                according to the in-scope namespace bindings established by namespace declarations
                    (<code>xmlns</code>).</para>
            <para><emphasis role="ital">Context constructor</emphasis> and <emphasis role="ital"
                    >resource models</emphasis> are described in subsequent sections.</para>
        </section>
        <section xml:id="resource-model">
            <title>Resource model</title>
            <para>A <emphasis role="bold">resource model</emphasis> is a set of rules how to
                construct triples describing a resource which is viewed as represented by a given
                XML node. A resource model is represented by a <code>&lt;resource></code> element
                and comprises the components summarized below.</para>
            <table xml:id="table-3">
                <title>Resource model components and their XML representation.</title>
                <titleabbrev xml:id="table-3-shorttitle"
                    >resource-model-components-and-their-xml-representation</titleabbrev>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="2*"/>
                    <colspec colname="c2" colnum="2" colwidth="2.5*"/>
                    <colspec colname="c3" colnum="3" colwidth="2*"/>
                    <thead>
                        <row>
                            <entry align="left" namest="c1" nameend="c2">Model component</entry>
                            <entry align="left">XML representation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry namest="c1" nameend="c2">Resource model ID</entry>
                            <entry align="left">@modelID</entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Resource IRI expression</entry>
                            <entry align="left">@iri</entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Target node assertion</entry>
                            <entry align="left">@assertedTargetNodes</entry>
                        </row>
                        <row>
                            <entry rowsep="0" colsep="0" namest="c1" nameend="c1">Target node
                                constraint</entry>
                            <entry rowsep="1" colsep="1" namest="c2" nameend="c2"/>
                            <entry rowsep="1" colsep="0" namest="c3" nameend="c3"/>
                        </row>
                        <row>
                            <entry rowsep="0"/>
                            <entry align="left">Target node namespace</entry>
                            <entry align="left">@targetNodeNamespace</entry>
                        </row>
                        <row>
                            <entry rowsep="0"/>
                            <entry align="left">Target node local name</entry>
                            <entry align="left">@targetNodeName</entry>
                        </row>
                        <row>
                            <entry/>
                            <entry align="left">Target node assertions</entry>
                            <entry align="left">&lt;targetNodeAssertion></entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Resource type IRIs</entry>
                            <entry align="left">@type</entry>
                        </row>
                        <row>
                            <entry namest="c1" nameend="c2">Property models</entry>
                            <entry align="left">&lt;property></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>The <emphasis role="ital">resource model ID</emphasis> is used for purposes of
                cross reference. A resource model has an implicit resource model IRI obtained by
                appending the resource model ID to the semantic map IRI (with a hash character (“#”)
                inserted in between if the semantic map IRI does not end with “/” or “#”).</para>
            <para>The <emphasis role="ital">resource IRI expression</emphasis> yields the IRI of the
                resource. The expression is evaluated using as context item the XML node used as
                target of the resource model.</para>
            <para>A <emphasis role="ital">target node assertion</emphasis> is an expression to be
                evaluated in the context of each input document passed to an instance of RDFe
                processing. The expression yields a sequence of nodes which MUST be mapped to RDF
                descriptions. Note that the processing result is not limited to these resource
                descriptions, as further descriptions may be triggered as explained in <xref
                    linkend="linking-resources"/>.</para>
            <para>A <emphasis role="ital">target node constraint</emphasis> is a set of conditions
                which is evaluated when selecting the resource model which is appropriate for a
                given XML node. It is used in particular when a property model treats XML nodes
                returned by a value expression as representations of an RDF description (for details
                see <xref linkend="linking-resources"/>).</para>
            <para><emphasis role="ital">Resource type IRIs</emphasis> identify the RDF types of the
                resource (<code>rdf:type</code> property values). The types are specified as literal
                IRI values.</para>
            <para><emphasis role="ital">Property models</emphasis> are explained in the following
                section. </para>
        </section>
        <section xml:id="property-model">
            <title>Property model</title>
            <para>A <emphasis role="bold">property model</emphasis> is represented by a
                    <code>&lt;property></code> child element of a <code>&lt;resource></code>
                element. The following table summarizes the major model components.</para>
            <table xml:id="table-4">
                <title>Property model components and their XML representation.</title>
                <titleabbrev xml:id="table-4-shorttitle"
                    >property-model-components-and-their-xml-representation</titleabbrev>
                <tgroup cols="2">
                    <colspec colname="c1" colnum="1" colwidth="3*"/>
                    <colspec colname="c2" colnum="2" colwidth="1*"/>
                    <thead>
                        <row>
                            <entry align="left">Model component</entry>
                            <entry align="left">XML representation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry align="left">Property IRI</entry>
                            <entry align="left">@iri</entry>
                        </row>
                        <row>
                            <entry align="left">Object value expression</entry>
                            <entry align="left">@value</entry>
                        </row>
                        <row>
                            <entry align="left">Object type (IRI or token)</entry>
                            <entry align="left">@type</entry>
                        </row>
                        <row>
                            <entry align="left">Object language tag</entry>
                            <entry align="left">@lang</entry>
                        </row>
                        <row>
                            <entry align="left">Object resource model (IRI or ID)</entry>
                            <entry align="left">@objectModelID</entry>
                        </row>
                        <row>
                            <entry align="left">RDF list flag</entry>
                            <entry align="left">@list</entry>
                        </row>
                        <row>
                            <entry align="left">Reverse property flag</entry>
                            <entry align="left">@reverse</entry>
                        </row>
                        <row>
                            <entry align="left">Conditional settings</entry>
                            <entry align="left">&lt;valueItemCase></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>The <emphasis role="ital">property IRI</emphasis> defines the IRI of the property.
                It is specified as a literal value.</para>
            <para>The <emphasis role="ital">object value expression</emphasis> yields XDM items
                    <xref linkend="xdm31"/> which are mapped to RDF terms in accordance with the
                settings of the property model, e.g. the object type. For each term a triple is
                constructed, using the term as object, a subject IRI obtained from the IRI
                expression of the containing resource model, and a property IRI as specified.</para>
            <para>The <emphasis role="ital">object type</emphasis> controls the mapping of the XDM
                items obtained from the object value expression to RDF terms used as triple objects.
                The object type can be an XSD data type, the token <code>#iri</code> denoting a
                resource IRI, or the token <code>#resource</code>. The latter token signals that the
                triple object is the subject IRI used by the resource description obtained for the
                value item, which must be a node. The resource description is the result of applying
                to the value node an appropriate resource model, which is either explicitly
                specified (@objectModelID) or determined by matching the node against the target
                node constraints of the available resource models.</para>
            <para>The <emphasis role="ital">language tag</emphasis> is used to turn the object value
                into a language-tagged string.</para>
            <para>The <emphasis role="ital">object resource model</emphasis> is evaluated in
                conjunction with object type <code>#resource</code>. It identifies a resource model
                to be used when mapping value nodes yielded by the object value expression to
                resource descriptions.</para>
            <para>The <emphasis role="ital">RDF list flag</emphasis> indicates whether or not the
                RDF terms obtained from the object value expression are arranged as an RDF list
                (default: no).</para>
            <para>The <emphasis role="ital">reverse flag</emphasis> can indicate that the items
                obtained from the object value expression represent the subjects, rather than
                objects, of the triples to be constructed, in which case the target node of the
                containing resource model becomes the triple object. </para>
            <para><emphasis role="ital">Conditional settings</emphasis> is a container for settings
                (e.g. property IRI or object type IRI) applied only to those value items which meet
                a condition. The condition is expressed by an XPath expression which references the
                value item as an additional context variable (<code>rdfe:value</code>). </para>
        </section>
        <section xml:id="construct-constructor">
            <title>Context constructor</title>
            <para>Using RDFe, the construction of RDF triples is based on the evaluation of XPath
                expressions. Evaluation can be supported by an <emphasis role="bold">evaluation
                    context</emphasis> consisting of variables and functions accessible within the
                expression. The context is obtained from a <emphasis role="ital">context
                    constructor</emphasis> represented by a <code>&lt;context></code> element. A
                distinct instance of the context is constructed for each XML document containing a
                node which is used as context node by an expression from the semantic map defining
                the context. The context constructor is a collection of variable and function
                constructors. Variable constructors associate a name with an XQuery expression
                providing the value. Function constructors associate a name with an XQuery function
                defined in terms of parameter names, return value type and an expression providing
                the function value. As the expressions used by the variable and function
                constructors are evaluated in the context of the root element of the document in
                question, variable values as well as function behaviour may reflect the contents of
                the document. Variable values may have any type defined by the XDM data model,
                version 3.1 <xref linkend="xdm31"/> (sequences of items which may be atom, node,
                map, array or function). Context functions are called within expressions like normal
                functions, yet provide behaviour defined by the semantic map and possibly dependent
                on document contents.</para>
        </section>
    </section>
    <section>
        <title>Evaluation</title>
        <para>Semantic maps are evaluated by an <emphasis role="bold">RDFe processor</emphasis>.
            This section describes the processing in an informal way. See also <xref
                linkend="appendix-formal-definition"/>.</para>
        <section>
            <title>Input / Ouput</title>
            <para>Processing input is</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>An initial set of XML documents</para>
                </listitem>
                <listitem>
                    <para>A set of semantic map documents</para>
                </listitem>
            </itemizedlist>
            <para>Processing output is a set of RDF triples, usually designed to express semantic
                content of the XML documents.</para>
            <para>The set of <emphasis role="bold">contributing semantic maps</emphasis> consists of
                the set explicitly supplied, as well as all semantic maps directly or indirectly
                imported by them.</para>
            <para>The set of <emphasis role="bold">contributing XML documents</emphasis> is not
                limited to the <emphasis role="ital">initial</emphasis> input documents, as
                expressions used to construct triples my access other documents by derefencing URIs
                found in documents or semantic maps. This is an example of navigation into a
                document which may not have been part of the initial set of input documents: </para>
            <programlisting><![CDATA[ <re:property iri="ont:country" type="#resource" 
              value="country/@href/doc(.)//country"/>]]></programlisting>
            <para>RDFe thus supports a linked data view.</para>
        </section>
        <section xml:id="hybrid-triples">
            <title>Hybrid triples and preliminary resource description</title>
            <para>Understanding the processing of semantic maps is facilitated by the auxiliary
                concepts of a “hybrid triple” and a “preliminary resource description”. When a
                property model uses the type specification <code>#resource</code>, the nodes
                obtained from the object value expression of the property model are viewed as
                    <emphasis role="ital">XML nodes representing resources</emphasis>, and the
                triple objects are the <emphasis role="ital">IRIs of these resources</emphasis>. The
                resource is identified by the combined identities of XML node and resource model to
                be used in order to map the node to a resource description. When this resource has
                already been described in an earlier phase of the evaluation, the IRI is available
                and the triple can be constructed. If the resource description has not yet been
                created, the IRI is still unknown and the triple cannot yet be constructed. In this
                situation, a <emphasis role="bold">hybrid triple</emphasis> is constructed, using
                the pair of XML node and resource model ID as object. A hybrid triple is a
                preliminary representation of the triple eventually to be constructed. A resource
                description is called <emphasis role="bold">preliminary</emphasis> or <emphasis
                    role="bold">final</emphasis>, dependent on whether or not it contains hybrid
                triples. A preliminary description is turned into a final description by creating
                for each hybrid triple a resource description and replacing the hybrid triple object
                by the subject IRI used by that description. The resource description created for
                the hybrid triple object may itself contain hybrid triples, but in any case it
                provides the IRI required to finalize the hybrid triple currently processed. If the
                new resource description is preliminary, it will be finalized in the same way, by
                creating for each hybrid triple yet another resource description which also provides
                the required IRI. In general, the finalization of preliminary resource descriptions
                is a recursive processing which ends when any new resource descriptions are
                final.</para>
        </section>
        <section>
            <title>Asserted target nodes</title>
            <para>The scope of processing is controlled by the <emphasis role="bold">asserted
                    resource descriptions</emphasis>, the set of resource descriptions which MUST be
                constructed, given a set of semantic maps and an <emphasis role="ital"
                    >initial</emphasis> set of XML documents. Such a description is identified by an
                XML node representing the resource and a resource model ID identifying the model to
                be used for mapping the node to an RDF description. (Note that for a single XML node
                more than one mapping may be defined, that is, more than one resource model may
                accept the same XML node as a target.) The <emphasis role="bold">asserted target
                    nodes</emphasis> of a resource model are the XML nodes to which the resource
                model must be applied in order to create all asserted resource descriptions
                involving this resource model.</para>
            <para>Any <emphasis role="bold">additional resource descriptions</emphasis> are only
                constructed if they are required in order to construct an asserted resource
                description. An additional resource description is required if without this
                description another description (asserted or itself additional) would be
                preliminary, that is, contain hybrid triples. As the discovery of required resource
                descriptions may entail the discovery of further required resource descriptions, the
                discovery process is recursive, as explained in <xref linkend="hybrid-triples"
                />.</para>
            <para>The asserted target nodes of a resource model are determined by the <emphasis
                    role="bold">target node assertion</emphasis> of the resource model, an
                expression evaluated in the context of each <emphasis role="ital">initial</emphasis>
                XML document. Note that the target node assertion is not applied to XML documents
                which do not belong to the initial set of XML documents. Such additional documents
                contribute only additional resource descriptions, no asserted resource descriptions.
                Initial documents, on the other hand, may contribute asserted and/or additional
                descriptions.</para>
        </section>
        <section>
            <title>Processing steps</title>
            <para>The processing of semantic maps can now be described as a sequence of
                steps:</para>
            <orderedlist spacing="compact">
                <listitem>
                    <para>For each resource model identify its asserted target nodes.</para>
                </listitem>
                <listitem>
                    <para>For each asserted target node create a resource description (preliminary
                        or final).</para>
                </listitem>
                <listitem>
                    <orderedlist spacing="compact">
                        <listitem>
                            <para>Map any hybrid triple object to a new resource description</para>
                        </listitem>
                        <listitem>
                            <para>Replace the hybrid triple object by the IRI provided by the new
                                resource description</para>
                        </listitem>
                    </orderedlist>
                </listitem>
                <listitem>
                    <para>If any resource descriptions created in (3) contain hybrid triples, repeat
                        (3)</para>
                </listitem>
                <listitem>
                    <para>The result is the set of all RDF triples created in steps (2) and
                        (3).</para>
                </listitem>
            </orderedlist>
            <para>For a formal definition of the processing see <xref
                    linkend="appendix-formal-definition"/>.</para>
        </section>
    </section>
    <section>
        <title>RDFe for non-XML resources</title>
        <para>The core capability of the XPath language is the navigation of XDM node trees, and
            this navigation is the “engine” of RDFe. The W3C recommendations defining XPath 3.1
                (<xref linkend="xpath31"/> and <xref linkend="xpathfunctions31"/>) do not define
            functions parsing HTML and CSV, and the function defined to parse JSON into node trees
                (<code>fn:json-to-xml</code>) uses a generic vocabulary which makes navigation
            awkward. Implementation-defined XPath extension functions, on the other hand, which
            parse JSON, HTML and CSV into navigation-friendly node trees are common (e.g. BaseX
                <xref linkend="basex"/> functions <code>json:parse</code>, <code>html:parse</code>
            and <code>csv:parse</code>). An RDFe processor may offer <emphasis role="bold"
                >implementation-defined support</emphasis> for such functions and, by implication,
            also enable the mapping of non-XML resources to RDF triples.</para>
    </section>
    <section>
        <title>Conformance</title>
        <para>An <emphasis role="bold">RDFe processor</emphasis> translates an initial set of XML
            documents and a set of semantic maps to a set of RDF triples.</para>
        <section>
            <title>Minimal conformance</title>
            <para>Minimal conformance requires a processing as described in this paper. It includes
                support for <emphasis role="bold">XPath 3.1 expressions</emphasis> in any place of a
                semantic map where an XPath expression is expected:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>targetAssertion/@expr</para>
                </listitem>
                <listitem>
                    <para>targetNodeAssertion/@expr</para>
                </listitem>
                <listitem>
                    <para>var/@value</para>
                </listitem>
                <listitem>
                    <para>fun/@code</para>
                </listitem>
                <listitem>
                    <para>resource/@iri</para>
                </listitem>
                <listitem>
                    <para>resource/@assertedTargetNodes</para>
                </listitem>
                <listitem>
                    <para>property/@value</para>
                </listitem>
                <listitem>
                    <para>property/@lang</para>
                </listitem>
                <listitem>
                    <para>valueItemCase/@test</para>
                </listitem>
                <listitem>
                    <para>valueItemCase/@value</para>
                </listitem>
                <listitem>
                    <para>valueItemCase/@lang</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Optional feature: XQuery Expressions Feature</title>
            <para>If an implementation provides the <emphasis role="bold">XQuery Expressions
                    Feature</emphasis>, it must support XQuery 3.1 <xref linkend="xquery31"/>
                expressions in any place of a semantic map where an XPath expression is
                expected.</para>
        </section>
        <section>
            <title>Implementation-defined extension functions</title>
            <para>An implementation may support implementation-defined XPath extension functions.
                These may in particular enable the parsing of non-XML resources into XDM node trees
                and thus support the RDFe-defined mapping of non-XML resources to RDF
                triples.</para>
        </section>
    </section>
    <section>
        <title>Implementation</title>
        <para>An implementation of an RDFe processor is available on github <xref linkend="shax"/>
                (<code>https://github.com/hrennau/shax</code>). The processor is provided as a
            command line tool (<code>shax.bat</code>, <code>shax.sh</code>). Example call:</para>
        <programlisting>shax rdfe?dox=drug*.xml,semap=drugbank.*rdfe.xml</programlisting>
        <para>The implementation is written in XQuery and requires the use of the BaseX <xref
                linkend="basex"/> XQuery processor. It supports the XQuery Expressions Feature and
            all XPath extension functions defined by BaseX. This includes functions for parsing
            JSON, HTML and CSV into node trees (<code>json:parse</code>, <code>html:parse</code>,
                <code>csv:parse</code>). The implementation can therefore be used for mapping any
            mixture of XML, JSON, HTML and CSV resources to an RDF graph.</para>
    </section>
    <section>
        <title>Discussion</title>
        <para>The purpose of RDFe is straightforward: to support the mapping of XML data to RDF
            data. Why should one want to do this? In a “push scenario”, XML data are the primary
            reality, and RDF is a means to augment it by an additional representation. In a “pull
            scenario”, an RDF model comes first, and XML is a data source used for populating the
            model. Either way, the common denominator is information content which may be
            represented in alternative ways, as a tree or as a graph. The potential usefulness of
            RDFe (and other tools for mapping between tree and graph, like RDFa <xref linkend="rdfa"
            />, JSON-LD <xref linkend="jsonld"/> and GraphQL <xref linkend="graphql"/>) depends on
            the possible benefits of switching between the two models. Such benefits emerge from the
            complementary character of these alternatives. </para>
        <para>A tree representation offers an optimal reduction of complexity, paying the price of a
            certain arbitrariness. The reduction of complexity is far more obvious than the
            arbitrariness. Tree structure decouples amount and complexity of information. A
            restaurant menu, for example, is a tree, with inner nodes like starters, main courses,
            desserts and beverages, perhaps further inner nodes (meat, fish, vegetarian, etc.) and
            leaf nodes which are priced offerings. Such representation fits the intended usage so
            well that it looks natural. But when integrating the menu data from all restaurants in a
            town - how to arrange intermediate nodes like location, the type of restaurant, price
            category, ratings, …? It may also make sense to pull the menu items out of the menus,
            grouping by name of the dish.</para>
        <para>A graph representation avoids arbitrariness by reducing information to an essence
            consisting of resources, properties and relationships – yet pays the price of a certain
            unwieldiness. Graph data are more difficult to understand and to use. If switching
            between tree and graph were an effortless operation, what could be gained by “seeing” in
            a tree the graph which it represents, and by “seeing” in a graph the trees which it can
            become? </para>
        <figure xml:id="magritte-clairvoacne">
            <title>La clairvoyance, Rene Magritte, 1936</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/magritte-la-clairvoyance.jpg" scalefit="1" width="100%"
                    />
                </imageobject>
                <caption>
                    <para>
                        <emphasis role="italic">A painting suggesting a thorough consideration of
                            the relationship between XML and RDF.</emphasis>
                    </para>
                </caption>
            </mediaobject>
        </figure>
        <para>Think of two XML documents, one representing <code>&lt;painter></code> as child
            element of <code>&lt;painting></code>, the other representing <code>&lt;painting></code>
            as child element of <code>&lt;painter></code>. From a tree-only perspective they are
            stating different facts; from a graph-in-tree perspective, they are representing the
                <emphasis role="ital">same information</emphasis>, which is about painters,
            paintings and a relationship between the two. Such intuitive insight may be <emphasis
                role="ital">inferred</emphasis> by a machine if machine-readable instructions for
            translating both documents into RDF are available. Interesting opportunities for data
            integration and quality control seem to emerge. A document-to-document transformation,
            for example, may be checked for semantic consistency. </para>
        <para>If the potential of using tree and graph quasi-simultaneously has hardly been
            explored, so far, a major reason <emphasis role="ital">may</emphasis> be the high
            “resistence” which hinders a flow of information between the two models. RDFe addresses
            one half of this problem, the direction tree-to-graph. RDFe is meant to complement
            approaches dealing with the other half, e.g. GraphQL <xref linkend="graphql"/>.</para>
        <para>RDFe is committed to XPath as <emphasis role="ital">the</emphasis> language for
            expressing mappings within a forest of information. The conclusion that RDFe is
            restricted to dealing with XML data would be a misunderstanding, due to oversight that
            any tree structure (e.g. JSON and any table format) can be parsed into an XDM node tree
            and thus become accessible to XPath navigation. Another error would be to think that
            RDFe is restricted to connecting information <emphasis role="ital">within</emphasis>
            documents, as XPath offers excellent support for inter-document navigation (see also the
            example given in <xref linkend="linking-resources"/>). Contrary to widespread views,
            XPath may be understood and used as a universal language for tree navigation - and RDFe
            might accordingly serve as a general language for mapping information forest to RDF
            graph.</para>
    </section>
    <appendix xml:id="appendix-formal-definition">
        <title>Processing semantic maps - formal definition</title>
        <para>The processing of semantic maps is based on the building block of an <emphasis
                role="bold">RDFe expression (rdfee)</emphasis>. An rdfee is a pair consisting of an
                <emphasis role="bold">XML node</emphasis> and a <emphasis role="bold">resource
                model</emphasis>: <programlisting>  rdfee ::= (xnode, rmodel)</programlisting> The
            XML node is viewed as representing a resource, and the resource model defines how to
            translate the XML node into an RDF resource description. An rdfee is an expression which
            can be resolved to a set of tripels.</para>
        <para>Resource models are contained by a <emphasis role="bold">semantic map</emphasis>. A
            set of semantic maps is called a <emphasis role="bold">semantic extension
                (SE)</emphasis>. A semantic extension is a function which maps a set of XML
            documents to a (possibly empty) set of RDF triples:</para>
        <programlisting>  triple* = SE(document+)</programlisting>
        <para>The mapping is defined by the following rules, expressed in pseudo-code. </para>
        <section>
            <title>Section 1: Top-level rule</title>
            <programlisting><emphasis role="bold">triples</emphasis>(docs, semaps) ::=
    for rdfee in <emphasis role="underline">rdfees</emphasis>(docs, semaps):
        <emphasis role="underline">rdfee-triples</emphasis>(rdfee, semaps)
</programlisting>
        </section>
        <section>
            <title>Section 2: Resolving an rdfee to a set of triples</title>
            <programlisting><emphasis role="bold">rdfee-triples</emphasis>(rdfee, semaps) ::=
    for pmodel in <emphasis role="underline">pmodels</emphasis>(rdfee.rmodel),
    for value in <emphasis role="underline">values</emphasis>(pmodel, rdfee.xnode):
    (	
        <emphasis role="underline">resource-iri</emphasis>(rdfee.rmodel, rdfee.xnode), 
        <emphasis role="underline">property-iri</emphasis>(pmodel, rdfee.xnode), 
        <emphasis role="underline">triple-object</emphasis>(value, pmodel, semaps)
    )

<emphasis role="bold">values</emphasis>(pmodel, xnode) ::=
    <emphasis role="underline">xpath</emphasis>(pmodel/@value, xnode, <emphasis role="underline">containing-semap</emphasis>(pmodel))

<emphasis role="bold">resource-iri</emphasis>(rmodel, xnode) ::=
    <emphasis role="underline">xpath</emphasis>(rmodel/@iri, xnode, <emphasis role="underline">containing-semap</emphasis>(rmodel))

<emphasis role="bold">property-iri</emphasis>(pmodel, xnode) ::=
    <emphasis role="underline">xpath</emphasis>(pmodel/@iri, xnode, <emphasis role="underline">containing-semap</emphasis>(pmodel))

<emphasis role="bold">triple-object</emphasis>(value, pmodel, semaps) ::=
    if <emphasis role="underline">object-type</emphasis>(value, pmodel) = "#resource":
        <emphasis role="underline">resource-iri</emphasis>(<emphasis role="underline">rmodel-for-xnode</emphasis>(value, pmodel), value)
    else:
        <emphasis role="underline">rdf-value</emphasis>(value, <emphasis role="underline">object-type</emphasis>(value, pmodel))

<emphasis role="bold">rmodel-for-xnode</emphasis>(xnode, pmodel, semaps) ::=
    if pmodel/@objectModelID:
        <emphasis role="underline">rmodel</emphasis>(pmodel/@objectModelID, semaps)
    else:
        <emphasis role="underline">best-matching-rmodel-for-xnode</emphasis>(xnode, semaps)

<emphasis role="bold">best-matching-rmodel-for-xnode</emphasis>(xnode, semaps):
[Returns the rmodel which is matched by xnode and, if several rmodels  
are matched, is deemed the best match; rules for “best match” may evolve; 
current implementation treats the number of target node constraints as a 
measure of priority – the better match is the rmodel with a greater number 
of constraints; an explicit @priority à la XSLT is considered a future 
option.]

<emphasis role="bold">object-type</emphasis>(value, pmodel):
[Returns the type to be used for a value obtained from the value expression; 
value provided by pmodel/@type or by pmodel/valueItemCase/@type.]

<emphasis role="bold">rdf-value</emphasis>(value, type):
[Returns a literal with lexical form = string(value), datatype = type.]
</programlisting>
        </section>
        <section>
            <title>Section 3: Resolving input documents to a set of rdfees</title>
            <programlisting><emphasis role="bold">rdfees</emphasis>(docs, semaps) ::=	
	for rdfee in <emphasis role="underline">asserted-rdfees</emphasis>(docs, semaps):
        rdfee,
        <emphasis role="underline">required-rdfees</emphasis>(rdfee, semaps)

<emphasis role="ital">Sub section: asserted rdfees</emphasis>

<emphasis role="bold">asserted-rdfees</emphasis>(docs, semaps) ::=	
    for doc in docs,
    for semap in semaps:
        if <emphasis role="underline">doc-matches-semap</emphasis>(doc, semap):
            for rmodel in <emphasis role="underline">rmodels</emphasis>(semap),
            for xnode in <emphasis role="underline">asserted-target-nodes</emphasis>(rmodel, doc):
                (xnode, rmodel)

<emphasis role="bold">asserted-target-nodes</emphasis>(rmodel, doc) ::=	
    xpath(rmodel/@assertedTargetNodes, doc, <emphasis role="underline">containing-semap</emphasis>(rmodel))

<emphasis role="ital">Sub section: required rdfees</emphasis>

<emphasis role="bold">required-rdfees</emphasis>(rdfee, semaps) ::=
    for pmodel in <emphasis role="underline">pmodels</emphasis>(rdfee.rmodel),
    for value in <emphasis role="underline">values</emphasis>(pmodel, rdfee.xnode):
        <emphasis role="underline">required-rdfee</emphasis>(value, pmodel, semaps)

<emphasis role="bold">required-rdfee</emphasis>(xnode, pmodel, semaps) ::=
    if <emphasis role="underline">object-type</emphasis>(xnode, pmodel) = "#resource": 
        let rmodel ::= <emphasis role="underline">rmodel-for-xnode</emphasis>(value, pmodel, semaps),
        let required-rdfee ::= (xnode, rmodel):
            required-rdfee,
            <emphasis role="underline">required-rdfees</emphasis>(required-rdfee, semaps )
</programlisting>
        </section>
        <section>
            <title>Section 4: auxilliary rules</title>
            <programlisting><emphasis role="bold">doc-matches-semap</emphasis>(doc, semap):
[Returns true if doc matches the target document constraints of semap.]

<emphasis role="bold">xnode-matches-rmodel</emphasis>(xnode, rmodel):
[Returns true if xnode matches the target node constraints of rmodel.]

<emphasis role="bold">rmodel</emphasis>(rmodelID, semaps) ::=
[Returns the rmodel with an ID matching rmodelID.]

<emphasis role="bold">rmodels</emphasis>(semap) ::= semap//resource

<emphasis role="bold">pmodels</emphasis>(rmodel) ::= rmodel/property

<emphasis role="bold">containing-doc</emphasis>(xnode) ::= xnode/root()

<emphasis role="bold">containing-semap</emphasis>(semapNode) ::= semapNode/ancestor-or-self::semanticMap

<emphasis role="bold">xpath</emphasis>(xpath-expression, contextNode, semap) ::=
[Value of xpath-expression, evaluated as XPath expression using contextNode 
as context node and a dynamic context including all in-scope variables from 
the dynamic context constructed for the combination of the document 
containing contextNode and semap.]
</programlisting>
        </section>
    </appendix>
    <bibliography>
        <biblioentry xml:id="basex">
            <abbrev>1</abbrev>
            <title>BaseX</title>
            <date>2019</date>
            <publisher>
                <publishername>BaseX GmbH</publishername>
            </publisher>
            <biblioid class="uri">http:// basex.org</biblioid>
        </biblioentry>
        <biblioentry xml:id="drugbank">
            <abbrev>2</abbrev>
            <title>DrugBank 5.0: a major update to the DrugBank database for 2018.</title>
            <date>2017</date>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>DS</firstname>
                        <surname>Wishart</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>YD</firstname>
                        <surname>Feunang</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>AC</firstname>
                        <surname>Guo</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>EJ</firstname>
                        <surname>Lo</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>A</firstname>
                        <surname>Marcu</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>JR</firstname>
                        <surname>Grant</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>T</firstname>
                        <surname>Sajed</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>D</firstname>
                        <surname>Johnson</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>C</firstname>
                        <surname>Li</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Z</firstname>
                        <surname>Sayeeda</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>N</firstname>
                        <surname>Assempour</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>I</firstname>
                        <surname>Iynkkaran</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Y</firstname>
                        <surname>Liu</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>A</firstname>
                        <surname>Maciejewski</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>N</firstname>
                        <surname>Gale</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>A</firstname>
                        <surname>Wilson</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>L</firstname>
                        <surname>Chin</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>R</firstname>
                        <surname>Cummings</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>D</firstname>
                        <surname>Le</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>A</firstname>
                        <surname>Pon</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>C</firstname>
                        <surname>Knox</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>M</firstname>
                        <surname>Wilson</surname>
                    </personname>
                </author>
            </authorgroup>
            <publisher>
                <publishername>Nucleic Acids Res. 2017 Nov 8.</publishername>
            </publisher>
            <biblioid class="uri">https://www.drugbank.ca/</biblioid>
            <biblioid class="doi">10.1093/nar/gkx1037</biblioid>
        </biblioentry>
        <biblioentry xml:id="graphql">
            <abbrev>3</abbrev>
            <title>GraphQL</title>
            <date>2017</date>
            <publisher>
                <publishername>Facebook Inc.</publishername>
            </publisher>
            <biblioid class="uri">http://graphql.org/</biblioid>
        </biblioentry>
        <biblioentry xml:id="jsonld">
            <abbrev>4</abbrev>
            <title>JSON-LD 1.0. A JSON-based Serialization for Linked Data</title>
            <date>2014</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/json-ld/</biblioid>
        </biblioentry>
        <biblioentry xml:id="location-trees">
            <abbrev>5</abbrev>
            <title>Location trees enable XSD based tool development.</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2017</date>
            <biblioid class="uri"
                >http://xmllondon.com/2017/xmllondon-2017-proceedings.pdf</biblioid>
        </biblioentry>
        <biblioentry xml:id="rdfa">
            <abbrev>6</abbrev>
            <title>RDFa Core 1.1 – Third Edition.</title>
            <date>2015</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/rdfa-core/</biblioid>
        </biblioentry>
        <biblioentry xml:id="turtle">
            <abbrev>7</abbrev>
            <title>RDF 1.1 Turtle</title>
            <date>2014</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/turtle/</biblioid>
        </biblioentry>
        <biblioentry xml:id="shax">
            <abbrev>8</abbrev>
            <title>A SHAX processor, transforming SHAX models into SHACL, XSD and JSON
                Schema.</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2017</date>
            <biblioid class="uri">https://github.com/hrennau/shax</biblioid>
        </biblioentry>
        <biblioentry xml:id="xpath31">
            <abbrev>9</abbrev>
            <title>XML Path Language (XPath) 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xpathfunctions31">
            <abbrev>10</abbrev>
            <title>XPath and XQuery Functions and Operators 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-functions-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xdm31">
            <abbrev>11</abbrev>
            <title>XQuery and XPath Data Model 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-datamodel-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xquery31">
            <abbrev>12</abbrev>
            <title>XQuery 3.1: An XML Query Language</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xquery-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xsdplus">
            <abbrev>13</abbrev>
            <title>xsdplus - a toolkit for XSD based tool development</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2017</date>
            <biblioid class="uri">https://github.com/hrennau/xsdplus</biblioid>
        </biblioentry>
    </bibliography>
</article>
