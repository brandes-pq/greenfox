<?xml-model href='http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng' schematypens='http://relaxng.org/ns/structure/1.0'?><?xml-model href='http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng' type='application/xml' schematypens='http://purl.oclc.org/dsdl/schematron'?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0">
    <info>
        <title>Greenfox – a schema language for validating file systems</title>
        <author>
            <personname>Hans-Juergen Rennau</personname>
            <email>hans-juergen.rennau@parsqube.de</email>
            <personblurb>
                <para/>
            </personblurb>
            <affiliation>
                <orgname>parsQube GmbH</orgname>
            </affiliation>
        </author>
        <keywordset>
            <keyword>Validation, SHACL, XSD, JSON Schema, Schematron</keyword>
        </keywordset>
        <abstract>
            <para>Greenfox is a schema language for validating file systems. One key feature is an
                abstract validation model inspired by the SHACL language. Another key feature is a
                view of the file system which is based on the XDM data model and thus supports a set
                of powerful expression languages (XPath, foxpath, XQuery). Using their expressions
                as basic building blocks, the schema language unifies navigation within and between
                resources and access to the structured contents of files with different mediatypes.
            </para>
        </abstract>
    </info>
    <section xml:id="introduction">
        <title>Introduction</title>
        <para>How to validate data against expectations? Major options are visual inspection,
            programmatic checking and validation against a schema document (e.g. XSD, RelaxNG,
            Schematron, JSON Schema) or a schema graph (e.g. SHACL). Schema validation is in many
            scenarios the superior approach, as it is automated and declarative. But there are also
            limitations worth considering when thinking about validation in general. </para>
        <para>First, schema languages describe instances of a particular format or mediatype only
            (e.g. XML, JSON, RDF), whereas typical projects involve a mixture of mediatypes.
            Therefore schema validation tends to describe the state of resources which are pieces
            from a jigsaw puzzle, and the question arises how to integrate the results into a
            coherent whole. </para>
        <para>Second, several schema languages of key importance are grammar based and therefore do
            not support “incremental validation” – starting with a minimum of constraints, and
            adding more along the way. We cannot use XSD, RelaxNG or JSON Schema in order to express
            some very specific key expectation, without saying many things about the document as a
            whole, which may be a task requiring disproportional effort. Rule based schema languages
            (like Schematron) do support incremental validation, but they are inappropriate for
            comprehensive validation as accomplished by grammar based languages.</para>
        <para>As a consequence, schema validation enables isolated acts of resource validation, but
            it cannot accomplish the integration of validation results. Put differently, schema
            validation may contribute to, but cannot accomplish, system validation. The situation
            might change in an interesting way if we had a schema language for validating <emphasis
                role="ital">file system contents</emphasis> – arbitrary trees of files and folders.
            This simple abstraction suffices to accommodate any software project, and it can
            accommodate system representations of very large complexity. </para>
        <para>This document describes an early version of <emphasis role="bold">greenfox</emphasis>,
            a schema language for validating file system contents. By implication, it can also be
            viewed as a schema language for the validation of <emphasis role="ital"
                >systems</emphasis>. Such a claim presupposes that a meaningful reflection of system
            properties, state and behaviour can be represented by a collection of data (log data,
            measurement results, test results, configurations, …) distributed over a set of files
            arranged in a tree of folders. It might then sometimes be possible to translate
            meaningful definitions of system validity into constraints on file system contents. At
            other times it may not be possible, for example if the assessment of validity requires a
            tracking of realtime data.</para>
        <para>The notion of system validation implies that extensibility must be a key feature of
            the language. The language must not only offer a scope of expressiveness which is
            immediately useful. It must at the same time serve as a <emphasis role="ital"
                >framework</emphasis>, within which current capabilities, future extensions and
            third-party contributions are uniform parts of a coherent whole. The approach we took is
            a generalization of the key concepts underlying SHACL <xref linkend="shacl"/>, a
            validation language for RDF data. These concepts serve as the building blocks of a
            simple metamodel of validation, which offers guidance for extension work.</para>
        <para>Validation relies on the key operations of navigation and comparison. File system
            validation must accomplish them in the face of divers mediatypes and the necessity to
            combine navigation within as well as between resources. In response to this challenge,
            greenfox is based on a <emphasis role="ital">unified data model</emphasis> (XDM) <xref
                linkend="shacl"/> and a <emphasis role="ital">unified navigation model</emphasis>
            (foxpath/XPath) <xref linkend="foxpath"/>
            <xref linkend="foxpath2"/>
            <xref linkend="foxpath3"/>, <xref linkend="xpath31"/>
            <xref linkend="xquery31"/> built upon it. </para>
        <para>Validation produces results, and the more complex the system, the more important it
            may become to produce results in a form which combines maximum precision with optimal
            conditions for integration with other resources. This goal is best served by a <emphasis
                role="ital">vocabulary</emphasis> for expressing validation results and schema
            contents in a way which does not require any context (like a document type) for being
            understood. We choose an RDF based definition of validation schema and validation
            results, combined with a bidirectional mapping between RDF and more intuitive
            representations, XML and JSON. For practical purposes, we assume the XML representation
            to be the form most frequently used. Concerning schemas, this document discusses only
            the XML representation. Concerning results, XML and RDF are dealt with. </para>
        <para>Before providing an overview of the greenfox language, a detailed example should give
            a first impression of how the language can be used.</para>
    </section>
    <section xml:id="getting-started">
        <title>Getting started with greenfox</title>
        <para>This section illustrates the development of a greenfox schema designed for validating
            a file system tree against a set of expections. Such a validation can also be viewed as
            validation of the system “behind” the file system tree, represented by its
            contents.</para>
        <section>
            <title>The system – system S</title>
            <para>Consider <emphasis role="bold">system S</emphasis> – an imaginary system which is
                a collection of web services. We are going to validate a <emphasis role="ital">file
                    system representation</emphasis> which is essentially a set of test results,
                accompanied by resources supporting validation (XSDs, codelists and data about
                expected response messages). The following listing shows a file system tree which is
                a representation of system S, as observed at a certain point in time:</para>
            <programlisting><![CDATA[
system-s
. resources
. . codelists
. . . codelist-foo-article.xml
. . xsd
. . . schema-foo-article.xsd
. testcases
. . test-t1
. . . config
. . . . msg-config.xml
. . . input
. . . . getFooRQ*.xml
. . . output
. . . . getFooRS*.xml
. . +test-t2   (contents: see test-t1)
. . usecases
. . . usecase-u1
. . . . usecase-u1a
. . . . . +test-t3   (contents: see test-t1)]]></programlisting>
            <para>The concrete file system tree must be distinguished from the <emphasis role="ital"
                    >expected file system</emphasis> tree, which is described by the following
                rules.</para>
            <table xml:id="table-1">
                <title>Rules defining "validity" of the considered file system.</title>
                <titleabbrev xml:id="table-1-shorttitle">Validity rules</titleabbrev>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="2*"/>
                    <colspec colname="c2" colnum="2" colwidth="4*"/>
                    <colspec colname="c3" colnum="3" colwidth="11*"/>
                    <thead>
                        <row>
                            <entry align="left">File or folder</entry>
                            <entry align="left">File path</entry>
                            <entry align="left">Expectation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">resources/codelists</entry>
                            <entry align="left">Contains one or more codelist files</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">resources/codelists/*</entry>
                            <entry align="left">A <emphasis role="bold">codelist file</emphasis>;
                                name not constrained; must be an XML document containing
                                    <code>&lt;codelist></code> elements with a @name attribute and
                                    <code>&lt;entry></code> children</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">resources/xsd</entry>
                            <entry align="left">Contains one or more XSDs describing services
                                messages</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">resources/xsd/*</entry>
                            <entry align="left">An <emphasis role="bold">XSD schema file</emphasis>;
                                name not constrained</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*</entry>
                            <entry align="left">A test case folder, containing <code>input</code>,
                                    <code>output</code> and <code>config</code> folders; apart from
                                these only optional <code>log-*</code> files are allowed </entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*/config</entry>
                            <entry align="left">Test case config folder, containing file
                                    <code>msg-config.csv</code></entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">.//test-*/config/msg-config.csv</entry>
                            <entry align="left">A <emphasis role="bold">message configuration
                                    file</emphasis>; CSV file with three columns: request file name,
                                response file name, expected return code</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*/input</entry>
                            <entry align="left">Test case input folder, containing request
                                messages</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">.//test-*/input/*</entry>
                            <entry align="left">A <emphasis role="bold">request message
                                    file</emphasis>; name extension <code>.xml</code> or
                                    <code>.json</code>; mediatype corresponding to name
                                extension</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*/output</entry>
                            <entry align="left">Test case output folder, containing response
                                messages</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">.//test-*/output/*</entry>
                            <entry align="left">A <emphasis role="bold">response message
                                    file</emphasis>; name extension <code>.xml</code> or
                                    <code>.json</code>; mediatype corresponding to name
                                extension</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>The number and location of testcase folders (<code>test-*</code>) are
                unconstrained. This means that the testcase folders may be grouped and wrapped in
                any way, although they must not be nested. So the use of a <code>testcases</code>
                folder wrapping all testcase folders - and the use of <code>usecase*</code> folders
                adding additional substructure - is allowed, but must not be expected. The placing
                of XSDs in folder <code>resources/xsd</code>, on the other hand, is obligatory, and
                likewise the placing of codelist documents in folder
                    <code>resources/codelists</code>. The names of XSD and codelist files are not
                constrained. </para>
            <para>Apart from these static constraints, the presence of some files implies the
                presence of other files:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>For every request message, there must be a response message with a name
                        derived from the request file name (replacing substring <code>RQ</code> with
                            <code>RS</code>).</para>
                </listitem>
            </itemizedlist>
            <para>Expectations are not limited to the presence of files and folders - they include
                details of file contents, in some cases relating the contents of different files
                with different mediatypes: </para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>For every response message in XML format, there is exactly one XSD against
                        which it can be validated</para>
                </listitem>
                <listitem>
                    <para>Every response message in XML format is valid against the appropriate
                        XSD</para>
                </listitem>
                <listitem>
                    <para>Response message items (XML elements and JSON fields) with a particular
                        name (e.g. <code>fooValue</code>) must be found in the appropriate XML
                        codelist discovered in a set of codelist files</para>
                </listitem>
                <listitem>
                    <para>Response message return codes (contained by XML and JSON documents) must
                        be as configured by the corresponding row in a CSV table</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Building a greenfox schema "system S"</title>
            <para>Now we create a greenfox schema which enables us to validate the file system
                against these expectations. An initial version only checks the existence of
                non-empty XSD and codelists folders:</para>
            <programlisting>
&lt;greenfox greenfoxURI="http://www.greenfox.org/ns/schema-examples/system-s"
          xmlns="http://www.greenfox.org/ns/schema">
          
  &lt;!-- *** System file tree *** -->    
  &lt;<emphasis role="bold">domain</emphasis> path="\tt\greenfox\resources\example-system\system-s" 
          name="system-s">    
        
      &lt;!-- *** System root folder shape *** -->
      &lt;<emphasis role="bold">folder</emphasis> foxpath="." id="systemRootFolderShape">
            
        &lt;!-- *** XSD folder shape *** -->
        &lt;<emphasis role="bold">folder</emphasis> foxpath="<emphasis role="bold">.\\resources\xsd</emphasis>" id="xsdFolderShape">
            &lt;targetSize count="1" 
                        countMsg="No XSD folder found"/>
                        
            &lt;<emphasis role="bold">file</emphasis> foxpath="<emphasis role="bold">*.xsd</emphasis>" id="xsdFileShape">
                &lt;targetSize minCount="1" 
                            minCountMsg="No XSDs found"/>
            &lt;/file>
        &lt;/folder>                

        &lt;!-- *** Codelist folder shape *** -->
        &lt;<emphasis role="bold">folder</emphasis> foxpath="<emphasis role="bold">.\\resources\codelists</emphasis>" id="codelistFolderShape">
            &lt;targetSize count="1" 
                        countMsg="No codelist folder found"/>
                        
            &lt;<emphasis role="bold">file</emphasis> foxpath="<emphasis role="bold">*[is-xml(.)]</emphasis>" id="codelistFileShape">
                &lt;targetSize minCount="1" 
                            minCountMsg="No codelist files found"/>
            &lt;/file>
        &lt;/folder          
      &lt;/folder>                
   &lt;/domain>    
&lt;/greenfox></programlisting>
            <para>The <code>&lt;domain></code> element represents the root folder of a <emphasis
                    role="bold">file system tree</emphasis> to be validated. The folder is
                identified by a mandatory @path attribute.</para>
            <para>A <code>&lt;folder></code> element describes a set of folders selected by a
                    <emphasis role="ital">target declaration</emphasis>. Here, the target
                declaration is a foxpath expression, given by a @foxpath attribute. Foxpath <xref
                    linkend="foxpath"/>
                <xref linkend="foxpath2"/> is an extended version of XPath 3.0 which supports file
                system navigation, node tree navigation and a mixing of file system and node tree
                navigation within a single path expression. Note that file system navigaton steps
                are connected by a backslash operator, rather than a slash, which is used for node
                tree navigation steps. The foxpath expression is evaluated in the context of a
                folder selected by the target declaration of the <emphasis role="ital"
                    >containing</emphasis>
                <code>&lt;folder></code> element (or the @path of <code>&lt;domain></code>, if there
                is no containing <code>&lt;folder></code>). Evaluation “in the context of a folder”
                means that the <emphasis role="ital">initial context item</emphasis> is the file
                path of that folder, so that relative file system path expressions are resolved in
                this context (see <xref linkend="foxpath"/> for details). For example, the
                expression</para>
            <programlisting>  .\\resources\xsd</programlisting>
            <para>resolves to the <code>xsd</code> folders contained by a <code>resources</code>
                folder found at any depth under the context folder, which here is
                <programlisting>  \tt\greenfox\resources\example-system\system-s\.</programlisting>
                Similarly, a <code>&lt;file></code> element describes the set of files selected by
                its <emphasis role="ital">target declaration</emphasis>, which is a foxpath
                expression evaluated in the context of a folder selected by the containing
                    <code>&lt;folder></code> element’s target declaration. So here we have a
                    <code>file</code> element describing all files found at the relative path
                <programlisting>  *.xsd</programlisting> evaluated in the context of any folder
                selected by
                <programlisting>  \tt\greenfox\resources\example-system\system-s\\resources\xsd</programlisting>
            </para>
            <para>A <code>&lt;folder></code> element represents a <emphasis role="bold">folder
                    shape</emphasis>, which is a set of <emphasis role="bold">constraints</emphasis>
                applying to a <emphasis role="bold">target</emphasis>. The target is a (possibly
                empty) set of folders, selected by a <emphasis role="bold">target
                    declaration</emphasis>, e.g. a foxpath expression. The constraints of a folder
                shape are declared by child elements of the shape element. Every folder in the
                target is tested against every constraint in the shape. When a folder is tested
                against a constraint, it is said to be the <emphasis role="bold">focus
                    resource</emphasis> of the constraint.</para>
            <para>Likewise, a <code>&lt;file></code> element represents a <emphasis role="bold">file
                    shape</emphasis>, defining a set of constraints applying to a target, which is a
                set of files selected by a target declaration. Folder shapes and file shapes are
                collectively called <emphasis role="bold">resource shapes</emphasis>.</para>
            <para>The expected number of folders or files belonging to the target of a shape can be
                expressed by declaring a <emphasis role="bold">constraint</emphasis>. A constraint
                has a kind (called the <emphasis role="bold">constraint component</emphasis>) and a
                set of arguments passed to the <emphasis role="bold">constraint
                    parameters</emphasis>. Every kind of constraint has a "signature", a
                characteristic set of mandatory and optional constraint parameters, defined in terms
                of name, type and cardinality. A <emphasis role="ital">constraint
                    component</emphasis> can therefore be thought of as a library function, and a
                    <emphasis role="ital">constraint declaration</emphasis> is like a function call,
                represented by elements and/or attributes. Here, we declare a
                    <code>TargetMinCount</code> constraint, represented by a @minCount attribute on
                a <code>&lt;targetSize></code> element. When a resource is validated against a
                constraint, the imaginary function consumes the constraint parameter values,
                inspects the resource and returns a validation result. If the constraint is
                violated, the validation result is a <code>&lt;gx:red></code> element which contains
                an optional message (either supplied by an attribute or constructed by the
                processor), along with a set of information items identifying the violating resource
                (@filePath), the constraint (@constraintComp and @constraintID) and its parameter
                values (@minCount). In the case of a <code>TargetMinCount</code> constraint, the
                violating resource is the folder providing the context when evaluating the target
                declaration. Example result:</para>
            <programlisting>
&lt;<emphasis role="bold">gx:red</emphasis> msg="No XSDs found"             
    filePath="C:/tt/greenfox/resources/example-system/system-s/resources/xsd"
    constraintComp="TargetMinCount" 
    constraintID="TargetSize_2-minCount" 
    resourceShapeID="xsdFileShape" 
    minCount="1" 
    valueCount="0" 
    targetFoxpath="*.xsd"/></programlisting>
            <para>In a second step we extend our schema with a folder shape whose target consists of
                    <emphasis role="ital">all testcase folders in the system</emphasis>:</para>
            <programlisting>&lt;!-- *** Testcase folder shape *** -->
&lt;<emphasis role="bold">folder</emphasis> foxpath="<emphasis role="bold">.\\test-*[input][output][config]</emphasis>" id="testcaseFolderShape">
  &lt;<emphasis role="bold">targetSize</emphasis> minCount="1" 
              minCountMsg="No testcase folders found">
  
  &lt;!-- # Check - test folder content ok? -->
  &lt;<emphasis role="bold">folderContent</emphasis> 
       closed="true"
       closedMsg="Testcase member(s) other than input/output/config, log-*.">
    &lt;memberFolders names="input, output, config"/>
    &lt;memberFile name="log-*" count="*"/>
  &lt;/folderContent>
    …
&lt;/folder></programlisting>
            <para>The target includes all folders found at any depth under the current context
                folder (<code>system-s</code>), matching the name pattern <code>test-*</code> and
                having (at least) three members <code>input</code>, <code>output</code> and
                    <code>config</code>. The <code>TargetMinCount</code> constraint checks that the
                system contains at least one such folder. The contents of these testcase folders are
                subject to several constraints defined by the <code>&lt;folderContent></code>
                element. There must be three subfolders <code>input</code>, <code>output</code> and
                    <code>config</code>, and there may be any number of <code>log-*</code> elements,
                but not any other members (<code>FolderContentClosed</code> constraint).</para>
            <para>We proceed with a file shape which targets the <code>msg-config.csv</code> file in
                the <code>config</code> folder of the test case:</para>
            <programlisting>&lt;!-- *** msg config file shape *** -->
&lt;<emphasis role="bold">file</emphasis> foxpath="<emphasis role="bold">config\msg-config.csv</emphasis>" id="msgConfigFileShape" ...>
  &lt;targetSize count="1" 
              countMsg="Config file missing"/>
  ...
&lt;/file></programlisting>
            <para>The <code>TargetCount</code> constraint makes this file mandatory, but we want to
                be more specific: to constrain the <emphasis role="ital">file contents</emphasis>.
                The file must be a CSV file, and the third column (which according to the header row
                is called <code>returnCode</code>) must contain a value which is "OK" or "NOFIND" or
                matches the pattern "ERROR_*". We add attributes to the <code>&lt;file></code>
                element which specify how to <emphasis role="bold">parse the CSV file into an XML
                    representation</emphasis> (@mediatype, @csv.separator, @csv.header). As with
                other non-XML mediatypes (e.g. JSON or HTML), an XML view enables us to leverage
                XPath and <emphasis role="ital">express</emphasis> a selection of content items,
                preparing the data material for fine-grained validation. </para>
            <para>We add to the file shape an <code>&lt;xpath></code> element which describes a
                    <emphasis role="ital">selection</emphasis> of content items and defines a
                    <emphasis role="ital">constrait</emphasis> which these items must satisfy
                (expressed by the <code>&lt;in></code> child element): </para>
            <programlisting>&lt;!-- *** msg config file shape *** -->
&lt;<emphasis role="bold">file</emphasis> foxpath="config\msg-config.csv" id="msgConfigFileShape" 
      <emphasis role="bold">mediatype</emphasis>="csv" <emphasis role="bold">csv.separator</emphasis>="," <emphasis role="bold">csv.withHeader</emphasis>="yes">
  ...
  &lt;!-- # Check - configured return codes ok? -->
  &lt;<emphasis role="bold">xpath</emphasis> expr="<emphasis role="bold">//returnCode</emphasis>"
         inMsg="Config file contains unknown return code">
    &lt;<emphasis role="bold">in</emphasis>>
      &lt;eq>OK&lt;/eq>
      &lt;eq>NOFIND&lt;/eq>
      &lt;like>ERROR_*&lt;/like>
    &lt;/in>                                
  &lt;/xpath>                    
&lt;/file></programlisting>
            <para>The item selection is defined by an XPath expression (provided by @expr), and an
                    <code>XPathValueIn</code> constraint is specified by the <code>&lt;in></code>
                child element: an item must either be equal to one of the strings “OK” or “NOFIND”,
                or it must match the glob pattern “ERROR_*”. </para>
            <para>It is important to understand that the XPath expression is evaluated in the
                context of the <emphasis role="bold">document node</emphasis> of the document
                obtained by parsing the file. Here comes an example of a conformant message
                definition file:</para>
            <programlisting><![CDATA[request,response,returnCode
getFooRQ1.xml,getFooRS1.xml,OK
getFooRQ2.xml,getFooRS2.xml,NOFIND
getFooRQ3.xml,getFooRS3.xml,ERROR_SYSTEM]]></programlisting>
            <para>while this example violates the <code>XPathValueIn</code> constraint:</para>
            <programlisting><![CDATA[request,response,returnCode
getFooRQ1.xml,getFooRS1.xml,OK
getFooRQ2.xml,getFooRS2.xml,NOFIND
getFooRQ3.xml,getFooRS3.xml,ERROR-SYSTEM]]></programlisting>
            <para>The second example would produce the following validation result, identify
                resource and constraint, describing the constraint and exposing the offending
                value:</para>
            <programlisting>&lt;<emphasis role="bold">gx:red</emphasis> msg="Config file contains unknown return code"             
    filePath="C:/tt/greenfox/resources/example-system/system-s/resources/xsd"
    constraintComp="ExprValueIn" 
    constraintID="xpath_1-in" 
    valueShapeID="xpath_1" 
    exprLang="xpath"
    expr="//returnCode">
    <emphasis role="bold">&lt;gx:value></emphasis>ERROR-SYSTEM&lt;/gx:value>
&lt;/red></programlisting>
            <para>According to the conceptual framework of greenfox, the <code>&lt;xpath></code>
                element does not, as one might expect, represent a constraint, but a <emphasis
                    role="bold">value shape</emphasis>. A value shape is a container combining a
                single <emphasis role="bold">value mapper</emphasis> with a set of constraints: the
                value mapper maps the focus resource to a value - called a <emphasis role="bold"
                    >resource value</emphasis> - which is validated against each one of the
                constraints. Greenfox supports two kinds of value mapper – XPath expression and
                foxpath expression, and accordingly there are two variants of a value shape –
                    <emphasis role="bold">XPath value shape</emphasis> (represented by an
                    <code>&lt;xpath></code> element) and <emphasis role="bold">Foxpath value
                    shape</emphasis> (<code>&lt;foxpath></code>). See <xref
                    linkend="schema-building-blocks"/> for more information about value
                shapes.</para>
            <para>Now we are going to check <emphasis role="ital">request message files</emphasis>:
                for each such file, there must be a response file in the <code>output</code> folder,
                with a name derived from the request file name (replacing the last occurrence of
                substring “RQ” with “RS”). This is a constraint which does not depend on file
                contents, but on file system contents found “around” the focus resource. A check
                requires <emphasis role="bold">navigation of the file system</emphasis>, rather than
                file contents. We solve the problem with a Foxpath value shape:</para>
            <programlisting>&lt;!-- *** Request file shape *** -->
&lt;<emphasis role="bold">file</emphasis> foxpath="<emphasis role="bold">input\(*.xml, *.json)</emphasis>" id="requestFileShape">
  ...
  &lt;!-- # Check - request with response ? -->
  &lt;<emphasis role="bold">foxpath</emphasis> 
      <emphasis role="bold">expr</emphasis>="..\..\output\*\file-name(.)"
      <emphasis role="bold">containsXPath</emphasis>=
           "$fileName ! replace(., '(.*)RQ(.*)$', '$1RS$2')"
      containsXPathMsg="Request without response"
  ...
&lt;file></programlisting>
            <para>A Foxpath value shape combines a foxpath expression (@expr) with a set of
                constraints. The expression maps the focus resource to a resource value, which is
                validated against all constraints. Here we have an expression which maps the focus
                resource to a list of file names found in the <code>output</code> folder. A single
                constraint, represented by the @containsXPath attribute, requires the foxpath
                expression value to contain the value of an XPath expression, which maps the request
                file name to the response file name. The constraint is satisfied if and only if the
                response file is present in the <code>output</code> folder.</para>
            <para>As with XPath value shapes, it is important to be aware of the evaluation context.
                We have already seen that in an XPath value shape the initial context item is the
                    <emphasis role="ital">document node</emphasis> obtained by parsing the text of
                the focus resource into an XML representation. In a Foxpath value shape the initial
                context item is the <emphasis role="ital">file path</emphasis> of the focus
                resource, which here is the file path of a request file. The foxpath expression
                starts with two steps along the parent axis (<code>..\..</code>) which lead to the
                enclosing testcase folder, from which navigation to the response files and their
                mapping to file names is trivial: </para>
            <programlisting><![CDATA[  ..\..\output\*\file-name(.)]]></programlisting>
            <para>A Foxpath value shape does not require the focus resource to be parsed into a
                document, as the context is a file path, rather than a document node. Therefore, a
                Foxpath value shape can also be used in a folder shape. We use this possibility in
                order to constrain the <code>codelists</code> folder to contain non-empty
                    <code>&lt;codelist></code> elements with unique names:</para>
            <programlisting><!-- *** Codelist folder shape -->
&lt;<emphasis role="bold">folder</emphasis> foxpath="<emphasis role="bold">.\\resources\codelists</emphasis>" id="codelistFolderShape">
    ...
    &lt;!-- # Check - folder contains codelists? -->
    &lt;<emphasis role="bold">foxpath</emphasis> expr="<emphasis role="bold">.\*.xml//codelist[entry]/@name</emphasis>"  
             <emphasis role="bold">minCount</emphasis>="1"
             minCoutMsg="Codelist folder without codelists"
             <emphasis role="bold">itemsUnique</emphasis>="true"
             itemsUniqueMsg="Codelist names must be unique"/>
    ...
&lt;/folder></programlisting>
            <para>Note the unified view of file system contents offered by the foxpath language: a
                single expression starts with file system navigation, visiting all <code>.xml</code>
                files in the current folder, enters their XML content and selects the @name
                attributes of non-empty <code>codelist</code> elements, which may occur at any depth
                inside the content trees.</para>
            <para>Now we turn to the <emphasis role="ital">response message files</emphasis>. They
                must be “fresh”, that is, have a timestamp of last modification which is after a
                limit timestamp provided by a call parameter of the system validation. This is
                accomplised by a <code>LastModified</code> constraint, which references the
                parameter value. Besides, response files must not be empty (<code>FileSize</code>
                constraint):</para>
            <programlisting>&lt;!-- *** Response file shape *** -->                
&lt;<emphasis role="bold">file</emphasis> foxpath="<emphasis role="bold">output\(*.xml, *.json)</emphasis>" mediatype="xml-or-json">
    ...                    
    &lt;!-- # Check - response fresh? -->
    &lt;<emphasis role="bold">lastModified</emphasis> ge="${lastModified}"
                  geMsg="Stale output file"

    &lt;!-- # Check - response non-empty? -->
    &lt;<emphasis role="bold">fileSize</emphasis> gt="0" 
              gtMsg="Empty output file"
    ...
&lt;/file></programlisting>
            <para>The placeholder <code>${lastModified}</code> is substituted with the value passed
                to the greenfox processor as input parameter and declared in the schema as a
                    <emphasis role="ital">context parameter</emphasis>:</para>
            <programlisting>&lt;<emphasis role="bold">greenfox</emphasis> ... >
  &lt;!-- *** External context *** -->
  &lt;<emphasis role="bold">context</emphasis>>
    &lt;<emphasis role="bold">field</emphasis> name="lastModified"
  &lt;/context>    
  ...
&lt;/greenfox></programlisting>
            <para>We have several expecations related to the contents of response files. If the
                response is an XML document (rather than JSON), it must be valid against some XSD
                found in the XSD folder. XSD validation is triggered by an <code>XSDValid</code>
                constraint, with a foxpath expression locating the XSD(s) to be used:</para>
            <programlisting>&lt;!-- *** Response file shape *** -->                
&lt;<emphasis role="bold">file</emphasis> foxpath="output\(*.xml, *.json)" mediatype="<emphasis role="bold">xml-or-json</emphasis>">
    ...
    &lt;!-- # Check - schema valid? (only if XML) -->
    &lt;<emphasis role="bold">ifMediatype</emphasis> eq="xml">
        &lt;<emphasis role="bold">xsdValid</emphasis> msg="Response msg not XSD valid" 
                  xsdFoxpath="<emphasis role="bold">$domain\resources\xsd\\*.xsd</emphasis>"/>  
    &lt;/ifMediatype>
    ...
&lt;/file></programlisting>
            <para>It is not necessary to specify an individual XSD – the greenfox processor inspects
                all XSDs matching the expression and selects for each file to be validated the
                appropriate XSD. This is achieved by comparing name and namespace of the root
                element with local name and target namespace of all element declarations found in
                the XSDs selected by the foxpath expression. If not exactly one element declaration
                is found, an error is reported, otherwise XSD validation is performed. Note the
                variable reference <code>$domain</code>, which can be referenced in any XPath or
                foxpath expression and which provides the file path of the domain folder. </para>
            <para>The next condition to be checked is that certain values from the response
                (selected by XPath <code>//*:fooValue</code>) are found in a particular codelist.
                Here we use an XPath value shape with an <code>ExprValueInFoxpath</code> constraint,
                represented by the @inFoxpath attribute:</para>
            <programlisting>&lt;!-- *** Response file shape *** -->                
&lt;<emphasis role="bold">file</emphasis> foxpath="output\(*.xml, *.json)" mediatype="<emphasis role="bold">xml-or-json</emphasis>">
    ...
   &lt;!-- # Check - known article number? -->
   &lt;<emphasis role="bold">xpath</emphasis> expr="//*:fooValue"
          <emphasis role="bold">inFoxpath</emphasis>="$domain\\codelists\*.xml
                     /codelist[@name eq 'foo-article']/entry/@code"
          inFoxpathMsg="Unknown foo article number"/>
&lt;/file></programlisting>
            <para>As always with an XPath value shape, the XPath expression (@expr) selects the
                content items to be checked. The <code>ExprValueInFoxpath</code> constraint works as
                follows: it evaluates the foxpath expression provided by constraint parameter
                @inFoxpath and checks that every item of the value to be checked also occurs in the
                value of the foxpath expression. As here the foxpath expression returns all entries
                of the appropriate codelist, the constraint is satisfied if and only if every
                    <code>&lt;fooValue></code> element in the response contains a string found in
                the codelist.</para>
            <para>Note that this value shape works properly for both, XML and JSON responses. Due to
                the @mediatype annotation on the file shape, which is set to
                    <code>xml-or-json</code>, the greenfox processor first attempts to parse the
                file as an XML document. If this does not succeed, it attempts to parse the file as
                a JSON document and transform it into an equivalent XML representation. In either
                case, the XPath expression is evaluated in the context of the document node of the
                resulting XDM node tree. In such cases one has to make sure, of course, that the
                XPath expression can be used in both structures, original XML and XML capturing the
                JSON content, which is the case in our example.</para>
            <para>As a last constraint, we want to check the return code of a response. The expected
                value can be retrieved from the message config file, a CSV file in the
                    <code>config</code> folder: it is the value found in the third column (named
                    <code>returnCode</code>) of the row in which the second column (named
                    <code>response</code>) contains the file name of the response file. We use a
                Foxpath value shape with an expression fetching the expected return value from the
                CSV file. This is accomplished by a mixed navigation, starting with file system
                navigation leading to the CSV file, then drilling down into the file and fetching
                the item of interest. The value against which to compare is retrieved by a trivial
                XPath expression (@eqXPath):</para>
            <programlisting>&lt;!-- *** Response file shape *** -->                
&lt;<emphasis role="bold">file</emphasis> foxpath="<emphasis role="bold">output\(*.xml, *.json)</emphasis>" mediatype="xml-or-json">
    ...
    &lt;!-- # Check - return code expected? -->
    &lt;<emphasis role="bold">foxpath</emphasis> expr="..\..\config\msg-config.csv\csv-doc(., ',', 'yes')
                   //record[response eq $fileName]/returnCode"
             <emphasis role="bold">eqXPath</emphasis>="//*:returnCode"
             eqXPathMsg="Return code not the configured value"                   
&lt;/file></programlisting>
            <para>The complete schema is shown in <xref linkend="appendix-greenfox-schema-s1"/>. To
                summarize, we have developed a schema which constrains the presence and contents of
                folders, the presence and contents of files, and relationships between contents of
                different files, in some cases belonging to different mediatypes. The development of
                the schema demanded familiarity with XPath, but no programming skills beyond that.
            </para>
        </section>
    </section>
    <section>
        <title>Basic principles</title>
        <para>The "Getting started" section has familiarized you with the basic building blocks and
            principles of greenfox schemas. They can be summarized as follows.</para>
        <itemizedlist spacing="compact">
            <listitem>
                <para>A file system is thought of as containing two kinds of resources, <emphasis
                        role="bold">folders</emphasis> and <emphasis role="bold"
                    >files</emphasis>.</para>
            </listitem>
            <listitem>
                <para>Resources are validated against <emphasis role="bold">resource
                        shapes.</emphasis></para>
            </listitem>
            <listitem>
                <para>There are two kinds of resource shapes – <emphasis role="bold">folder
                        shapes</emphasis> and <emphasis role="bold">file shapes.</emphasis></para>
            </listitem>
            <listitem>
                <para>A resource shape is a set of <emphasis role="bold">constraints</emphasis>
                    which apply to each resource validated against the shape.</para>
            </listitem>

            <listitem>
                <para>A resource which is validated against a shape is called a <emphasis
                        role="bold">focus resource</emphasis>.</para>
            </listitem>
            <listitem>
                <para>A resource shape may have a <emphasis role="bold">target
                        declaration</emphasis> which selects a set of focus resources.</para>
            </listitem>
            <listitem>
                <para>A target declaration of a resource shape can be a file path or a foxpath
                    expression.</para>
            </listitem>
            <listitem>
                <para>A target declaration of a resource shape is resolved in the context of all
                    resources obtained from the target declaration of the containing resource
                    shape.</para>
            </listitem>
            <listitem>
                <para>Every violation of a constraint produces a <emphasis role="bold">validation
                        result</emphasis> describing the violation and identifying the focus
                    resource and the constraint.</para>
            </listitem>
            <listitem>
                <para>Constraints can apply to <emphasis role="bold">resource properties</emphasis>
                    like the last modification time or the file size.</para>
            </listitem>
            <listitem>
                <para>Constraints can apply to a <emphasis role="bold">resource value</emphasis>,
                    which is a value to which the resource is mapped by an expression, or by a chain
                    of expressions.</para>
            </listitem>
            <listitem>
                <para>A <emphasis role="bold">value shape</emphasis> combines an expression mapping
                    the focus resource to a resource value, or a resource value to another resource
                    value, and a set of constraints against which to validate the resource value
                    obtained.</para>
            </listitem>
            <listitem>
                <para>The expression used by a value shape may be an <emphasis role="bold">XPath
                        expression</emphasis> or a <emphasis role="bold">foxpath
                        expression</emphasis>.</para>
            </listitem>
            <listitem>
                <para>The <emphasis role="bold">foxpath context item</emphasis> used by a value
                    shape mapping a focus resource to a resource value is the file path of the focus
                    resource. The foxpath context item used by a value shape mapping a preceding
                    resource value to another resource value is a single item of the preceding
                    resource value. </para>
            </listitem>
            <listitem>
                <para>The <emphasis role="bold">XPath context item</emphasis> used by a value shape
                    mapping a focus resource to a resource value is the root of an XDM node tree
                    representing the content of the focus resource, or the file path of the focus
                    resource if an XDM node tree cannot be constructed. The XPath context item used
                    by a value shape mapping a preceding resource value to another resource value is
                    a single item of the preceding resource value.</para>
            </listitem>
            <listitem>
                <para><emphasis role="bold">XDM node tree representations</emphasis> of file
                    resources can be controlled by mediatype related attributes on a file
                    shape.</para>
            </listitem>
            <listitem>
                <para>When validating resources against resource shapes, the heterogeneity of
                    mediatypes can be hidden by a <emphasis role="bold">unified representation as
                        XDM node trees.</emphasis></para>
            </listitem>
            <listitem>
                <para>When validating resources against resource shapes, the heterogeneity of
                    navigation (within resource contents and between resources) can be hidden by a
                        <emphasis role="bold">unified navigation language.</emphasis>
                    (foxpath)</para>
            </listitem>
        </itemizedlist>

    </section>
    <section>
        <title>Information model</title>
        <para>This section describes the information model underlying the operations of
            greenfox.</para>
        <section>
            <title>Part 1: resource model</title>
            <para>A <emphasis role="bold">file system tree</emphasis> is a tree whose nodes are file
                system resources – folders and files.</para>
            <para>A <emphasis role="bold">file system resource</emphasis> has an identity, resource
                properties, derived resource properties and resource values.</para>
            <para>The <emphasis role="bold">resource identity</emphasis> of a file system resource
                can be expressed by a combination of file system identity and a file path locating
                the resource within the file system.</para>
            <para>A <emphasis role="bold">resource property</emphasis> has a name and a value which
                can be represented by an XDM value.</para>
            <para>A <emphasis role="bold">derived resource property</emphasis> is a property of a
                resource property value, or of a derived resource property value, which can be
                represented by an XDM value.</para>
            <para>A <emphasis role="bold">resource value</emphasis> is the XDM value of an
                expression evaluated in the context of a resource property, or of a derived resource
                property, or of an item from another resource value.</para>
            <section>
                <title>Folder resources</title>
                <para>The table below summarizes the <emphasis role="bold">resource
                        properties</emphasis> of a folder resource, as currently evaluated by
                    greenfox. More properties may be added in the future, e.g. representing access
                    rights.</para>
                <table xml:id="table-102">
                    <title>Resource properties of a folder resource.</title>
                    <titleabbrev xml:id="table-102-shorttitle">Folder resource
                        properties</titleabbrev>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="3*"/>
                        <colspec colname="c2" colnum="2" colwidth="4*"/>
                        <colspec colname="c3" colnum="3" colwidth="11*"/>
                        <thead>
                            <row>
                                <entry align="left">Property name</entry>
                                <entry align="left">Value type</entry>
                                <entry align="left">Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry align="left">[name]</entry>
                                <entry align="left"><code>xsd:string?</code></entry>
                                <entry align="left">The folder name; optional – the file system root
                                    folder does not have a name</entry>
                            </row>
                            <row>
                                <entry align="left">[parent]</entry>
                                <entry align="left">Folder resource</entry>
                                <entry align="left">The XDM representation of resource identity is
                                    its file path</entry>
                            </row>
                            <row>
                                <entry align="left">[children]</entry>
                                <entry align="left">Folder and file resources</entry>
                                <entry align="left">The XDM representation of resource identity is
                                    its file path</entry>
                            </row>
                            <row>
                                <entry align="left">[last-modified]</entry>
                                <entry align="left"><code>xsd:dateTime</code></entry>
                                <entry align="left">May be out of sync when comparing values of
                                    resources from different machines</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para>A folder has the following <emphasis role="bold">derived resource
                        properties</emphasis>.</para>
                <table xml:id="table-103">
                    <title>Derived resource properties of a folder resource.</title>
                    <titleabbrev xml:id="table-103-shorttitle">Derived folder resource
                        properties</titleabbrev>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="3*"/>
                        <colspec colname="c2" colnum="2" colwidth="4*"/>
                        <colspec colname="c3" colnum="3" colwidth="11*"/>
                        <thead>
                            <row>
                                <entry align="left">Property name</entry>
                                <entry align="left">Value type</entry>
                                <entry align="left">Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry align="left">[filepath]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">The names of all ancestor folders and the folder
                                    itself, separated by a slash</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para><emphasis role="bold">Resource values</emphasis> of a folder are obtained by
                    evaluating a foxpath expression in the context of [filepath]. They can also be
                    obtained by evaluating an XPath or a foxpath expression in the context of an
                    item taken from another resource value. See <xref
                        linkend="appendix-expression-chains"/> for implications of this recursive
                    definition.</para>
            </section>
            <section>
                <title>File resources</title>
                <para>A file has the following <emphasis role="bold">resource properties</emphasis>,
                    as currently evaluated by greenfox.</para>
                <table xml:id="table-104">
                    <title>Resource properties of a file resource.</title>
                    <titleabbrev xml:id="table-104-shorttitle">File resource
                        properties</titleabbrev>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="3*"/>
                        <colspec colname="c2" colnum="2" colwidth="4*"/>
                        <colspec colname="c3" colnum="3" colwidth="11*"/>
                        <thead>
                            <row>
                                <entry align="left">Property name</entry>
                                <entry align="left">Value type</entry>
                                <entry align="left">Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry align="left">[name]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">Mandatory – a file must have a name</entry>
                            </row>
                            <row>
                                <entry align="left">[parent]</entry>
                                <entry align="left">Folder resource</entry>
                                <entry align="left">The XDM representation of resource identity is
                                    its file path</entry>
                            </row>
                            <row>
                                <entry align="left">[last-modified]</entry>
                                <entry align="left"><code>xsd:dateTime</code></entry>
                                <entry align="left">May be out of sync when comparing values of
                                    resources from different machines</entry>
                            </row>
                            <row>
                                <entry align="left">[size]</entry>
                                <entry align="left"><code>xsd:integer</code></entry>
                                <entry align="left">File size, in bytes</entry>
                            </row>
                            <row>
                                <entry align="left">[sha1]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">SHA-1 hash value of file contents</entry>
                            </row>
                            <row>
                                <entry align="left">[sha256]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">SHA-256 hash value of file contents</entry>
                            </row>
                            <row>
                                <entry align="left">[md5]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">MD5 hash value of file contents</entry>
                            </row>

                            <row>
                                <entry align="left">[text]</entry>
                                <entry align="left"><code>xsd:string?</code></entry>
                                <entry align="left">The text content of the file (empty sequence if
                                    not a text file)</entry>
                            </row>
                            <row>
                                <entry align="left">[encoding]</entry>
                                <entry align="left"><code>xsd:string?</code></entry>
                                <entry align="left">The encoding of the text content of the file
                                    (empty sequence if not a text file)</entry>
                            </row>
                            <row>
                                <entry align="left">[octets]</entry>
                                <entry align="left"><code>xsd:base64-Binary</code></entry>
                                <entry align="left">The binary file content</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para>A file has the following <emphasis role="bold">derived resource
                        properties</emphasis>, as currently evaluated by greenfox.</para>
                <table xml:id="table-105">
                    <title>Derived resource properties of a file resource.</title>
                    <titleabbrev xml:id="table-105-shorttitle">Derived folder resource
                        properties</titleabbrev>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="5*"/>
                        <colspec colname="c2" colnum="2" colwidth="5*"/>
                        <colspec colname="c3" colnum="3" colwidth="11*"/>
                        <thead>
                            <row>
                                <entry align="left">Property name</entry>
                                <entry align="left">Value type</entry>
                                <entry align="left">Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry align="left">[filepath]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">The names of all ancestor folders and the folder
                                    itself, separated by a slash</entry>
                            </row>
                            <row>
                                <entry align="left">[xmldoc]</entry>
                                <entry align="left"><code>document-node()?</code></entry>
                                <entry align="left">The result of parsing [text] into an XML
                                    document</entry>
                            </row>
                            <row>
                                <entry align="left">[jsondoc-basex]</entry>
                                <entry align="left"><code>document-node()?</code></entry>
                                <entry align="left">The result of parsing [text] into a JSON
                                    document represented by a document node in accordance with the
                                    rules defined by BaseX documentation</entry>
                            </row>
                            <row>
                                <entry align="left">[jsondoc-w3c]</entry>
                                <entry align="left"><code>document-node()?</code></entry>
                                <entry align="left">The result of parsing [text] into a JSON
                                    document represented by a document node in accordance with XPath
                                    function <code>fn:json-to-xml</code></entry>
                            </row>
                            <row>
                                <entry align="left">[htmldoc]</entry>
                                <entry align="left"><code>document-node()?</code></entry>
                                <entry align="left">The result of parsing [text] into an XML
                                    document represented by a document node in accordance with the
                                    rules defined by TagSoup documentation</entry>
                            </row>
                            <row>
                                <entry align="left">[csvdoc]</entry>
                                <entry align="left"><code>document-node()?</code></entry>
                                <entry align="left">The result of parsing [text] into an XML
                                    document represented by a document node, as controlled by the
                                    CSV parsing parameter values derived from a file shape, in
                                    accordance with the rules defined by BaseX documentation
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para><emphasis role="bold">Resource values</emphasis> of a file are obtained by
                    evaluating a foxpath expression in the context of [filepath], or evaluating an
                    XPath expression in the context of a [*doc] or [*doc-*] property. They can also
                    be obtained by evaluating an XPath or a foxpath expression in the context of an
                    item taken from another resource value. See <xref
                        linkend="appendix-expression-chains"/> for implications of this recursive
                    definition.</para>
                <para>For information about CSV parsing parameters, see <xref linkend="basex"/>,
                    section <code>#wiki/CSV_Module</code>.</para>

            </section>
        </section>
        <section>
            <title>Part 2: schema model</title>
            <para>File system validation is a mapping of a file system tree and a greenfox schema to
                a set of validation results.</para>
            <para>A <emphasis role="bold">greenfox schema</emphasis> is a set of shapes.</para>
            <para>A <emphasis role="bold">shape</emphasis> is a resource shape or a value
                shape.</para>
            <para>A <emphasis role="bold">resource shape</emphasis> is a set of constraints
                applicable to a file system resource. It has an optional target declaration.</para>
            <para>A <emphasis role="bold">target declaration</emphasis> specifies the selection of a
                target.</para>
            <para>A <emphasis role="bold">target</emphasis> is a set of focus resources, or a focus
                value.</para>
            <para>A <emphasis role="bold">focus resource</emphasis> is a resource to be validated
                against a resource shape.</para>
            <para>A <emphasis role="bold">focus value</emphasis> is a resource value providing a
                context in which to evaluate value shapes (rather than in the context of a
                resource's file path or node tree representation). A focus value is typically a set
                of nodes selected from the resource's node tree representation.</para>
            <para>A resource shape is a <emphasis role="bold">folder shape</emphasis> or a <emphasis
                    role="bold">file shape</emphasis>.</para>
            <para>A <emphasis role="bold">value shape</emphasis> is a mapping of a focus resource,
                or of a resource value, to a resource value and a set of constraints which apply to
                the value.</para>
            <para>A <emphasis role="bold">constraint</emphasis> maps a resource property or a
                resource value to a validation result.</para>
            <para>A constraint is defined by a <emphasis role="bold">constraint
                    declaration</emphasis>.</para>
            <para>A constraint declaration is provided by a shape. It identifies a constraint
                component and assigns values to the constraint parameters.</para>
            <para>A <emphasis role="bold">constraint component</emphasis> is a set of constraint
                parameter definitions and a validator.</para>
            <para>A <emphasis role="bold">constraint parameter definition</emphasis> specifies a
                name, a type, a cardinality range and value semantics.</para>
            <para>A <emphasis role="bold">validator</emphasis> is a set of rules how a resource
                property or a resource value and the values of the constraint parameters are mapped
                to a validation result.</para>
            <para>A <emphasis role="bold">validation result</emphasis> describes the outcome of
                validating a resource against a constraint. It contains a boolean value signaling
                conformance, an identification of the resource and the constraint, constraint
                parameter values and optional details about the violation.</para>
        </section>
        <section>
            <title>Part 3: validation model</title>
            <para><emphasis role="bold">File system validation</emphasis> is a mapping of a
                    <emphasis role="underline">file system tree</emphasis> and a <emphasis
                    role="underline">greenfox schema</emphasis> to a set of <emphasis
                    role="underline">validation result</emphasis>s, as defined in the following
                paragraphs.</para>
            <para><emphasis role="bold">Validation of a file system tree against a greenfox
                    schema</emphasis>: Given a <emphasis role="underline">file system
                    tree</emphasis> and a <emphasis role="underline">greenfox schema</emphasis>, the
                    <emphasis role="underline">validation result</emphasis>s are the union of
                results of the validation of the <emphasis role="underline">file system
                    tree</emphasis> against all <emphasis role="underline">shape</emphasis>s in the
                    <emphasis role="underline">greenfox schema</emphasis>. </para>
            <para><emphasis role="bold">Validation of a file system tree against a shape</emphasis>:
                Given a <emphasis role="underline">file system tree</emphasis> and a <emphasis
                    role="underline">shape</emphasis> in the <emphasis role="underline">greenfox
                    schema</emphasis>, the <emphasis role="underline">validation result</emphasis>s
                are the union of the results of the validation of all <emphasis role="underline"
                    >focus resource</emphasis>s that are in the <emphasis role="underline"
                    >target</emphasis> of the <emphasis role="underline">shape</emphasis>. </para>
            <para><emphasis role="bold">Validation of a focus resource against a shape</emphasis>:
                Given a <emphasis role="underline">focus resource</emphasis> in the <emphasis
                    role="underline">file system tree</emphasis> and a <emphasis role="underline"
                    >shape</emphasis> in the <emphasis role="underline">greenfox schema</emphasis>,
                the <emphasis role="underline">validation result</emphasis>s are the union of the
                results of the validation of the <emphasis role="underline">focus
                    resource</emphasis> against all <emphasis role="underline"
                >constraint</emphasis>s declared by the <emphasis role="underline">shape</emphasis>. </para>
            <para><emphasis role="bold">Validation of a focus resource against a
                    constraint</emphasis>: Given a <emphasis role="underline">focus
                    resource</emphasis> in the <emphasis role="underline">file system
                    tree</emphasis> and a <emphasis role="underline">constraint</emphasis> of kind C
                in the <emphasis role="underline">greenfox schema</emphasis>, the <emphasis
                    role="underline">validation result</emphasis>s are defined by the <emphasis
                    role="underline">validator</emphasis> of the <emphasis role="underline"
                    >constraint component</emphasis> C. The <emphasis role="underline"
                    >validator</emphasis> typically takes as input a <emphasis role="underline"
                    >resource property</emphasis> or a <emphasis role="underline">resource
                    value</emphasis> of the <emphasis role="underline">focus resource</emphasis> and
                the arguments supplied to the <emphasis role="underline">constraint
                    parameter</emphasis>s. </para>
        </section>
    </section>
    <section xml:id="schema-building-blocks">
        <title>Schema building blocks</title>
        <para>This section summarizes the <emphasis role="bold">building blocks</emphasis> of a
            greenfox schema. Building blocks are the parts of which a schema serialized as XML is
            composed. The serialized schema should be distinguished from the logical schema, which
            is independent of a serialization and can be described as a set of logical components
            (as defined by the information model) and parameter bindings. </para>
        <para>Each building block is represented by XML elements with a particular name. There is
            not necessarily a one-to-one correspondence between building blocks and logical
            components as defined by the information model. An Import declaration, for example, is a
            building block without corresponding logical component. Constraints, on the other hand,
            are logical components which in many cases are not represented by a separate building
            block, but by attributes attached to a building block. Note also that the information
            model includes logical components built into the greenfox language and without
            representation in any given schema (e.g. validators).</para>
        <table xml:id="table-201">
            <title>The building blocks of a greenfox schema.</title>
            <titleabbrev xml:id="table-201-shorttitle">Greenfox building blocks</titleabbrev>
            <tgroup cols="3">
                <colspec colname="c1" colnum="1" colwidth="4*"/>
                <colspec colname="c2" colnum="2" colwidth="11*"/>
                <colspec colname="c3" colnum="3" colwidth="5*"/>
                <thead>
                    <row>
                        <entry align="left">Building block</entry>
                        <entry align="left">Role</entry>
                        <entry align="left">XML representation</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left">Import declaration</entry>
                        <entry align="left">Declares the import of another greenfox schema so that
                            its contents are included in the current schema</entry>
                        <entry align="left"><code>gx:import</code></entry>
                    </row>
                    <row>
                        <entry align="left">Context declaration</entry>
                        <entry align="left">Declares external schema variables, the values of which
                            can be supplied by the agent launching the validation. Each variable is
                            represented by a <code>gx:field</code> child element.</entry>
                        <entry align="left"><code>gx:context</code></entry>
                    </row>
                    <row>
                        <entry align="left">Shapes library</entry>
                        <entry align="left">A collection of shapes without target declaration, which
                            can be referenced by other shapes</entry>
                        <entry align="left"><code>gx:shapes</code></entry>
                    </row>
                    <row>
                        <entry align="left">Constraints library</entry>
                        <entry align="left">A collection of constraint declaration nodes, which can
                            be referenced by shapes</entry>
                        <entry align="left"><code>gx:constraints</code></entry>
                    </row>
                    <row>
                        <entry align="left">Constraint components library</entry>
                        <entry align="left">A collection of constraint component definitions, for
                            which constraints can be declared</entry>
                        <entry align="left"><code>gx:constraint-Components</code></entry>
                    </row>
                    <row>
                        <entry align="left">Constraint component definition</entry>
                        <entry align="left">A user-defined constraint component. It declares the
                            constraint parameters and provides a validator. Parameters are
                            represented by <code>gx:param</code> child elements, the validator by a
                                <code>gx:validatorXPath</code> or <code>gx:validatorFoxpath</code>
                            child element, or a @validatorXPath or @validatorFoxpath
                            attribute</entry>
                        <entry align="left"><code>gx:constraint-Component</code></entry>
                    </row>
                    <row>
                        <entry align="left">Domain</entry>
                        <entry align="left">A container element wrapping the shapes used for
                            validating a particular file system tree, identified by its root
                            folder</entry>
                        <entry align="left"><code>gx:domain</code></entry>
                    </row>
                    <row>
                        <entry align="left">Resource shape</entry>
                        <entry align="left">A shape applicable to a file system folder or
                            file</entry>
                        <entry align="left">
                            <para><code>gx:folder</code></para>
                            <para><code>gx:file</code></para>
                        </entry>
                    </row>
                    <row>
                        <entry align="left">Value shape</entry>
                        <entry align="left">A shape applicable to a resource value</entry>
                        <entry align="left">
                            <para><code>gx:xpath</code></para>
                            <para><code>gx:foxpath</code></para>
                        </entry>
                    </row>
                    <row>
                        <entry align="left">Focus mapper</entry>
                        <entry align="left">Maps a resource to a focus value, or the items of a
                            focus value to another focus value; contains value shapes to be applied
                            to the focus value; may contain other Focus mappers using the focus
                            value items as input</entry>
                        <entry align="left">
                            <para><code>gx:focusNode</code></para>
                        </entry>
                    </row>
                    <row>
                        <entry align="left">Base shape declaration</entry>
                        <entry align="left">References a shape so that its constraints are included
                            in the shape containing the reference</entry>
                        <entry align="left"><code>gx:baseShape</code></entry>
                    </row>
                    <row>
                        <entry align="left">Constraint declaration node</entry>
                        <entry align="left">An element representing one or several constraints
                            declared by a shape. Constraint parameters are represented by attributes
                            and/or child elements</entry>
                        <entry align="left">
                            <para><code>gx:fileSize</code></para>
                            <para><code>gx:folderContent</code></para>
                            <para><code>gx:hashCode</code></para>
                            <para><code>gx:lastModified</code></para>
                            <para><code>gx:mediaType</code></para>
                            <para><code>gx:resourceName</code></para>
                            <para><code>gx:targetSize</code></para>
                            <para><code>gx:xsdValid</code></para>
                        </entry>
                    </row>
                    <row>
                        <entry align="left">Conditional node</entry>
                        <entry align="left">A set of building blocks associated with a condition, so
                            that the building blocks are only used if the condition is
                            satisfied</entry>
                        <entry align="left"><code>gx:ifMediatype</code></entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
    </section>
    <section>
        <title>Schema language extension</title>
        <para>This section describes <emphasis role="bold">user-defined constraint
                components</emphasis>. Such components are defined within a greenfox schema by a
                <code>gx:constraintComponent</code> element, which specifies the constraint
            component name, declares the constraint parameters and provides an implementation. The
            implementation is an XPath or a foxpath expression, which accesses the parameter values
            as pre-bound variables. User-defined constraint components are used like built-in
            components: a constraint is declared by an element with attributes (or child elements)
            providing the parameter values and optional messages.</para>
        <para>As an illustrative example, consider the creation of a new constraint component
            characterized as follows.</para>
        <para><emphasis role="bold">Constraint component IRI</emphasis>: <code>ex:grep</code></para>
        <para><emphasis role="bold">Constraint parameters</emphasis>:</para>
        <informaltable xml:id="table-301">
            <tgroup cols="5">
                <colspec colname="c1" colnum="1" colwidth="5*"/>
                <colspec colname="c2" colnum="2" colwidth="10*"/>
                <colspec colname="c3" colnum="3" colwidth="10*"/>
                <colspec colname="c4" colnum="4" colwidth="10*"/>
                <colspec colname="c5" colnum="5" colwidth="10*"/>
                <thead>
                    <row>
                        <entry align="left">Name</entry>
                        <entry align="left">Type</entry>
                        <entry align="left">Meaning</entry>
                        <entry align="left">Mandatory?</entry>
                        <entry align="left">Default value</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left">regex</entry>
                        <entry align="left"><code>xsd:string</code></entry>
                        <entry align="left">A regular expression</entry>
                        <entry>+</entry>
                        <entry>-</entry>
                    </row>
                    <row>
                        <entry align="left">flags</entry>
                        <entry align="left"><code>xsd:string</code></entry>
                        <entry align="left">Evaluation flags</entry>
                        <entry>-</entry>
                        <entry>Zero-length string</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        <para><emphasis role="bold">Semantics</emphasis>:</para>
        <para>"A constraint is satisfied if the focus resource is a text file containing a line
            matching regular expression <code>$regex</code>, as controlled by the regex evaluation
            flags given by <code>$flags</code> (e.g. case-insensitively)."</para>
        <para>The <emphasis role="bold">implementation</emphasis> may be provided by the following
            element, added to the schema as a child element of
            <code>gx:constraintComponents</code>:</para>
        <programlisting>&lt;<emphasis role="bold">constraintComponent</emphasis> constraintElementName="<emphasis role="bold">ex:grep</emphasis>">
    &lt;param name="<emphasis role="bold">pattern</emphasis>" type="xs:string"/>
    &lt;param name="<emphasis role="bold">flags</emphasis>" type="xs:string?"/>
    &lt;<emphasis role="bold">validatorXPath</emphasis>>
        <emphasis role="ital">exists(unparsed-text-lines($this)[matches(., $pattern, $flags)])</emphasis>
    &lt;/validatorXPath>
&lt;/constraintComponent>
</programlisting>
        <para>The <emphasis role="ital">context item</emphasis> supplied to the validator is
            assigned by the greenfox processor according to the following rules: <itemizedlist
                spacing="compact">
                <listitem>
                    <para>If the constraint is used by a value shape: an item from the resource
                        value</para>
                </listitem>
                <listitem>
                    <para>If the constraint is used by a folder shape: the file path of the focus
                        resource</para>
                </listitem>
                <listitem>
                    <para>If the constraint is used by a file shape, the validator is an XPath
                        expression and the file can be parsed into an XDM node tree: the root node
                        of the node tree</para>
                </listitem>
                <listitem>
                    <para>Otherwise the file path of the focus resource</para>
                </listitem>
            </itemizedlist> Because of these rules, the example code uses the built-in variable
                <code>$this</code> which is always bound to the file path, rather than the context
            item (<code>.</code>) which may be the file path or a document node, dependent on the
            mediatype of the file.</para>
        <para>The constraint can be used like this:</para>
        <programlisting>&lt;file foxpath="...">
    ex:grep <emphasis role="bold">pattern</emphasis>="fbIx?" <emphasis role="bold">flags</emphasis>="i"
            msg="File does not contain string '$pattern'."
            msgOK="File contains string '$pattern'."/>
&lt;/file></programlisting>
        <para>Note the variable references in the message text, which the greenfox processor
            replaces with the actual parameter values.</para>
    </section>
    <section>
        <title>Validation results</title>
        <para>This section describes the results produced by a greenfox validation.</para>
        <section>
            <title>Validation reports and representations</title>
            <para>The primary result of a greenfox validation is an RDF graph called the <emphasis
                    role="bold">white validation report</emphasis>. This is mapped to the <emphasis
                    role="bold">red validation report</emphasis>, an RDF graph obtained by removing
                from a white report all triples not related to constraint violations. For red and
                white validation reports a <emphasis role="bold">canonical XML
                    representation</emphasis> is defined. Apart from that, there are <emphasis
                    role="bold">derived representations</emphasis>, implementation-dependent reports
                which may use any data model and mediatype.</para>
            <para>The <emphasis role="bold">white validation report</emphasis> is an RDF graph with
                exactly one instance of <code>gx:ValidationReport</code>. The instance has the
                following properties:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para><code>gx:conforms</code>, with an <code>xsd:boolean</code> value
                        indicating conformance</para>
                </listitem>
                <listitem>
                    <para><code>gx:result</code>, with one value ...</para>
                    <itemizedlist spacing="compact">
                        <listitem>
                            <para>for each constraint violation (“red and yellow values”)</para>
                        </listitem>
                        <listitem>
                            <para>for each constraint check which was successful (“green
                                values”)</para>
                        </listitem>
                        <listitem>
                            <para>for each observation, which is a result triggered by a value shape
                                in order to record a resource value not related to constraint
                                checking (“blue values”)</para>
                        </listitem>
                    </itemizedlist>
                </listitem>
            </itemizedlist>
            <para>The <emphasis role="bold">red validation report</emphasis> is an RDF graph
                obtained by removing from the white validation report all green and blue result
                values. Note that the validation report defined by SHACL <xref linkend="shacl"/>
                corresponds to the red validation report defined by greenfox.</para>
            <para>The <emphasis role="bold">canonical XML representation</emphasis> of a white or
                red validation report is an XML document with a
                    <code>&lt;gx:validationReport></code> root element. It contains for each
                    <code>gx:result</code> value from the RDF graph one child element, which is a
                    <code>&lt;gx:red></code>, <code>&lt;gx:yellow></code>,
                    <code>&lt;gx:green></code> or <code>&lt;gx:blue></code> element, according to
                the <code>gx:result/gx:severity</code> property value being
                    <code>gx:Violation</code>, <code>gx:Warning</code>, <code>gx:Pass</code> or
                    <code>gx:Observation</code>). </para>
            <para>A <emphasis role="bold">derived representation</emphasis> is any kind of data
                structure, using any mediatype, representing information content from the white or
                red validation report in an implementation-defined way.</para>
        </section>
        <section>
            <title>Validation result</title>
            <para>A <emphasis role="bold">validation result</emphasis> is a unit of information
                which describes the outcome of validating a focus resource against a constraint:
                either constraint violation (“red” or “yellow” result), or conformance (“green”
                result).</para>
            <para>A validation result is an RDF resource with several properties as described in
                    <xref linkend="validation-result-model"/>. Key features of the result model
                are:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>Every result is related to an individual file system resource (file or
                        folder)</para>
                </listitem>
                <listitem>
                    <para>Every result is related to an individual constraint (and, by implication,
                        a shape)</para>
                </listitem>
            </itemizedlist>
            <para>This allows for meaningful aggregation by resource, by constraint and by shape, as
                well as any combination of aggregated resources, constraints and shapes. Such
                aggregation may be useful, e.g. for integrating validation results into a graphical
                representation of the file system, or for analysis of impact.</para>
            <para>See <xref linkend="validation-result-model"/> for a detailed description of the
                validation result model – RDF properties, SHACL equivalent and XML
                representation.</para>
        </section>
    </section>
    <section>
        <title>Implementation</title>
        <para>An implementation of a greenfox processor is available on github <xref
                linkend="greenfox"/>. The processor is provided as a command-line tool
                (<code>greenfox.bat</code>, <code>greenfox.sh</code>). Example call:</para>
        <programlisting>greenfox "val?gfox=/projects/greenfox/example-schemas/gfox-system-s.xml,
          domain=/projects/greenfox/example-systems/system-s"</programlisting>
        <para>The implementation is written in XQuery and requires the use of the BaseX <xref
                linkend="basex"/> XQuery processor. </para>
    </section>
    <section>
        <title>Discussion</title>
        <para>Due to the rigorous framework on which it is based, the functionality of greenfox can
            be extended easily. Any number of new constraint components can be added without
            increasing the complexity of the language, as the <emphasis role="ital">usage</emphasis>
            of any constraint component follows the same pattern: select the component and assign
            the parameter values. Validation <emphasis role="ital">results</emphasis> likewise
            retain their simplicity, as their structure is immutable: a collection of result
            objects, reporting the validation of a single resource against a single constraint,
            expressed in a small and stable core vocabulary. New constraint components can be
            enhancements of the core language or extensions defined by user-defined schemas. Library
            schemas may give access to domain-specific sets of constraint components.</para>
        <para>Another aspect of extension concerns the reuse of existing constraints and shapes.
            Reuse should be facilitated by refining the syntax and semantics of parameterizing and
            extending existing components. The value gain is immediate and the purity of the
            conceptual framework is not endangered.</para>
        <para>The remainder of this discussion deals with the possibility to extend greenfox beyond
            adding new constraint components and refining techniques of component reuse. Care must
            be taken to avoid a hodgepodge of features increasing complexity and reducing
            uniformity, making further extension increasingly difficult and risky. Ideally, the
            future development of the language should be guarded by an architectural style as
            defined by Roy Fielding <xref linkend="rest"/> – a set of architectural constraints. A
            good starting point is an attempt to take an abstract and fundamental view of the
            language.</para>
        <para>Greenfox is <emphasis role="bold">tree-oriented</emphasis>, as a tree-structured
            perception of a file system is natural: a folder contains folders and files, a file
            (often) contains tree-structured information (XML, JSON, HTML, CSV, …). The
            expressiveness of greenfox can in large parts be attributed to the expressiveness of
            tree navigation languages (XPath, XQuery, foxpath), in combination with the suitability
            of the XDM model <xref linkend="xdm31"/> for turning different mediatypes into a unified
            substrate for those languages.</para>
        <para>On the other hand, greenfox is based on a rigorous conceptual framework which has been
            defined by SHACL <xref linkend="shacl"/>, a <emphasis role="bold">validation language
                for graphs</emphasis> – without any relationship to tree structures. This apparent
            contradiction is resolved by identifying the <emphasis role="ital"
                >fundamental</emphasis> concepts shared by the SHACL and greenfox languages,
            distinguishing them from derived concepts accounting for all the outward differences.
            Such fundamental concepts are: </para>
        <orderedlist spacing="compact">
            <listitem>
                <para>itemization of information</para>
            </listitem>
            <listitem>
                <para>identification of a subset of items with resources</para>
            </listitem>
            <listitem>
                <para>constraint check: resource + constraint parameters = true/false +
                    details</para>
            </listitem>
            <listitem>
                <para>itemization of validation: one resource against one constraint</para>
            </listitem>
            <listitem>
                <para>itemization of validation results: one unit per pair of resource and
                    constraint</para>
            </listitem>
            <listitem>
                <para>resource interface model: resource properties and resource values</para>
            </listitem>
            <listitem>
                <para>resource value model: a mapping of resource property or resource value to a
                    value</para>
            </listitem>
        </orderedlist>
        <para>The degree of abstraction makes it unnecessary to prescribe the data model (RDF /
            XDM), the alignment between items and resources (RDF-nodes / Files+Folders), the value
            mapping languages (SPARQL / XPath+foxpath). The conceptual foundation is equally
            well-suited for supporting an RDF or an XDM based view.</para>
        <para>This perception can give guidance for the further development of greenfox. Greenfox
            differs from other validation languages in its main goal which is a <emphasis
                role="bold">unified view on system validity</emphasis>, integrating any resources
            which can be accommodated in a file system. Greenfox is intent on hiding outward
            heterogeneity (e.g. of mediatype) behind rigorous abstractions. In this field, RDF has
                <emphasis role="ital">very much</emphasis> to offer, as it separates information
            content from its representation in a most radical way. There is no reason not to also
            consider the use of RDF nodes as resource values, or to use RDF expressions as vehicles
            of mapping and navigation. The integration of graph and tree models, the combination of
            their complementary strengths, holds considerable promise for anyone interested in
            unified views of information. In spite of its deep commitment to a tree-oriented data
            model and expression languages built upon it, the greenfox language might in due time
            integrate with graph technology in order to offer yet more comprehensive answers to
            problems of validity. </para>
    </section>


    <appendix xml:id="appendix-greenfox-schema-s1">
        <title>Greenfox schema "system S"</title>
        <para>This appendix lists the complete schema developed in <xref linkend="getting-started"
            />.</para>
        <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<greenfox greenfoxURI="http://www.greenfox.org/ns/schema-examples/system-s"
   xmlns="http://www.greenfox.org/ns/schema">

   <!-- *** External context *** -->
   <context>
      <field name="lastModified" value="2019-12-01"/>
   </context>

   <!-- *** System file tree *** -->
   <domain path="\tt\greenfox\resources\example-system\system-s" 
           name="system-s">

      <!-- *** System root folder shape *** -->
      <folder foxpath="." id="systemRootFolderShape">
      
         <!-- *** XSD folder shape *** -->
         <folder foxpath=".\\resources\xsd" id="xsdFolderShape">
            <targetSize count="1"
                        countMsg="No XSD folder found"/>
            <file foxpath="*.xsd" id="xsdFileShape">
               <targetSize minCount="1"
                           minCountMsg="No XSDs found"/>
            </file>
         </folder>

         <!-- *** Codelist folder shape *** -->
            <folder foxpath=".\\resources\codelists" 
                    id="codelistFolderShape">
               <targetSize count="1"
                           countMsg="No codelist folder found"/>

               <!-- # Check - folder contains codelists? -->
               <foxpath 
                  expr="*.xml/codelist[entry]/@name"
                  minCount="1"
                  minCountMsg="Codelist folder without codelists"
                  itemsUnique="true"
                  itemsUniqueMsg="Codelist names must be unique"/>
                  
               <file foxpath="*[is-xml(.)]" id="codelistFileShape">
                  <targetSize minCount="1"
                              minCountMsg="No codelist files found"/>
               </file>
            </folder>

            <!-- *** Testcase folder shape *** -->
            <folder foxpath=".\\test-*[input][output][config]" 
                    id="testcaseFolderShape">
               <targetSize minCount="1" 
                           minCountMsg="No testcase folders found"/>
               
               <!-- # Check - test folder content ok? -->
               <folderContent
                  closed="true"
                  closedMsg="Testcase contains member other than 
                             input, output, config, log-*.">
                  <memberFolders names="input, output, config"/>
                  <memberFile name="log-*" count="*"/>
               </folderContent>

               <!-- *** msg config shape *** -->
               <file foxpath="config\msg-config.csv" id="msgConfigFileShape"
                     mediatype="csv" csv.separator="," csv.withHeader="yes">
                  <targetSize count="1" 
                              countMsg="Config file missing"/>

                  <!-- # Check - configured return codes expected? -->
                  <xpath expr="//returnCode" 
                         inMsg="Config file contains unknown return code">
                     <in>
                        <eq>OK</eq>
                        <eq>NOFIND</eq>
                        <like>ERROR_*</like>
                     </in>
                  </xpath>
               </file>

               <!-- *** Request file shape *** -->
               <file foxpath="input\(*.xml, *.json)" 
                     id="requestFileShape">
                  <targetSize 
                     minCount="1"
                     minCountMsg="Input folder without request msgs"/>
                              
                  <!-- # Check - request with response? -->
                  <foxpath 
                     expr="..\..\output\*\file-name(.)"
                     containsXPath=
                          "$fileName ! replace(., '(.*)RQ(.*)$', '$1RS$2')"
                     containsXPathMsg="Request without response"/>
               </file>

               <!-- *** Response file shape *** -->
               <file foxpath="output\(*.xml, *.json)" 
                     id="responseFileShape"
                     mediatype="xml-or-json">
                  <targetSize 
                     minCount="1"
                     minCountMsg="Output folder without request msgs"/>

                  <!-- # Check - response fresh? -->
                  <lastModified ge="${lastModified}"
                                geMsg="Stale output file"

                  <!-- # Check - response non-empty? -->
                  <fileSize gt="0"
                            gtMsg="Empty output file"/>

                  <!-- # Check - schema valid? (only if XML) -->
                  <ifMediatype eq="xml">
                     <xsdValid xsdFoxpath="$domain\resources\xsd\\*.xsd"
                               msg="Response msg not XSD valid"/>
                                  
                  </ifMediatype>

                  <!-- # Check - known article number? -->
                  <xpath 
                     expr="//*:fooValue"
                     inFoxpath="$domain\\codelists\*.xml
                                /codelist[@name eq 'foo-article']/entry/@code"
                     inFoxpathMsg="Unknown foo article number" 
                     id="articleNumberValueShape"/>

                  <!-- # Check - return code ok? -->
                  <foxpath 
                     expr="..\..\config\msg-config.csv\csv-doc(., ',', 'yes')
                           //record[response eq $fileName]/returnCode"
                     eqXPath="//*:returnCode"                                   
                     eqXPathMsg="Return code not the configured value"/>                                   
    
                </file>
            </folder>
        </folder>
    </domain>
</greenfox>]]></programlisting>
    </appendix>
    <appendix xml:id="appendix-alignment-greenfox-shacl">
        <title>Alignment of key concepts between greenfox and SHACL</title>
        <para>This appendix summarizes the conceptual alignment between greenfox and SHACL. The
            striking correspondence reflects our decision to use SHACL as a blueprint for the
            conceptual framework underlying the greenfox language. Greenfox can be thought of as a
            combination of SHACL’s abstract validation model with a view of the file system through
            the prism of a unified value model (XDM), supporting powerful expression languages
            (XPath/XQuery + foxpath). </para>
        <para>The alignment is described in two tables. The first table provides an aligned
            definition of the validation process as a decomposable operation as defined by greenfox
            and SHACL. The second table is an aligned enumeration of some building blocks of the
            conceptual framework underlying greenfox and SHACL. </para>
        <table xml:id="appendix-a2-alignment-table-1">
            <title>Greenfox/SHACL alignment, part 1: validation model</title>
            <titleabbrev xml:id="appendix-a2-alignment-table-1-shorttitle">Alignment 1</titleabbrev>
            <tgroup cols="2">
                <colspec colname="c1" colnum="1" colwidth="4*"/>
                <colspec colname="c2" colnum="2" colwidth="4*"/>
                <thead>
                    <row>
                        <entry align="left">Greenfox operation</entry>
                        <entry align="left">SHACL operaration</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left">Validation of a file system against a greenfox schema </entry>
                        <entry align="left">Validation of a data graph against a shapes graph
                        </entry>
                    </row>
                    <row>
                        <entry align="left">= Union of the results of the validation of the file
                            system against all shapes</entry>
                        <entry align="left">= Union of the results of the validation of the data
                            graph against all shapes</entry>
                    </row>
                    <row>
                        <entry align="left">Validation of a file system against a shape</entry>
                        <entry align="left">Validation of a data graph against a shape</entry>
                    </row>
                    <row>
                        <entry align="left">= Union of the results of all focus resources in the
                            target of the shape</entry>
                        <entry align="left">= Union of the results of all focus nodes in the target
                            of the shape</entry>
                    </row>
                    <row>
                        <entry align="left">Validation of a focus resource against a shape = Union
                            of the results of the validation of the focus resource against all
                            constraints declared by the shape </entry>
                        <entry align="left">Validation of a focus node against a shape = Union of
                            the results of the validation of the focus node against all constraints
                            declared by the shape</entry>
                    </row>
                    <row>
                        <entry align="left">Validation of a focus resource against a constraint =
                            function(constraint parameters, focus resource, resource values) </entry>
                        <entry align="left">Validation of a focus node against a constraint =
                            function(constraint parameters, focus node, property values) </entry>
                    </row>
                    <row>
                        <entry align="left">Resource values = XPath|foxpath, applied to a
                            resource</entry>
                        <entry align="left">Property values = SPARQL property path, applied to a
                            node</entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
        <table xml:id="appendix-a2-alignment-table-2">
            <title>Greenfox/SHACL alignment, part 2: conceptual building blocks</title>
            <titleabbrev xml:id="appendix-a2-alignment-table-2-shorttitle">Alignment 2</titleabbrev>
            <tgroup cols="3">
                <colspec colname="c1" colnum="1" colwidth="4*"/>
                <colspec colname="c2" colnum="2" colwidth="4*"/>
                <colspec colname="c3" colnum="3" colwidth="6*"/>
                <thead>
                    <row>
                        <entry align="left">Greenfox concept</entry>
                        <entry align="left">SHACL</entry>
                        <entry align="left">Remark</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left"><para>Resource shape:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Folder shape</para>
                                </listitem>
                                <listitem>
                                    <para>File shape</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Node shape</entry>
                        <entry align="left">Common key concept: shape = set of constraints for a set
                            of resources </entry>
                    </row>
                    <row>
                        <entry align="left">Focus resource</entry>
                        <entry align="left">Focus node</entry>
                        <entry align="left">Common view: validation can be decomposed into instances
                            of validation of a single focus against a single shape </entry>
                    </row>
                    <row>
                        <entry align="left"><para>Target declaration</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Foxpath expression</para>
                                </listitem>
                                <listitem>
                                    <para>Literal file system path</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">
                            <para>Target declaration</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Class members</para>
                                </listitem>
                                <listitem>
                                    <para>Subjects of predicate IRI</para>
                                </listitem>
                                <listitem>
                                    <para>Objects of predicate IRI</para>
                                </listitem>
                                <listitem>
                                    <para>Literal IRI</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Difference: in greenfox a target declaration is
                            essentially a navigation result, in SHACL it tends to be derived from
                            class membership (ontological)</entry>
                    </row>
                    <row>
                        <entry align="left">Resource value</entry>
                        <entry align="left">Value node</entry>
                        <entry align="left">Common view: non-trivial validation requires mapping
                            resources to values</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Mapping resource to value:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>XPath expression</para>
                                </listitem>
                                <listitem>
                                    <para>Foxpath expression</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Mapping resource to property:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>SPARQL property path</para>
                                </listitem>
                            </itemizedlist></entry>
                        <entry align="left">Common view: the mapping of a resource to a value is an
                            expression</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Value shape:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>XPath shape</para>
                                </listitem>
                                <listitem>
                                    <para>Foxpath shape</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Property shape</entry>
                        <entry align="left">Common view: usefulness of an entity combining a
                                <emphasis role="ital">single</emphasis> mapping of the focus
                            resource to a value with a <emphasis role="ital">set of
                                constraints</emphasis> for that value</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Constraint declaration</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Constraint component</para>
                                </listitem>
                                <listitem>
                                    <para>Constraint parameters</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Constraint declaration</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Constraint component</para>
                                </listitem>
                                <listitem>
                                    <para>Constraint parameters</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Common view: a constraint declaration can be thought of
                            as a function call</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Constraint component</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Signature</para>
                                </listitem>
                                <listitem>
                                    <para>Mapping semantic</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Constraint component</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Signature</para>
                                </listitem>
                                <listitem>
                                    <para>Mapping semantic</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Common view: a constraint component can be thought of as
                            a library function</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Validation report</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Constraint violations</para>
                                </listitem>
                                <listitem>
                                    <para>Constraint passes</para>
                                </listitem>
                                <listitem>
                                    <para>Observations</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Validation report</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Constraint violations</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Common view: a result is an RDF resource; difference: in
                            greenfox also successful constraint checks produce results (“green
                            results”); difference: in greenfox also observations can be produced,
                            results unrelated to constraint checking (“blue results”) </entry>
                    </row>
                    <row>
                        <entry align="left"><para>Extension language:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>XPath/XQuery expression</para>
                                </listitem>
                                <listitem>
                                    <para>foxpath expression</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Extension language:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>SPARQL SELECT queries</para>
                                </listitem>
                                <listitem>
                                    <para>SPARQL ASK queries</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Common view: extension of functionality is based on an
                            expression language for mapping resources to values and values to a
                            result</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Mediatype integration:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Common data model</para>
                                </listitem>
                                <listitem>
                                    <para>Common navigation model</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">-</entry>
                        <entry align="left">Difference: in contrast to SHACL, greenfox faces a
                            heterogeneous collection of validation targets, calling for integration
                            concepts</entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
    </appendix>
    <appendix xml:id="validation-result-model">
        <title>Validation result model</title>
        <para>This appendix defines the validation result model.</para>
        <para>In the table below, the XML representation is rendered as an XPath expression to be
            evaluated in the context of the XML element representing the result, which is a
                <code>&lt;gx:red></code>, <code>&lt;gx:yellow></code>, <code>&lt;gx:green></code> or
                <code>&lt;gx:blue></code> element. Apart from the result properties shown in the
            table, individual constraint components may define additional properties.</para>
        <table xml:id="validation-result-model-table">
            <title>The validation result model – RDF properties, description, corresponding SHACL
                result property and XML representation. </title>
            <titleabbrev xml:id="validation-result-model-table-shorttitle">Validation result
                model</titleabbrev>
            <tgroup cols="4">
                <colspec colname="c1" colnum="1" colwidth="6*"/>
                <colspec colname="c2" colnum="2" colwidth="6*"/>
                <colspec colname="c3" colnum="3" colwidth="6*"/>
                <colspec colname="c4" colnum="4" colwidth="6*"/>
                <thead>
                    <row>
                        <entry align="left">RDF property</entry>
                        <entry align="left">Description</entry>
                        <entry align="left">SHACL result property</entry>
                        <entry align="left">XML representation</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left"><code>gx:severity</code></entry>
                        <entry align="left">
                            <para>The possible values:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para><code>gx:Violation</code></para>
                                </listitem>
                                <listitem>
                                    <para><code>gx:Warning</code></para>
                                </listitem>
                                <listitem>
                                    <para><code>gx:Pass</code></para>
                                </listitem>
                                <listitem>
                                    <para><code>gx:Observation</code></para>
                                </listitem>
                            </itemizedlist>
                            <para> While <code>gx:Observation</code> is a value not related to a
                                constraint check, the other ones represent constraint violations or
                                a successful check </para></entry>
                        <entry align="left"><code>sh:severity</code></entry>
                        <entry align="left">
                            <para>Local name of the result representing element:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para><code>red = gx:Violation</code></para>
                                </listitem>
                                <listitem>
                                    <para><code>yellow = gx:Warning</code></para>
                                </listitem>
                                <listitem>
                                    <para><code>green = gx:Pass</code></para>
                                </listitem>
                                <listitem>
                                    <para><code>blue = gx:Observation</code></para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:fileSystem</code></entry>
                        <entry align="left">Identifies the file system validated</entry>
                        <entry align="left">An aspect of <code>sh:focusNode</code></entry>
                        <entry align="left"><code>ancestor:: gx:validation-Report/ @fileSystemURI
                            </code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:focusResource</code></entry>
                        <entry align="left">File path of a file or folder resource</entry>
                        <entry align="left">An aspect of <code>sh:focusNode</code></entry>
                        <entry align="left"><code>@filePath</code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:focusNode</code></entry>
                        <entry align="left">XPath of a node within an XDM node tree representing the
                            contents of a file resource</entry>
                        <entry align="left"><code>sh:focusNode</code></entry>
                        <entry align="left"><code>@nodePath</code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:xpath</code></entry>
                        <entry align="left">The XPath expression of a value shape</entry>
                        <entry align="left"><code>sh:resultPath</code></entry>
                        <entry align="left"><code>@expr</code> or <code>./expr</code> +
                                <code>@exprLang= "XPath"</code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:foxpath</code></entry>
                        <entry align="left">The foxpath expression of a value shape</entry>
                        <entry align="left"><code>sh:resultPath</code></entry>
                        <entry align="left"><code>@expr</code> or <code>./expr</code> +
                                <code>@exprLang= "foxpath"</code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:value</code></entry>
                        <entry align="left">A resource value, or single item of a resource value,
                            causing a violation</entry>
                        <entry align="left"><code>gx:value</code></entry>
                        <entry align="left"><para><code>@value</code> or
                                <code>value</code></para><para>A value consisting of several items
                                is represented by a sequence of <code>value</code> child
                                elements</para></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:valueCount</code></entry>
                        <entry align="left">Number of resources in a target, or of resource value
                            items, causing a violation</entry>
                        <entry align="left">-</entry>
                        <entry align="left"><para><code>@valueCount</code></para></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:sourceShape</code></entry>
                        <entry align="left">The value shape or resource shape defining the
                            constraint; the value is the @id value on the shape element in the
                            schema if present, or a value assigned by the greenfox processor
                            otherwise </entry>
                        <entry align="left"><code>gx:sourceShape</code></entry>
                        <entry align="left"><code>@resourceShapeID</code>, or
                                <code>@valueShapeID</code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:constraint-Component</code></entry>
                        <entry align="left">Identifies the kind of constraint</entry>
                        <entry align="left"><code>sh:constraint-Component</code></entry>
                        <entry align="left"><code>@constraintComp</code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:message</code></entry>
                        <entry align="left">A message communicating details to humans; the value is
                            the <code>@msg</code> or <code>@...Msg</code> attribute or
                                <code>&lt;msg></code> or <code>&lt;...Msg></code> child element
                            value on the shape or constraint element in the schema, or a value
                            assigned by the greenfox processor. In the above, … is a prefix
                            identifying the constraint to which the message relates. Examples:
                                <code>@minCountMsg</code>, <code>@exprValueEqMsg</code>. </entry>
                        <entry align="left"><code>sh:message</code></entry>
                        <entry align="left"><para><code>@msg</code> or <code>msg</code> +
                                    <code>msg/@xml:lang</code></para><para>A message with a language
                                tag is represented by a child element with language
                                attribute.</para></entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

    </appendix>
    <appendix xml:id="appendix-expression-chains">
        <title>Note on the generation of resource values by expression chains</title>
        <para> The recursive definition of <emphasis role="ital">resource values</emphasis> allows
            the construction of resource values through <emphasis role="bold">chains of
                expressions</emphasis>. When a chain is used, each combination of items from all
            expressions except the last one is mapped to a distinct resource value, which itself may
            have zero, one or more items. As an example, consider a first expression mapping a
            folder to a sequence of files, a second expression mapping each file to all
                <code>&lt;row></code> elements found in its node tree representation, and a final
            expression mapping each <code>&lt;row></code> element to its <code>&lt;col></code> child
            elements. This chain generates one resource value for each combination of file and row,
            consisting of zero, one or more <code>&lt;col></code> elements. These values are
            resource values of the folder to which the expression chain was applied.</para>

    </appendix>
    <bibliography>
        <biblioentry xml:id="basex">
            <abbrev>1</abbrev>
            <title>BaseX</title>
            <date>2020</date>
            <publisher>
                <publishername>BaseX GmbH</publishername>
            </publisher>
            <biblioid class="uri">http:// basex.org</biblioid>
        </biblioentry>
        <biblioentry xml:id="rest">
            <abbrev>2</abbrev>
            <title>Architectural Styles and the Design of Network-based Software
                Architectures.</title>
            <date>2000</date>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Roy</firstname>
                        <firstname>Thomas</firstname>
                        <surname>Fielding</surname>
                    </personname>
                </author>
            </authorgroup>
            <biblioid class="uri"
                >https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</biblioid>
        </biblioentry>

        <biblioentry xml:id="foxpath">
            <abbrev>3</abbrev>
            <title>FOXpath - an expression language for selecting files and folders.</title>
            <date>2016</date>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <biblioid class="uri">http://www.balisage.net/Proceedings/vol17/html/
                Rennau01/BalisageVol17-Rennau01.html</biblioid>
        </biblioentry>
        <biblioentry xml:id="foxpath2">
            <abbrev>4</abbrev>
            <title>FOXpath navigation of physical, virtual and literal file systems.</title>
            <date>2016</date>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <biblioid class="uri"
                >https://archive.xmlprague.cz/2017/files/xmlprague-2017-proceedings.pdf</biblioid>
        </biblioentry>
        <biblioentry xml:id="foxpath3">
            <abbrev>5</abbrev>
            <title>foxpath - an extended version of XPath 3.0 supporting file system
                navigation.</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2017</date>
            <biblioid class="uri">https://github.com/hrennau/shax</biblioid>
        </biblioentry>
        <biblioentry xml:id="greenfox">
            <abbrev>6</abbrev>
            <title>Greenfox - a schema language for validating file system contents and, by
                implication, real-world systems.</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2020</date>
            <biblioid class="uri">https://github.com/hrennau/greenfox</biblioid>
        </biblioentry>
        <biblioentry xml:id="shacl">
            <abbrev>7</abbrev>
            <title>Shapes Constraint Language (SHACL)</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/shacl/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xdm31">
            <abbrev>8</abbrev>
            <title>XQuery and XPath Data Model 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-datamodel-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xpath31">
            <abbrev>9</abbrev>
            <title>XML Path Language (XPath) 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xpathfunctions31">
            <abbrev>10</abbrev>
            <title>XPath and XQuery Functions and Operators 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-functions-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xquery31">
            <abbrev>11</abbrev>
            <title>XQuery 3.1: An XML Query Language</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xquery-31/</biblioid>
        </biblioentry>
    </bibliography>
</article>
