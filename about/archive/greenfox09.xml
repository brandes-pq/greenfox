<?xml-model href='http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng' schematypens='http://relaxng.org/ns/structure/1.0'?><?xml-model href='http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng' type='application/xml' schematypens='http://purl.oclc.org/dsdl/schematron'?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0">
    <info>
        <title>Greenfox – a schema language for validating file systems</title>
        <author>
            <personname>Hans-Juergen Rennau</personname>
            <email>hans-juergen.rennau@parsqube.de</email>
            <personblurb>
                <para/>
            </personblurb>
            <affiliation>
                <orgname>parsQube GmbH</orgname>
            </affiliation>
        </author>
        <keywordset>
            <keyword>Validation, SHACL, XSD, JSON Schema, Schematron</keyword>
        </keywordset>
        <abstract>
            <para>Greenfox is a schema language for validating file systems. One key feature is an
                abstract validation model inspired by the SHACL language. Another key feature is a
                view of the file system which is based on the XDM data model and thus supports a set
                of powerful expression languages (XPath, foxpath, XQuery). Using their expressions
                as basic building blocks, the schema language unifies navigation within and between
                resources and access to the structured contents of files with different mediatypes.
            </para>
        </abstract>
    </info>
    <section xml:id="introduction">
        <title>Introduction</title>
        <para>How to validate data against expectations? Major options are visual inspection,
            programatic checking and validation against a schema document (e.g. XSD, RelaxNG,
            Schematron, JSON Schema) or a schema graph (e.g. SHACL). Schema validation is in many
            scenarios the superior approach, as it is automated and declarative. But there are also
            limitations worth considering when thinking about validation in general. </para>
        <para>First, schema languages describe instances of a particular format or mediatype only
            (e.g. XML, JSON, RDF), whereas typical projects involve a mixture of mediatypes.
            Therefore schema validation tends to describe the state of resources which are pieces
            from a jigsaw puzzle, and the question arises how to integrate the results into a
            coherent whole. </para>
        <para>Second, several schema languages of key importance are grammar based and therefore do
            not support “incremental validation” – starting with a minimum of constraints, and
            adding more along the way. We cannot use XSD, RelaxNG or JSON Schema in order to express
            some very specific key expectation, without saying many things about the document as a
            whole, which may be a task requiring disproportional effort. Rule based schema languages
            (like Schematron) do support incremental validation, but they are inappropriate for
            comprehensive validation as accomplished by grammar based languages.</para>
        <para>As a consequence, schema validation enables isolated acts of resource validation, but
            it cannot accomplish the integration of validation results. Put differently, schema
            validation may contribute to, but cannot accomplish, system validation. The situation
            might change in an interesting way if we had a schema language for validating <emphasis
                role="ital">file system contents</emphasis> – arbitrary trees of files and folders.
            This simple abstraction suffices to accommodate any software project, and it can
            accommodate system representations of very large complexity. </para>
        <para>This document describes an early version of <emphasis role="bold">greenfox</emphasis>,
            a schema language for validating file system contents. By implication, it can also be
            viewed as a schema language for the validation of <emphasis role="ital"
                >systems</emphasis>. Such a claim presupposes that a meaningful reflection of system
            properties, state and behaviour can be represented by a collection of data (log data,
            measurement results, test results, configurations, …) distributed over a set of files
            arranged in a tree of folders. It might then sometimes be possible to translate
            meaningful definitions of system validity into constraints on file system contents. At
            other times it may not be possible, for example if the assessment of validity requires a
            tracking of realtime data.</para>
        <para>The notion of system validation implies that extensibility must be a key feature of
            the language. The language must not only offer a scope of expressiveness which is
            immediately useful. It must at the same time serve as a <emphasis role="ital"
                >framework</emphasis>, within which current capabilities, future extensions and
            third-party contributions are uniform parts of a coherent whole. The approach we took is
            a generalization of the key concepts underlying SHACL [x], a validation language for RDF
            data. These concepts serve as the building blocks of a simple metamodel of validation,
            which offers guidance for extension work.</para>
        <para>Validation relies on the key operations of navigation and comparison. File system
            validation must accomplish them in the face of divers mediatypes and the necessity to
            combine navigation within as well as between resources. In response to this challenge,
            greenfox is based on a <emphasis role="ital">unified data model</emphasis> (XDM) [x] and
            a <emphasis role="ital">unified navigation model</emphasis> (foxpath/XPath) [x] [x] [x]
            [x] built upon it. </para>
        <para>Validation produces results, and the more complex the system, the more important it
            may become to produce results in a form which combines maximum precision with optimal
            conditions for integration with other resources. This goal is best served by a <emphasis
                role="ital">vocabulary</emphasis> for expressing validation results and schema
            contents in a way which does not require any context for being understood. We choose an
            RDF based definition of validation schema and validation results, combined with a
            bidirectional mapping between RDF and more intuitive representations, XML and JSON. For
            practical purposes, we assume the XML representation to be the form most frequently
            used.</para>
        <para>Before providing a more detailed overview of the greenfox language, a detailed example
            should give a first impression of how the language can be used.</para>
    </section>
    <section xml:id="getting-started">
        <title>Getting started with greenfox</title>
        <para>This section illustrates the development of a greenfox schema designed for validating
            a file system tree against a set of expections. Such a validation can also be viewed as
            validation of the system “behind” the file system tree, represented by its
            contents.</para>
        <section>
            <title>The system – system S</title>
            <para>Consider <emphasis role="bold">system S</emphasis> – an imaginary system which is
                a collection of web services. We are going to validate a <emphasis role="ital">file
                    system representation</emphasis> which is essentially a set of test results,
                accompanied by resources supporting validation (XSDs, codelists and data about
                expected response messages). The following listing shows a file system tree which is
                a representation of system S, as observed at a certain point in time:</para>
            <programlisting><![CDATA[
system-s
. resources
. . codelists
. . . codelist-foo-article.xml
. . xsd
. . . schema-foo-article.xsd
. testcases
. . test-t1
. . . config
. . . . msg-config.xml
. . . input
. . . . getFooRQ*.xml
. . . output
. . . . getFooRS*.xml
. . +test-t2   (contents: see test-t1)
. . usecases
. . . usecase-u1
. . . . usecase-u1a
. . . . . +test-t3   (contents: see test-t1)]]></programlisting>
            <para>The concrete file system tree must be distinguished from the expected file system
                tree, which is described by the following rules.</para>
            <table xml:id="table-1">
                <title>Rules defining "validity" of the considered file system.</title>
                <titleabbrev xml:id="table-1-shorttitle">Validity rules</titleabbrev>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="2*"/>
                    <colspec colname="c2" colnum="2" colwidth="4*"/>
                    <colspec colname="c3" colnum="3" colwidth="11*"/>
                    <thead>
                        <row>
                            <entry align="left">File or folder</entry>
                            <entry align="left">File path</entry>
                            <entry align="left">Expectation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">resources/codelists</entry>
                            <entry align="left">Contains one or more codelist files</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">resources/codelists/*</entry>
                            <entry align="left">A codelist file; name not constrained; must be an
                                XML document containing <code>&lt;codelist></code> elements with a
                                @name attribute and <code>&lt;entry></code> children</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">resources/xsd</entry>
                            <entry align="left">Contains one or more XSDs describing services
                                messages</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">resources/xsd/*</entry>
                            <entry align="left">An XSD schema file; name not constrained</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*</entry>
                            <entry align="left">A test case folder, containing <code>input</code>,
                                    <code>xoutput</code> and <code>config</code> folders; apart from
                                these only optional <code>log-*</code> files are allowed </entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*/config</entry>
                            <entry align="left">Test case config folder, containing file
                                    <code>msg-config.csv</code></entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">.//test-*/config/msg-config.csv</entry>
                            <entry align="left">A CSV file with three columns: request file name,
                                response file name, expected return code</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*/input</entry>
                            <entry align="left">Test case input folder, containg request
                                messages</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">.//test-*/input/*</entry>
                            <entry align="left">A file representing a request message; name
                                extension <code>.xml</code> or <code>.json</code>; mediatype
                                corresponding to name extension</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*/output</entry>
                            <entry align="left">Test case output folder, containing response
                                messages</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">.//test-*/output/*</entry>
                            <entry align="left">A file representing a response message; name
                                extension <code>.xml</code> or <code>.json</code>; mediatype
                                corresponding to name extension</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>The number and location of testcase folders (<code>test-*</code>) are
                unconstrained. This means that the testcase folders may be grouped and wrapped in
                any way, although they must not be nested. So the use of a <code>testcases</code>
                folder wrapping all testcase folders - and the use of <code>usecase*</code> folders
                adding additional substructure - is allowed, but must not be expected. The placing
                of XSDs in folder <code>resources/xsd</code>, on the other hand, is obligatory, and
                likewise the placing of codelist documents in folder
                    <code>resources/codelists</code>. The names of XSD and codelist files are not
                constrained. </para>
            <para>Structural expectations include also a conditional constraint:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>For every request message, there must be a response message with a name
                        obtained by replacing in the request file name <code>RQ</code> with
                            <code>RS</code> (e.g. <code>getFooRQ.*</code> and
                            <code>getFooRS.*</code>)</para>
                </listitem>
            </itemizedlist>
            <para>Besides the structural expectations, there are also content-related expectations: </para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>For every response message in XML format, there is exactly one XSD against
                        which it can be validated</para>
                </listitem>
                <listitem>
                    <para>Every response message in XML format is valid against the appropriate
                        XSD</para>
                </listitem>
                <listitem>
                    <para>Response message items (XML elements or JSON fields) with name
                            <code>fooValue</code> must be found in the codelist with name
                            <code>foo-article</code></para>
                </listitem>
                <listitem>
                    <para>Response message return codes must be as configured by the corresponding
                        row in <code>msg-config.csv</code> (applies to XML and JSON responses
                        alike)</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Building a greenfox schema "system S"</title>
            <para>Now we create a greenfox schema which enables us to validate the file system
                against these expectations. An initial version only checks the existence of
                non-empty XSD and codelists folders:</para>
            <programlisting><![CDATA[
<greenfox greenfoxURI="http://www.greenfox.org/ns/schema-examples/system-s"
          xmlns="http://www.greenfox.org/ns/schema">
    
  <domain path="\tt\greenfox\resources\example-system\system-s" 
          name="system-s">    
        
      <!-- *** System root folder shape *** -->
      <folder foxpath="." id="systemRootFolderShape">
            
        <!-- *** XSD folder shape -->
        <folder foxpath=".\\resources\xsd" id="xsdFolderShape">
            <targetSize msg="No XSD folder found" count="1"/>
            <file foxpath="*.xsd" id="xsdFileShape">
                <targetSize msg="No XSDs found" minCount="1"/>
            </file>
        </folder>                

        <!-- *** Codelist folder shape -->
        <folder foxpath=".\\resources\codelists" id="codelistFolderShape">
            <targetSize msg="No codelist folder found" count="1"/>
            <file foxpath="*[is-xml(.)]" id="codelistFileShape">
                <targetSize msg="No codelist files found" minCount="1"/>
            </file>
        </folder          
      </folder>                
  </domain>    
</greenfox>]]></programlisting>
            <para>The <code>&lt;domain></code> element represents the root folder of a file system
                tree to be validated. The folder is identified by a mandatory @path
                attribute.</para>
            <para>A <code>&lt;folder></code> element describes a set of folders selected by a target
                declaration. Here, the target declaration is a foxpath expression, given by a
                @foxpath attribute. Foxpath [2] [3] [4] is an extended version of XPath 3.0 which
                supports file system navigation, node tree navigation and a mixing of file system
                and node tree navigation within a single path expression. Note that file system
                navigaton steps are connected by a backslash operator, rather than a slash, which is
                used for node tree navigation steps. The foxpath expression is evaluated in the
                context of a folder selected by the target declaration of the <emphasis role="ital"
                    >containing</emphasis>
                <code>&lt;folder></code> element (or <code>&lt;domain></code>, if there is no
                containing <code>&lt;folder></code>). Evaluation “in the context of a folder” means
                that the initial context item is the file path of that folder, so that relative file
                system path expressions are resolved in this context (see [3], [4] for details). For
                example, the expression</para>
            <programlisting>  .\\resources\xsd</programlisting>
            <para>resolves to the <code>xsd</code> folders contained by a <code>resources</code>
                folder found at any depth under the context folder, <code>system-s</code>.
                Similarly, a <code>&lt;file></code> element describes the set of files selected by
                its target declaration, which is a foxpath expression evaluated in the context of a
                folder selected by the parent <code>&lt;folder></code>’s target declaration. </para>
            <para>A <code>&lt;folder></code> element represents a <emphasis role="bold">folder
                    shape</emphasis>, which is a set of <emphasis role="bold">constraints</emphasis>
                applying to a <emphasis role="bold">target</emphasis>. The target is a (possibly
                empty) set of folders, selected by a <emphasis role="bold">target
                    declaration</emphasis>, e.g. a foxpath expression. The constraints of a folder
                shape are declared by child elements of the shape element.</para>
            <para>Likewise, a <code>&lt;file></code> element represents a <emphasis role="bold">file
                    shape</emphasis>, defining a set of constraints applying to a target, which is a
                set of files selected by a target declaration. Folder shapes and file shapes are
                collectively called <emphasis role="bold">resource shapes</emphasis>.</para>
            <para>The expected number of folders or files belonging to the target of a shape can be
                expressed by declaring a <emphasis role="bold">constraint</emphasis>. A constraint
                has a kind (identified by the <emphasis role="bold">constraint component
                    IRI</emphasis>) and a set of arguments passed to the <emphasis role="bold"
                    >constraint parameters</emphasis>. For every kind of constraint, a
                characteristic set of mandatory and optional constraint parameters is defined in
                terms of name, type and cardinality. In a schema document, a constraint is either
                declared by a <emphasis role="ital">constraint element</emphasis> or by <emphasis
                    role="ital">constraint attributes</emphasis> attached to an element representing
                a set of constraints or a shape. Here, we declare a <code>TargetSize</code>
                constraint, which is represented by a <code>&lt;targetSize></code> child element of
                a file or folder shape. The element has three optional attributes, @minCount,
                @maxCount and @count, representing three different constraints. A constraint can be
                thought of as a function which consumes constraint parameter values and a <emphasis
                    role="ital">resource value</emphasis>, representing the resource being
                validated; and which returns a validation result. Here, the resource value is the
                number of target resources selected, and the constraint parameter
                    <code>minCount</code> is set to the value “1”. If the constraint is violated,
                the validation result is a <code>&lt;gx:red></code> element which contains the
                message (if any) specified by @msg on the constraint element, along with a set of
                information items identifying the violating resource (@filePath), the constraint
                (@constraintComp and @constraintID) and its parameter values (@minCount). Example
                result:</para>
            <programlisting><![CDATA[
<gx:red msg="No XSDs found"             
    filePath="C:/tt/greenfox/resources/example-system/system-s/resources/xsd"
    constraintComp="targetMinCount" 
    constraintID="TargetSize_2-minCount" 
    resourceShapeID="xsdFileShape" 
    minCount="1" 
    actCount="0" 
    targetFoxpath="*.xsd"/>]]></programlisting>
            <para>In a second step we extend our schema with a folder shape whose target consists of
                    <emphasis role="ital">all testcase folders in the system</emphasis>:</para>
            <programlisting><![CDATA[<!-- *** Testcase folder shape *** -->
<folder foxpath=".\\test-*[input][output][config]" id="testcaseFolderShape">
  <targetSize msg="No testcase folders found" minCount="1"/>
  <folderContent 
       closedMsg="Testcase member(s) other than input/output/config, log-*." 
       closed="true">
    <memberFolders names="input, output, config"/>
    <memberFiles names="log-*" minCount="0" maxCount="*"/>
  </folderContent>
    …
</folder>]]></programlisting>
            <para>The target includes all folders found at any depth under the current context
                folder (<code>system-s</code>), matching the name pattern <code>test-*</code> and
                having (at least) three members <code>input</code>, <code>output</code> and
                    <code>config</code>. The <code>&lt;targetSize></code> constraint checks that the
                system contains at least one such folder. The <code>&lt;folderContent></code>
                constraint is checked for each folder in the target, thus for each testcase folder.
                The constraint disallows any additional members except for optional files matching
                    <code>log-*</code>, of which any number is allowed (note the @minCount and
                @maxCount attributes).</para>
            <para>We proceed with a file shape which targets the <code>msg-config.csv</code> file in
                the config folder of the test case:</para>
            <programlisting><![CDATA[<!-- *** msg config file shape -->
  <file foxpath="config\msg-config.csv" id="msgConfigFileShape" ...>
    <targetSize msg="Config file missing" count="1"/>
    ...
  </file>]]></programlisting>
            <para>For any testcase folder which does not contain a file
                    <code>config/msg-config.csv</code>, a violation of the <code>targetSize</code>
                constraint will be reported.</para>
            <para>We want to be more specific: to constrain the <emphasis role="ital">file
                    contents</emphasis>. The file must be a CSV file, and the third column (which
                according to the header row is called <code>returnCode</code>) must contain a value
                which is <code>OK</code> or <code>NOFIND</code> or matches the pattern
                    <code>ERROR_*</code>. We add attributes to the <code>&lt;file></code> element
                which specify how to <emphasis role="bold">parse the CSV file into an XML
                    representation</emphasis> (@mediatype, @csv.separator, @csv.header). As with
                other non-XML mediatypes (e.g. JSON or HTML), an XML view enables us to leverage
                XPath and <emphasis role="ital">express</emphasis> a selection of content items,
                preparing the data material for meaningful and complex validation. </para>
            <para>We insert into the file shape an <code>&lt;xpath></code> element which describes a
                selection of content items and defines a constrait which these items must satisfy
                (expressed by the <code>&lt;in></code> child element): </para>
            <programlisting><![CDATA[<!-- *** msg config file shape -->
<file foxpath="config\msg-config.csv" id="msgConfigFileShape" 
      mediatype="csv" csv.separator="," csv.withHeader="yes">
  ...
  <!-- *** Check - configured return codes ok? -->
  <xpath expr="//returnCode"
         inMsg="Config file contains unknown return code">
    <in>
      <eq>OK</eq>
      <eq>NOFIND</eq>
      <like>ERROR_*</like>
    </in>                                
  </xpath>                    
</file>]]></programlisting>
            <para>The item selection is defined by an XPath expression (provided by @expr), and the
                constraint is specified by the &lt;in> child element: an item must either be equal
                to one of the strings “OK” or “NOFIND”, or it must match the glob pattern “ERROR_*”. </para>
            <para>It is important to understand that the XPath expression is evaluated in the
                context of the <emphasis role="bold">document node</emphasis> of the document
                obtained by parsing the file. Here comes an example of a conformant message
                definition file:</para>
            <programlisting><![CDATA[request,response,returnCode
getFooRQ1.xml,getFooRS1.xml,OK
getFooRQ2.xml,getFooRS2.xml,NOFIND
getFooRQ3.xml,getFooRS3.xml,ERROR_SYSTEM]]></programlisting>
            <para>while this example violates the <code>xpath-in</code> constraint:</para>
            <programlisting><![CDATA[request,response,returnCode
getFooRQ1.xml,getFooRS1.xml,OK
getFooRQ2.xml,getFooRS2.xml,NOFIND
getFooRQ3.xml,getFooRS3.xml,ERROR-SYSTEM]]></programlisting>
            <para>According to the conceptual framework of greenfox, the <code>&lt;xpath></code>
                element does not, as one might expect, represent a constraint, but a <emphasis
                    role="bold">value shape</emphasis>. A value shape is a container combining a
                single <emphasis role="bold">value mapper</emphasis> with a set of constraints: the
                value mapper maps the focus resource to a value (“resource value”), which is
                validated against each one of the constraints. Greenfox supports two kinds of value
                mapper – XPath expression and foxpath expression, and accordingly there are two
                variants of a value shape – <emphasis role="bold">XPath value shape</emphasis>
                (represented by an <code>&lt;xpath></code> element) and <emphasis role="bold"
                    >Foxpath value shape</emphasis> (<code>&lt;foxpath></code>). See section “Schema
                building blocks” for detailed information about value shapes.</para>
            <para>We proceed to check <emphasis role="ital">request message files</emphasis>: for
                each such file, there must be a response file in the output folder, with a name
                derived from the request file name (replacing the last occurrence of substring “RQ”
                with “RS”). This is a constraint which does not depend on file contents, but on file
                system contents found “around” the focus resource. A check requires navigation of
                the file system, rather than file contents. We solve the problem with a Foxpath
                value shape:</para>
            <programlisting><![CDATA[<!-- *** Request file shape *** -->
<file foxpath="input\(*.xml, *.json)" id="requestFileShape">
  ...
  <!-- *** Check - request with response ? -->
  <foxpath 
      expr="..\..\output\*\file-name(.)"
      containsXPathMsg="Request without response"      
      containsXPath="$fileName ! 
                     replace(., '(.*)RQ(.*)$', '$1RS$2')"/>]]></programlisting>
            <para>A Foxpath value shape combines a foxpath expression (@expr) with a set of
                constraints. The expression maps the focus resource to a value, which is validated
                against all constraints. Here we have an expression which maps the focus resource to
                a list of file names found in the <code>output</code> folder. A single constraint,
                represented by the @containsXPath attribute, requires the expression value to
                contain the value of an XPath expression, which maps the request file name to the
                response file name. The constraint is satisfied if and only if the response file is
                present in the <code>output</code> folder.</para>
            <para>As with XPath value shapes, it is important to be aware of the evaluation context.
                We have already seen that in an XPath value shape the initial context item is the
                    <emphasis role="ital">document node</emphasis> obtained by parsing the text of
                the focus resource into an XML representation. In a Foxpath value shape the initial
                context item is the <emphasis role="ital">file path</emphasis> of the focus
                resource, which here is the file path of a request file. The foxpath expression
                starts with two steps along the parent axis (<code>..\..</code>) which lead to the
                enclosing <code>testcase</code> folder, from which navigation to the response files
                and their mapping to file names is trivial: </para>
            <programlisting><![CDATA[  ..\..\output\*\file-name(.)]]></programlisting>
            <para>A Foxpath value shape does not require the focus resource to be parsed into a
                document, as the context is a file path, rather than a document node. Therefore, a
                Foxpath value shape can also be used in a folder shape. We use this possibility in
                order to constrain the <code>codelists</code> folder to contain
                    <code>&lt;codelist></code> elements with a @name attribute and at least one
                    <code>&lt;entry></code> child:</para>
            <programlisting><![CDATA[<!-- *** Codelist folder shape -->
<folder foxpath=".\\resources\codelists" id="codelistFolderShape">
    ...
    <!-- *** Check - folder contains codelists? -->
    <foxpath expr="*.xml/codelist[entry]/@name"  
             minCoutMsg="Codelist folder without codelists"
             minCount="1"/>
    ...
</folder>]]></programlisting>
            <para>Note the aggregative view enabled by the foxpath language: we do not bother with
                individual files but perform a “mixed” navigation, starting with file system
                navigation to all *.xml files, continuing within their collected content (<code>…
                    /codelist[entry]/@name</code>), arriving at @name attributes on non-empty
                    <code>&lt;codelist></code> elements.</para>
            <para>Now we turn to the <emphasis role="ital">response message files</emphasis>. They
                must be “fresh”, that is, have a timestamp of last modification which is after a
                limit timestamp provided by a call parameter of the system validation. This is
                accomplised by a <code>lastModified</code> constraint, which references the
                parameter value. Besides, response files must not be empty (<code>fileSize</code>
                constraint):</para>
            <programlisting><![CDATA[<!-- *** Response file shape *** -->                
<file foxpath="output\(*.xml, *.json)" mediatype="xml-or-json">
    ...                    
    <!-- *** Check - response fresh? *** -->
    <lastModified ge="${lastModified}"
                  geMsg="Stale output file"/>

    <!-- *** Check - response non-empty? *** -->
    <fileSize gt="0" 
              gtMsg="Empty output file"/>
    ...
</file>]]></programlisting>
            <para>The placeholder <code>${lastModified}</code> is substituted by the value passed to
                the greenfox processor as input parameter and declared in the schema as a <emphasis
                    role="ital">context parameter</emphasis>:</para>
            <programlisting><![CDATA[<greenfox ... >
  <!-- *** External context *** -->
  <context>
    <field name="lastModified"/>
  </context>    
  ...
</greenfox>]]></programlisting>
            <para>We have several expecations related to the contents of response files. If the
                response is an XML document (rather than JSON), it must be valid valid against some
                XSD found in the XSD folder. XSD validation is triggered by an <code>xsdValid</code>
                constraint, with a foxpath expression locating the XSD(s) to be used:</para>
            <programlisting><![CDATA[<!-- *** Response file shape *** -->                
<file foxpath="output\(*.xml, *.json)" mediatype="xml-or-json">
    ...
    <!-- *** Check - schema valid? (only if XML) -->
    <ifMediatype eq="xml">
        <xsdValid msg="Response msg not XSD valid" 
                  xsdFoxpath="$domain\resources\xsd\\*.xsd"/>  
    </ifMediatype>
</file>]]></programlisting>
            <para>It is not necessary to specify an individual XSD – the greenfox processor inspects
                all XSDs matching the expression and selects for each file to be validated the
                appropriate XSD. This is achieved by comparing name and namespace of the root
                element with local name and target namespace of all element declarations found in
                the XSDs selected by the foxpath expression. If not exactly one element declaration
                is found, an error is reported, otherwise XSD validation is performed. Note the
                variable reference <code>$domain</code>, which can be referenced in any XPath or
                foxpath expression and which provides the file path of the domain folder. </para>
            <para>The next condition to be checked is that certain values from the response
                (selected by XPath <code>//*:fooValue</code>) are found in a particular codelist.
                Here we use an XPath value shape which contains an <code>ExprValueEqFoxpath</code>
                constraint, represented by the @eqFoxpath attribute:</para>
            <programlisting><![CDATA[<!-- *** Response file shape *** -->                
<file foxpath="output\(*.xml, *.json)" mediatype="xml-or-json">
    ...
   <!-- *** Check - known article number? -->
   <xpath expr="//*:fooValue"
          eqFoxpathMsg="Unknown foo article number"   
          eqFoxpath="$domain\\codelists\*.xml
                     /codelist[@name eq 'foo-article']/entry/@code"/>
 
   </xpath>
</file>]]></programlisting>
            <para>As always with an XPath value shape, the XPath expression (@expr) selects the
                content items to be checked. The <code>ExprValueEqFoxpath</code> constraint works as
                follows: it evaluates the foxpath expression provided by constraint parameter
                    <code>eqFoxpath</code> and checks that every item of the value to be checked
                also occurs in the value of the foxpath expression. As here the foxpath expression
                returns all entries of the appropriate codelist, the constraint is satisfied if and
                only if every <code>fooValue</code> element in the response contains a string found
                in the codelist.</para>
            <para>Note that this value shape works properly for both, XML and JSON responses. Due to
                the @mediatype annotation on the file shape, which is set to
                    <code>xml-or-json</code>, the greenfox processor first attempts to parse the
                file as an XML document. If this does not succeed, it attempts to parse the file as
                a JSON document and transform it into an equivalent XML representation. In either
                case, the XPath expression is evaluated in the context of the document node of the
                resulting XDM node tree. In such cases one has to make sure, of course, that the
                XPath expression can be used in both structures, original XML and XML capturing the
                JSON content, which is the case in our example.</para>
            <para>As a last constraint, we want to check the return code of a response. The expected
                value can be retrieved from the message config file, a CSV file in the
                    <code>config</code> folder: it is the value found in the third column (named
                    <code>returnCode</code>) of the row in which the second column (named
                    <code>response</code>) contains the file name of the response file. We use a
                Foxpath value shape with an expression fetching the expected return value from the
                CSV file. This is accomplished by a mixed navigation, starting with file system
                navigation leading to the CSV file, then drilling down into the file and fetching
                the item of interest. The value against which to compare is retrieved by a trivial
                XPath expression (@eqXPath):</para>
            <programlisting><![CDATA[<!-- *** Response file shape *** -->                
<file foxpath="output\(*.xml, *.json)" mediatype="xml-or-json">
    ...
    <!-- *** Check - return code expected? *** -->
    <foxpath expr="..\..\config\msg-config.csv\csv-doc(., ',', 'yes')
                   //record[response eq $fileName]/returnCode"
             eqXPathMsg="Return code not the configured value"                   
             eqXPath="//*:returnCode"/>
    </foxpath>
</file>]]></programlisting>
            <para>The complete schema is shown in the appendix A1. To summarize, we have developed a
                schema which constrains the presence and contents of folders, the presence and
                contents of files, and relationships between contents of different files, in some
                cases belonging to different mediatypes. The devlopment of the schema demanded
                familiarity with XPath, but no programming skills beyond that. </para>
        </section>
    </section>
    <section>
        <title>Basic principles</title>
        <para>The "Getting started" section has familiarized you with the basic building blocks and
            principles of greenfox schemas. They can be summarized as follows.</para>
        <itemizedlist spacing="compact">
            <listitem>
                <para>A file system is thought of as containing two kinds of resources, <emphasis
                        role="bold">folders</emphasis> and <emphasis role="bold"
                    >files</emphasis></para>
            </listitem>
            <listitem>
                <para>Resources are validated against <emphasis role="bold">resource
                        shapes</emphasis></para>
            </listitem>
            <listitem>
                <para>There are two kinds of resource shapes – <emphasis role="bold">folder
                        shapes</emphasis> and <emphasis role="bold">file shapes</emphasis></para>
            </listitem>
            <listitem>
                <para>A resource shape is a set of <emphasis role="bold">constraints</emphasis>
                    which apply to a resource being validated</para>
            </listitem>
            <listitem>
                <para>Every violation of a constraint produces a <emphasis role="bold">validation
                        result</emphasis> describing the violation and identifying resource and
                    constraint</para>
            </listitem>
            <listitem>
                <para>The resources validated against a shape are called its <emphasis role="bold"
                        >focus resources</emphasis></para>
            </listitem>
            <listitem>
                <para>A resource shape may have a <emphasis role="bold">target
                        declaration</emphasis> which selects a set of focus resources</para>
            </listitem>
            <listitem>
                <para>A target declaration can be a resource name, a relative file path or a foxpath
                    expression</para>
            </listitem>
            <listitem>
                <para>Constraints can apply to <emphasis role="bold">resource properties</emphasis>
                    like the last modification time or the file size</para>
            </listitem>
            <listitem>
                <para>Constraints can apply to a <emphasis role="bold">resource value</emphasis>,
                    which is a value to which the resource is mapped by an expression</para>
            </listitem>
            <listitem>
                <para>A <emphasis role="bold">value shape</emphasis> combines an expression mapping
                    the focus resource to a resource value, and a set of constraints against which
                    to validate the resource value</para>
            </listitem>
            <listitem>
                <para>The expression used by a value shape may be an <emphasis role="bold">XPath
                        expression</emphasis> or a <emphasis role="bold">foxpath
                        expression</emphasis></para>
            </listitem>
            <listitem>
                <para>The <emphasis role="bold">foxpath context item</emphasis> used by a value
                    shape is the file path of the focus resource</para>
            </listitem>
            <listitem>
                <para>The <emphasis role="bold">XPath context item</emphasis> used by a value shape
                    is the root of an XDM node tree representing the content of the focus resource,
                    or the file path of the focus resource if an XDM node tree could not be
                    constructed</para>
            </listitem>
            <listitem>
                <para><emphasis role="bold">XDM node tree representations</emphasis> of file
                    resources can be controlled by mediatype related attributes on a file
                    shape</para>
            </listitem>
            <listitem>
                <para>When validating resources against resource shapes, the heterogeneity of
                    mediatypes can be hidden by a <emphasis role="bold">unified representation as
                        XDM node trees</emphasis></para>
            </listitem>
            <listitem>
                <para>When validating resources against resource shapes, the heterogeneity of
                    navigation (within resource contents and between resources) can be hidden by a
                        <emphasis role="bold">unified navigation language</emphasis>
                    (foxpath)</para>
            </listitem>
        </itemizedlist>

    </section>
    <section>
        <title>Information model</title>
        <para>This section describes the information model underlying the operations of
            greenfox.</para>
        <section>
            <title>Part 1: resource model</title>
            <para>A <emphasis role="bold">file system tree</emphasis> is a tree whose nodes are file
                system resources – folders and files.</para>
            <para>A <emphasis role="bold">file system resource</emphasis> has an identity, resource
                properties, derived resource properties and resource values.</para>
            <para>The <emphasis role="bold">resource identity</emphasis> of a file system resource
                can be expressed by a combination of file system identity and a file path locating
                the resource within the file system.</para>
            <para>A <emphasis role="bold">resource property</emphasis> has a name and a value which
                can be represented by an XDM value.</para>
            <para>A <emphasis role="bold">derived resource property</emphasis> is a property of a
                resource property value, or of a derived resource property value, which can be
                represented by an XDM value.</para>
            <para>A <emphasis role="bold">resource value</emphasis> is the XDM value of an
                expression evaluated in the context of a resource property or derived resource
                property.</para>
            <section>
                <title>Folder resources</title>
                <para>A folder has the following <emphasis role="bold">resource
                        properties</emphasis>.</para>
                <table xml:id="table-102">
                    <title>Resource properties of a folder resource, as currently evaluated by
                        greenfox. More properties may be added, e.g. representing access
                        rights.</title>
                    <titleabbrev xml:id="table-102-shorttitle">Folder resource
                        properties</titleabbrev>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="3*"/>
                        <colspec colname="c2" colnum="2" colwidth="4*"/>
                        <colspec colname="c3" colnum="3" colwidth="11*"/>
                        <thead>
                            <row>
                                <entry align="left">Property name</entry>
                                <entry align="left">Value type</entry>
                                <entry align="left">Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry align="left">[name]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">The folder name; optional – the file system root
                                    folder does not have a name</entry>
                            </row>
                            <row>
                                <entry align="left">[parent]</entry>
                                <entry align="left">Folder resource</entry>
                                <entry align="left">The XDM representation of resource identity is
                                    its file path</entry>
                            </row>
                            <row>
                                <entry align="left">[children]</entry>
                                <entry align="left">Folder and file resources</entry>
                                <entry align="left">The XDM representation of resource identity is
                                    its file path</entry>
                            </row>
                            <row>
                                <entry align="left">[last-modified]</entry>
                                <entry align="left"><code>xsd:dateTime</code></entry>
                                <entry align="left">May be out of sync when comparing values of
                                    resources from different machines</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para>A folder has the following <emphasis role="bold">derived resource
                        properties</emphasis>.</para>
                <table xml:id="table-103">
                    <title>Derived resource properties of a folder resource, as currently evaluated
                        by greenfox.</title>
                    <titleabbrev xml:id="table-103-shorttitle">Derived folder resource
                        properties</titleabbrev>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="3*"/>
                        <colspec colname="c2" colnum="2" colwidth="4*"/>
                        <colspec colname="c3" colnum="3" colwidth="11*"/>
                        <thead>
                            <row>
                                <entry align="left">Property name</entry>
                                <entry align="left">Value type</entry>
                                <entry align="left">Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry align="left">[filepath]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">The names of all ancestor folders and the folder
                                    itself, separated by a slash</entry>
                            </row>
                            <row>
                                <entry align="left">[foxpath-value]</entry>
                                <entry align="left">Mapping: foxpath expression string => XDM value </entry>
                                <entry align="left">A mapping of foxpath expressions to an XDM
                                    value, which is the value obtained by evaluating the expression
                                    in the context of the resource folder’s [filepath] value</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para><emphasis role="bold">Resource values</emphasis> are obtained by applying
                    [foxpath-value] to the text of a foxpath expression.</para>
            </section>
            <section>
                <title>File resources</title>
                <para>A file has the following <emphasis role="bold">resource
                    properties</emphasis>.</para>
                <table xml:id="table-104">
                    <title>Resource properties of a file resource, as currently evaluated by
                        greenfox. More properties may be added, e.g. representing access
                        rights.</title>
                    <titleabbrev xml:id="table-104-shorttitle">Folder resource
                        properties</titleabbrev>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="3*"/>
                        <colspec colname="c2" colnum="2" colwidth="4*"/>
                        <colspec colname="c3" colnum="3" colwidth="11*"/>
                        <thead>
                            <row>
                                <entry align="left">Property name</entry>
                                <entry align="left">Value type</entry>
                                <entry align="left">Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry align="left">[name]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">Mandatory – a file must have a name</entry>
                            </row>
                            <row>
                                <entry align="left">[parent]</entry>
                                <entry align="left">Folder resource</entry>
                                <entry align="left">The XDM representation of resource identity is
                                    its file path</entry>
                            </row>
                            <row>
                                <entry align="left">[last-modified]</entry>
                                <entry align="left"><code>xsd:dateTime</code></entry>
                                <entry align="left">May be out of sync when comparing values of
                                    resources from different machines</entry>
                            </row>
                            <row>
                                <entry align="left">[size]</entry>
                                <entry align="left"><code>xsd:integer</code></entry>
                                <entry align="left">File size, in bytes</entry>
                            </row>
                            <row>
                                <entry align="left">[sha1]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">SHA-1 hash value of file contents</entry>
                            </row>
                            <row>
                                <entry align="left">[sha256]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">SHA-256 hash value of file contents</entry>
                            </row>
                            <row>
                                <entry align="left">[md5]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">MD5 hash value of file contents</entry>
                            </row>

                            <row>
                                <entry align="left">[text]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">The text content of the file (empty if not a
                                    text file)</entry>
                            </row>
                            <row>
                                <entry align="left">[encoding]</entry>
                                <entry align="left"><code>xsd:anyURI</code></entry>
                                <entry align="left">The encoding of the text content of the file
                                    (empty if not a text file)</entry>
                            </row>
                            <row>
                                <entry align="left">[octets]</entry>
                                <entry align="left"><code>xsd:base64Binary</code></entry>
                                <entry align="left">The binary file content</entry>
                            </row>
                            <row>
                                <entry align="left">[xmldoc]</entry>
                                <entry align="left"><code>document-node()</code></entry>
                                <entry align="left">The result of parsing [text] into an XML
                                    document</entry>
                            </row>
                            <row>
                                <entry align="left">[jsondoc-basex]</entry>
                                <entry align="left"><code>document-node()</code></entry>
                                <entry align="left">The result of parsing [text] into a JSON
                                    document represented by a document-node in accordance with the
                                    rules defined by BaseX documentation</entry>
                            </row>
                            <row>
                                <entry align="left">[jsondoc-w3c]</entry>
                                <entry align="left"><code>document-node()</code></entry>
                                <entry align="left">The result of parsing [text] into a JSON
                                    document represented by a document-node in accordance with XPath
                                    function <code>fn:json-to-xml</code></entry>
                            </row>
                            <row>
                                <entry align="left">[htmldoc]</entry>
                                <entry align="left"><code>document-node()</code></entry>
                                <entry align="left">The result of parsing [text] into an XML
                                    document represented by a document-node in accordance with the
                                    rules defined by TagSoup documentation</entry>
                            </row>
                            <row>
                                <entry align="left">[csvdoc]</entry>
                                <entry align="left"><code>document-node()</code></entry>
                                <entry align="left">The result of parsing [text] into an XML
                                    document represented by a document-node, as controlled by the
                                    CSV parsing parameter values derived from a file shape, in
                                    accordance with the rules defined by BaseX documentation
                                </entry>
                            </row>
                            <row>
                                <entry align="left">[csvdocs]</entry>
                                <entry align="left">Mapping: csv-parse-parameters => document-node() </entry>
                                <entry align="left">The mapping result is a CSV document represented
                                    by a document-node as controlled by given CSV parsing parameter
                                    values, in accordance with the rules defined by BaseX
                                    documentation </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para>A file has the following <emphasis role="bold">derived resource
                        properties</emphasis>.</para>
                <table xml:id="table-105">
                    <title>Derived resource properties of a file resource, as currently evaluated by
                        greenfox.</title>
                    <titleabbrev xml:id="table-105-shorttitle">Derived folder resource
                        properties</titleabbrev>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="5*"/>
                        <colspec colname="c2" colnum="2" colwidth="5*"/>
                        <colspec colname="c3" colnum="3" colwidth="11*"/>
                        <thead>
                            <row>
                                <entry align="left">Property name</entry>
                                <entry align="left">Value type</entry>
                                <entry align="left">Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry align="left">[filepath]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">The names of all ancestor folders and the folder
                                    itself, separated by a slash</entry>
                            </row>
                            <row>
                                <entry align="left">[xmldoc.xpath]</entry>
                                <entry align="left">Mapping: XPath expression string => XDM value </entry>
                                <entry align="left">A mapping of XPath expressions to an XDM value,
                                    which is the value obtained by evaluating the expression in the
                                    context of [xmldoc]</entry>
                            </row>
                            <row>
                                <entry align="left">[jsondoc-basex.xpath]</entry>
                                <entry align="left">Mapping: XPath expression string => XDM value </entry>
                                <entry align="left">A mapping of XPath expressions to an XDM value,
                                    which is the value obtained by evaluating the expression in the
                                    context of [jsondoc-basex]</entry>
                            </row>
                            <row>
                                <entry align="left">[jsondoc-w3c.xpath]</entry>
                                <entry align="left">Mapping: XPath expression string => XDM value </entry>
                                <entry align="left">A mapping of XPath expressions to an XDM value,
                                    which is the value obtained by evaluating the expression in the
                                    context of [jsondoc-w3c]</entry>
                            </row>
                            <row>
                                <entry align="left">[htmldoc.xpath]</entry>
                                <entry align="left">Mapping: XPath expression string => XDM value </entry>
                                <entry align="left">A mapping of XPath expressions to an XDM value,
                                    which is the value obtained by evaluating the expression in the
                                    context of [htmldoc]</entry>
                            </row>
                            <row>
                                <entry align="left">[csvdoc.xpath]</entry>
                                <entry align="left">Mapping: ( csv-parse-parameters, XPath
                                    expression string ) => XDM value </entry>
                                <entry align="left">A mapping of CSV parsing parameter values and an
                                    XPath expression to an XDM value, which is the value obtained by
                                    evaluating the expression in the context of a document node from
                                    [csv-docs], obtained for the parsing parameter values</entry>
                            </row>
                            <row>
                                <entry align="left">[foxpath-value]</entry>
                                <entry align="left">Mapping: foxpath expression string => XDM value </entry>
                                <entry align="left">A mapping of foxpath expressions to an XDM
                                    value, which is the value obtained by evaluating the expression
                                    in the context of [filepath]</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para><emphasis role="bold">Resource values</emphasis> are obtained by applying
                    [foxpath-value] to the text of a foxpath expression, or one of the mappings
                    [*-xpath] to the text of an XPath expression.</para>
                <para>For information about CSV parsing parameters, see [x], section
                        <code>#wiki/CSV_Module</code>.</para>
            </section>
        </section>
        <section>
            <title>Part 2: schema model</title>
            <para>File system validation is a mapping of a file system tree and a greenfox schema to
                a set of greenfox validation results.</para>
            <para>A <emphasis role="bold">greenfox schema</emphasis> is a set of shapes.</para>
            <para>A <emphasis role="bold">shape</emphasis> is a resource shape or a value
                shape.</para>
            <para>A <emphasis role="bold">resource shape</emphasis> is a set of constraints
                applicable to a file system resource. It has an optional target declaration.</para>
            <para>A <emphasis role="bold">target declaration</emphasis> specifies the selection of a
                target.</para>
            <para>A <emphasis role="bold">target</emphasis> is a set of focus resources.</para>
            <para>A <emphasis role="bold">focus resource</emphasis> is a resource to be validated
                against a resource shape.</para>
            <para>A resource shape is a <emphasis role="bold">folder shape</emphasis> or a <emphasis
                    role="bold">file shape</emphasis>.</para>
            <para>A <emphasis role="bold">value shape</emphasis> is a mapping of a focus resource to
                a resource value and a set of constraints.</para>
            <para>A <emphasis role="bold">constraint</emphasis> maps a resource property or a
                resource value to a validation result.</para>
            <para>A constraint is declared by a shape. It identifies a constraint component and
                assigns values to the constraint parameters.</para>
            <para>A <emphasis role="bold">constraint component</emphasis> is a set of constraint
                parameter definitions and a validator.</para>
            <para>A <emphasis role="bold">constraint parameter</emphasis> is defined by the
                specification of a constraint component. The definition includes a name, a type, the
                value semantics and whether the parameter is mandatory or optional.</para>
            <para>A <emphasis role="bold">validator</emphasis> is a set of rules how a resource
                property or a resource value and the arguments bound to the constraint parameters
                are mapped to a validation result.</para>
            <para>A <emphasis role="bold">validation result</emphasis> is a boolean value signaling
                conformance of a resource property or a resource value against a constraint,
                accompanied by additional information identifying the resource and the constraint,
                as well as further items of information with names and semantics as prescribed by
                the constraint component.</para>
        </section>
        <section>
            <title>Part 3: validation model</title>
            <para><emphasis role="bold">File system validation</emphasis> is a mapping of a
                    <emphasis role="underline">file system tree</emphasis> and a <emphasis
                    role="underline">greenfox schema</emphasis> to a set of <emphasis
                    role="underline">validation result</emphasis>s, as defined in the following
                paragraphs.</para>
            <para><emphasis role="bold">Validation of a file system tree against a greenfox
                    schema</emphasis>: Given a <emphasis role="underline">file system
                    tree</emphasis> and a <emphasis role="underline">greenfox schema</emphasis>, the
                    <emphasis role="underline">validation result</emphasis>s are the union of
                results of the validation of the <emphasis role="underline">file system
                    tree</emphasis> against all <emphasis role="underline">shape</emphasis>s in the
                    <emphasis role="underline">greenfox schema</emphasis>. </para>
            <para><emphasis role="bold">Validation of a file system tree against a shape</emphasis>:
                Given a <emphasis role="underline">file system tree</emphasis> and a <emphasis
                    role="underline">shape</emphasis> in the <emphasis role="underline">greenfox
                    schema</emphasis>, the <emphasis role="underline">validation result</emphasis>s
                are the union of the results of the validation of all <emphasis role="underline"
                    >focus resource</emphasis>s that are in the <emphasis role="underline"
                    >target</emphasis> of the <emphasis role="underline">shape</emphasis>. </para>
            <para><emphasis role="bold">Validation of a resource against a shape</emphasis>: Given a
                    <emphasis role="underline">focus resource</emphasis> in the <emphasis
                    role="underline">file system tree</emphasis> and a <emphasis role="underline"
                    >shape</emphasis> in the <emphasis role="underline">greenfox schema</emphasis>,
                the <emphasis role="underline">validation result</emphasis>s are the union of the
                results of the validation of the <emphasis role="underline">focus
                    resource</emphasis> against all <emphasis role="underline"
                >constraint</emphasis>s declared by the <emphasis role="underline">shape</emphasis>,
                unless the <emphasis role="underline">shape</emphasis> has been deactivated, in
                which case the <emphasis role="underline">validation result</emphasis>s are empty. </para>
            <para><emphasis role="bold">Validation of a focus resource against a
                    constraint</emphasis>: Given a <emphasis role="underline">focus
                    resource</emphasis> in the <emphasis role="underline">file system
                    tree</emphasis> and a <emphasis role="underline">constraint</emphasis> of kind C
                in the <emphasis role="underline">greenfox schema</emphasis>, the <emphasis
                    role="underline">validation result</emphasis>s are defined by the <emphasis
                    role="underline">validator</emphasis> of the <emphasis role="underline"
                    >constraint component</emphasis> C. The <emphasis role="underline"
                    >validator</emphasis> typically takes as input a <emphasis role="underline"
                    >resource property</emphasis> or a <emphasis role="underline">resource
                    value</emphasis> of the <emphasis role="underline">focus resource</emphasis> and
                the arguments supplied to the <emphasis role="underline">constraint
                    parameter</emphasis>s. </para>
        </section>
    </section>
    <section>
        <title>Schema building blocks</title>
        <para>This section summarizes the <emphasis role="bold">building blocks</emphasis> of a
            greenfox schema. Building blocks are the parts of which a serialized schema is composed.
            The serialized schema should be distinguished from the logical schema, which is
            independent of a serialization and can be defined as a set of logical components (as
            defined by the information model) and parameter bindings. </para>
        <para>Each building block is represented by XML elements with a particular name. Note that
            there need not be a one-to-one correspondence between building blocks and logical
            components as defined by the information model. An Import declaration, for example, is a
            building block without corresponding logical component. Constraints, on the other hand,
            are logical components which in many cases are not represented by a separate building
            block, but by attributes attached to a building block. Note also that the information
            model includes logical components built into the greenfox language and without
            representation in any given schema (e.g. validators).</para>
        <table xml:id="table-201">
            <title>The building blocks of a greenfox schema.</title>
            <titleabbrev xml:id="table-201-shorttitle">Greenfox building blocks</titleabbrev>
            <tgroup cols="3">
                <colspec colname="c1" colnum="1" colwidth="4*"/>
                <colspec colname="c2" colnum="2" colwidth="11*"/>
                <colspec colname="c3" colnum="3" colwidth="5*"/>
                <thead>
                    <row>
                        <entry align="left">Building block</entry>
                        <entry align="left">Role</entry>
                        <entry align="left">XML representation</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left">Import declaration</entry>
                        <entry align="left">Declares the import of another greenfox schema so that
                            its contents are included in the current schema</entry>
                        <entry align="left"><code>gx:import</code></entry>
                    </row>
                    <row>
                        <entry align="left">Context declaration</entry>
                        <entry align="left">Declares external schema variables, the values of which
                            can be supplied by the agent launching the validation. Each variable is
                            represented by a <code>gx:field</code> child element.</entry>
                        <entry align="left"><code>gx:context</code></entry>
                    </row>
                    <row>
                        <entry align="left">Shapes library</entry>
                        <entry align="left">A collection of shapes without target declaration, which
                            can be referenced by other shapes</entry>
                        <entry align="left"><code>gx:shapesLib</code></entry>
                    </row>
                    <row>
                        <entry align="left">Constraints library</entry>
                        <entry align="left">A collection of constraint declaration nodes, which can
                            be referenced by shapes</entry>
                        <entry align="left"><code>gx:constraintsLib</code></entry>
                    </row>
                    <row>
                        <entry align="left">Constraint components library</entry>
                        <entry align="left">A collection of constraint component definitions, for
                            which constraints can be declared</entry>
                        <entry align="left"><code>gx:contraint-ComponentsLib/*</code></entry>
                    </row>
                    <row>
                        <entry align="left">Constraint component definition</entry>
                        <entry align="left">A user-defined constraint component. It declares the
                            constraint parameters and provides a validator. Parameters are
                            represented by <code>gx:param</code> child elements, the validator by a
                                <code>gx:xpath</code> or <code>gx:foxpath</code> child
                            element</entry>
                        <entry align="left"><code>gx:constraint-Component</code></entry>
                    </row>
                    <row>
                        <entry align="left">Domain</entry>
                        <entry align="left">A container element wrapping the shapes used for
                            validating a particular file system tree, identified by its root
                            folder</entry>
                        <entry align="left"><code>gx:domain</code></entry>
                    </row>
                    <row>
                        <entry align="left">Resource shapes</entry>
                        <entry align="left">A shape applicable to a file system folder or
                            file</entry>
                        <entry align="left">
                            <para><code>gx:folder</code></para>
                            <para><code>gx:file</code></para>
                        </entry>
                    </row>
                    <row>
                        <entry align="left">Value shape</entry>
                        <entry align="left">A shape applicable to a resource value</entry>
                        <entry align="left">
                            <para><code>gx:xpath</code></para>
                            <para><code>gx:foxpath</code></para>
                        </entry>
                    </row>
                    <row>
                        <entry align="left">Base shape declaration</entry>
                        <entry align="left">References a shape so that its contents are included in
                            the shape containing the reference</entry>
                        <entry align="left"><code>gx:baseShape</code></entry>
                    </row>
                    <row>
                        <entry align="left">Constraint declaration node</entry>
                        <entry align="left">An element representing one or several constraints
                            declared by a shape. Constraint parameters are represented by attributes
                            and/or child elements</entry>
                        <entry align="left">
                            <para><code>gx:targetSize</code></para>
                            <para><code>gx:folderContent</code></para>
                            <para><code>gx:mediaType</code></para>
                            <para><code>gx:fileSize</code></para>
                            <para><code>gx:lastModified</code></para>
                            <para><code>gx:name</code></para>
                            <para><code>gx:hashCode</code></para>
                        </entry>
                    </row>
                    <row>
                        <entry align="left">Conditional node</entry>
                        <entry align="left">A set of building blocks associated with a condition, so
                            that the building blocks are only used if the condition is met</entry>
                        <entry align="left"><code>gx:ifMediatype</code></entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
    </section>
    <section>
        <title>Schema language extension</title>
        <para>This section describes <emphasis role="bold">user-defined constraint
                components</emphasis>. Such components are defined within a greenfox schema by a
                <code>gx:constraintComponent</code> element. They can be used like built-in
            constraint components, observing syntax rules implied by the details of the component
            defining element.</para>
        <para>The extension model is based on the simple conceptual framework organizing
            greenfox:</para>
        <itemizedlist spacing="compact">
            <listitem>
                <para>File system validation can be decomposed into smallest units which are the
                    validation of a single resource against a single constraint</para>
            </listitem>
            <listitem>
                <para>A constraint resembles a function call, where the “function” is a constraint
                    component and the “function parameters” are the constraint parameters</para>
            </listitem>
            <listitem>
                <para>A constraint is declared by an XML element whose name, attributes and content
                    identify the constraint component and supply the parameter values (possibly
                    along with the details of other constraints)</para>
            </listitem>
            <listitem>
                <para>The location of the constraint element implies the value input:</para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>If the element is a value shape element, or a child of a value shape
                            element, the test value is the resource value produced by the expression
                            of the value shape</para>
                    </listitem>
                    <listitem>
                        <para>If it is a child element of a resource shape element, the test value
                            is a resource property</para>
                    </listitem>
                </itemizedlist>
            </listitem>
        </itemizedlist>
        <para>These rules imply a simple model how to define <emphasis role="bold">new constraint
                components</emphasis>. The definition of a new constraint component
            comprises:</para>
        <itemizedlist spacing="compact">
            <listitem>
                <para><emphasis role="ital">Specifies the signature</emphasis> of the constraint
                    component – component name, parameter names and types</para>
            </listitem>
            <listitem>
                <para><emphasis role="ital">Specifies the semantics</emphasis> of the constraint
                    component – the rules how the test value plus the parameter values are mapped
                    to</para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>A boolean result (signaling pass or failure)</para>
                    </listitem>
                    <listitem>
                        <para>Details of the validation result</para>
                    </listitem>
                </itemizedlist>
            </listitem>
            <listitem>
                <para><emphasis role="ital">Specifies the XML representation</emphasis> of a
                    constraint – element and attribute names and their mapping to constraint
                    parameters</para>
            </listitem>
            <listitem>
                <para><emphasis role="ital">Provides an implementation</emphasis> of the
                    semantics</para>
            </listitem>
        </itemizedlist>
        <para>The XML representaton of a constraint is one of the following: <itemizedlist
                spacing="compact">
                <listitem>
                    <para>a set of attributes which must be attached to a value shape</para>
                </listitem>
                <listitem>
                    <para>an element which must be a child element of a specified set of shape
                        elements (e.g. must be a child of a <code>&lt;file></code> element)</para>
                </listitem>
            </itemizedlist>
        </para>
        <para>As an illustrative example, consider the creation of a new constraint component
            characterized as follows.</para>
        <para><emphasis role="bold">Constraint component IRI</emphasis>: <code>ex:grep</code></para>
        <para><emphasis role="bold">Constraint parameters</emphasis>:</para>
        <informaltable xml:id="table-301">
            <tgroup cols="5">
                <colspec colname="c1" colnum="1" colwidth="5*"/>
                <colspec colname="c2" colnum="2" colwidth="10*"/>
                <colspec colname="c3" colnum="3" colwidth="10*"/>
                <colspec colname="c4" colnum="4" colwidth="10*"/>
                <colspec colname="c5" colnum="5" colwidth="10*"/>
                <thead>
                    <row>
                        <entry align="left">Name</entry>
                        <entry align="left">Type</entry>
                        <entry align="left">Meaning</entry>
                        <entry align="left">Mandatory?</entry>
                        <entry align="left">Default value</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left">regex</entry>
                        <entry align="left"><code>xsd:string</code></entry>
                        <entry align="left">A regular expression</entry>
                        <entry>+</entry>
                        <entry>-</entry>
                    </row>
                    <row>
                        <entry align="left">flags</entry>
                        <entry align="left"><code>xsd:string</code></entry>
                        <entry align="left">Evaluation flags</entry>
                        <entry>-</entry>
                        <entry>Zero-length string</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        <para><emphasis role="bold">XML syntax</emphasis>:</para>
        <itemizedlist spacing="compact">
            <listitem>
                <para>Syntax style: constraint element</para>
            </listitem>
            <listitem>
                <para>element name: <code>ex:grep</code></para>
            </listitem>
            <listitem>
                <para>parameter mapping:</para>
                <itemizedlist spacing="compact">
                    <listitem>
                        <para>parameter $regex - attribute @regex</para>
                    </listitem>
                    <listitem>
                        <para>parameter $flags – attribute @flags</para>
                    </listitem>
                </itemizedlist>
            </listitem>
            <listitem>
                <para>child elements: -</para>
            </listitem>
        </itemizedlist>
        <para><emphasis role="bold">Semantics</emphasis>:</para>
        <para>"A constraint is satisfied if the focus resource is a text file containing a line
            matching regular expression <code>$regex</code>, as controlled by the regex evaluation
                <code>flags</code> given by $flags (e.g. case-insensitively)"</para>
        <para>The <emphasis role="bold">implementation</emphasis> may be provided by the following
            element, which must be a child element of
            <code>gx:constraintComponentsLib</code>:</para>
        <programlisting><![CDATA[<constraintComponent constraintElementName="ex:grep">
    <param name="pattern"></param>
    <param name="flags"></param>
    <xpath><![CDATA[
exists($this ! unparsed-text-lines(.)[matches(., $pattern, $flags)])
    ]]>]]<![CDATA[></xpath>
</constraintComponent>]]></programlisting>
        <para>Note in the expression text the use of a variable $this. It is always bound to the
            file path of the focus resource.</para>
    </section>
    <section>
        <title>Validation results</title>
        <para>This section describes the results produced by a greenfox validation.</para>
        <section>
            <title>Validation reports and representations</title>
            <para>The primary result of a greenfox validation is an RDF graph called the <emphasis
                    role="bold">white validation report</emphasis>. This is mapped to the <emphasis
                    role="bold">red validation report</emphasis>, an RDF graph obtained by removing
                from a white report all triples not related to constraint violations. For red and
                white validation reports a <emphasis role="bold">canonical XML
                    representation</emphasis> is defined. Apart from that there are <emphasis
                    role="bold">derived representations</emphasis>, implementation-dependent reports
                which may use any data model and mediatype.</para>
            <para>The <emphasis role="bold">white validation report</emphasis> is an RDF graph with
                exactly one instance of <code>gx:ValidationReport</code>. The instance has the
                following properties:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para><code>gx:conforms</code>, with an <code>xsd:boolean</code> value
                        indicating conformance</para>
                </listitem>
                <listitem>
                    <para><code>gx:result</code>, with one value ...</para>
                    <itemizedlist spacing="compact">
                        <listitem>
                            <para>for each constraint violation (“red and yellow values”)</para>
                        </listitem>
                        <listitem>
                            <para>for each constraint check which did not produce a violation
                                (“green values”)</para>
                        </listitem>
                        <listitem>
                            <para>o for each observation, which is a result triggered by a value
                                shape in order to record a resource value not related to constraint
                                checking (“blue values”)</para>
                        </listitem>
                    </itemizedlist>
                </listitem>
            </itemizedlist>
            <para>The <emphasis role="bold">red validation report</emphasis> is an RDF graph
                obtained by removing from the white validation report all green and blue result
                values. Note that the validation report defined by the SHACL language [x]
                corresponds to the red validation report defined by greenfox.</para>
            <para>The <emphasis role="bold">canonical XML representation</emphasis> of a white or
                red validation report is an XML document with a
                    <code>&lt;gx:validationReport></code> root element, which has for each
                    <code>gx:result</code> value from the RDF graph one child element, which is a
                    <code>&lt;gx:red></code>, <code>&lt;gx:yellow></code>,
                    <code>&lt;gx:green></code> or <code>&lt;gx:blue></code> element, according to
                the <code>gx:result/gx:severity</code> property value being
                    <code>gx:Violation</code>, <code>gx:Warning</code>, <code>gx:Info</code> or
                    <code>gx:Observation</code>). </para>
            <para>A <emphasis role="bold">derived representation</emphasis> is any kind of data
                structure, using any mediatype, representing information content from the white or
                red validation report in an implementation-defined way.</para>
        </section>
        <section>
            <title>Validation result</title>
            <para>A <emphasis role="bold">validation result</emphasis> is a unit of information
                which describes the outcome of validating a focus resource against a constraint:
                either constraint violation (“red” or “yellow” result), or conformance (“green”
                result).</para>
            <para>A validation result is an RDF resource with several properties as described below.
                Key features of the result model:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>Every result is related to an individual file system resource (file or
                        folder)</para>
                </listitem>
                <listitem>
                    <para>Every result is related to an individual constraint (and, by implication,
                        a shape)</para>
                </listitem>
            </itemizedlist>
            <para>This allows for meaningfull aggregation by resource, by constraint and by shape
                and, by implication, any combination of aggregated resources, constraints and
                shapes. Such aggregation may, for example, be useful for integrating validation
                results into a graphical representation of the file system and for analysis of
                impact.</para>
            <para>A detailed description of the validation result model – RDF properties, SHACL
                equivalent and XML representation – is found in appendix A3.</para>
        </section>
    </section>
    <section>
        <title>Implementation</title>
        <para>An implementation of a greenfox processor is available on github [x]. The processor is
            provided as a command line tool (<code>greenfox.bat</code>, <code>greenfox.sh</code>).
            Example call:</para>
        <programlisting>greenfox "val?gfox=/projects/greenfox/examples/gfox-system-s.xml,
      domain=/projects/greenfox/examples/system-s"</programlisting>
        <para>The implementation is written in XQuery and requires the use of the BaseX [x] XQuery
            processor. </para>
    </section>
    <section>
        <title>Discussion</title>
        <para>To be added.</para>
    </section>


    <appendix xml:id="appendix-greenfox-schema-s1">
        <title>Appendix A1: greenfox schema for system S</title>
        <para>This appendix lists the complete schema developed in section “Getting started with
            greenfox”.</para>
    </appendix>
    <appendix xml:id="appendix-alignment-greenfox-shacl">
        <title>Appendix A2: Alignment of key concepts between greenfox and SHACL</title>
        <para>This appendix summarizes the conceptual alignment between greenfox and SHACL. The
            striking correspondence reflects our decision to use SHACL as a blueprint for the
            conceptual framework underlying the greenfox language. Greenfox can be thought of as a
            combination of SHACL’s abstract validation model with a view of the file system through
            the prism of a unified value and expression model (XDM, XPath/XQuery + foxpath). </para>
        <para>The alignment is described in two tables. The first table provides an aligned
            definition of the validation process as a decomposable operation as defined by greenfox
            and SHACL. The second table is an aligned enumeration of some building blocks of the
            conceptual framework underlying greenfox and SHACL. </para>
        <table xml:id="appendix-a2-alignment-table-1">
            <title>Greenfox/SHACL alignment, part 1: validation model</title>
            <titleabbrev xml:id="appendix-a2-alignment-table-1-shorttitle">Alignment 1</titleabbrev>
            <tgroup cols="2">
                <colspec colname="c1" colnum="1" colwidth="4*"/>
                <colspec colname="c2" colnum="2" colwidth="4*"/>
                <thead>
                    <row>
                        <entry align="left">Greenfox operation</entry>
                        <entry align="left">SHACL operaration</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left">Validation of a file system against a greenfox schema </entry>
                        <entry align="left">Validation of a data graph against a shapes graph
                        </entry>
                    </row>
                    <row>
                        <entry align="left">= Union of the results of the validation of the file
                            system against all shapes</entry>
                        <entry align="left">= Union of the results of the validation of the data
                            graph against all shapes</entry>
                    </row>
                    <row>
                        <entry align="left">Validation of a file system against a shape</entry>
                        <entry align="left">Validation of a data graph against a shape</entry>
                    </row>
                    <row>
                        <entry align="left">= Union of the results of all focus resources in the
                            target of the shape</entry>
                        <entry align="left">= Union of the results of all focus nodes in the target
                            of the shape</entry>
                    </row>
                    <row>
                        <entry align="left">Validation of a focus resource against a shape = Union
                            of the results of the validation of the focus resource against all
                            constraints declared by the shape </entry>
                        <entry align="left">Validation of a focus node against a shape = Union of
                            the results of the validation of the focus node against all constraints
                            declared by the shape</entry>
                    </row>
                    <row>
                        <entry align="left">Validation of a focus node against a constraint =
                            function( constraint parameters , focus resource, resource values? </entry>
                        <entry align="left">Validation of a focus node against a constraint =
                            function( constraint parameters , focus node, property values? </entry>
                    </row>
                    <row>
                        <entry align="left">Resource values = XPath(resource) | foxpath
                            (resource)</entry>
                        <entry align="left">Property values = SPARQL property path (node)</entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
        <table xml:id="appendix-a2-alignment-table-2">
            <title>Greenfox/SHACL alignment, part 2: conceptual building blocks</title>
            <titleabbrev xml:id="appendix-a2-alignment-table-2-shorttitle">Alignment 2</titleabbrev>
            <tgroup cols="3">
                <colspec colname="c1" colnum="1" colwidth="4*"/>
                <colspec colname="c2" colnum="2" colwidth="4*"/>
                <colspec colname="c3" colnum="3" colwidth="6*"/>
                <thead>
                    <row>
                        <entry align="left">Greenfox concept</entry>
                        <entry align="left">SHACL</entry>
                        <entry align="left">Remark</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left"><para>Resource shape:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Folder shape</para>
                                </listitem>
                                <listitem>
                                    <para>File shape</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Node shape</entry>
                        <entry align="left">Common key concept: shape = set of constraints for a set
                            of resources </entry>
                    </row>
                    <row>
                        <entry align="left">Focus resource</entry>
                        <entry align="left">Focus node</entry>
                        <entry align="left">Common view: validation can be decomposed into instances
                            of validation of a single focus against a single shape </entry>
                    </row>
                    <row>
                        <entry align="left"><para>Target declaration</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Foxpath expression</para>
                                </listitem>
                                <listitem>
                                    <para>Literal file system path</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">
                            <para>Target declaration</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Class members</para>
                                </listitem>
                                <listitem>
                                    <para>Subjects of predicate IRI</para>
                                </listitem>
                                <listitem>
                                    <para>Objects of predicate IRI</para>
                                </listitem>
                                <listitem>
                                    <para>Literal IRI (node target)</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Difference: in greenfox a target declaration is
                            essentially a navigation result, in SHACL it tends to be derived from
                            class membership (ontological)</entry>
                    </row>
                    <row>
                        <entry align="left">Resource value</entry>
                        <entry align="left">Value node</entry>
                        <entry align="left">Common view: non-trivial validation requires mapping
                            resources to values</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Mapping resource to value:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>XPath expression</para>
                                </listitem>
                                <listitem>
                                    <para>Foxpath expression</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Mapping resource to property:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>SPARQL property path</para>
                                </listitem>
                            </itemizedlist></entry>
                        <entry align="left">Common view: the mapping of a resource to a value is an
                            expression</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Value shape:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>XPath shape</para>
                                </listitem>
                                <listitem>
                                    <para>Foxpath shape</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Property shape</entry>
                        <entry align="left">Common view: usefulness of an entity combining a
                                <emphasis role="ital">single</emphasis> mapping of the focus
                            resource to a value with a <emphasis role="ital">set of
                                constraints</emphasis> for that value</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Constraint declaration</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Constraint component</para>
                                </listitem>
                                <listitem>
                                    <para>Constraint parameters</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Constraint declaration</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Constraint component</para>
                                </listitem>
                                <listitem>
                                    <para>Constraint parameters</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Common view: a constraint declaration can be thought of
                            as a function call</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Constraint component</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Signature</para>
                                </listitem>
                                <listitem>
                                    <para>Mapping semantic</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Constraint component</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Signature</para>
                                </listitem>
                                <listitem>
                                    <para>Mapping semantic</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Common view: a constraint component can be thought of as
                            a library function</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Validation report</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Constraint violations</para>
                                </listitem>
                                <listitem>
                                    <para>Constraint passes</para>
                                </listitem>
                                <listitem>
                                    <para>Observations</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Validation report</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Constraint violations</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Common view: a result is an RDF resource; difference: in
                            greenfox also successful constraint checks produce results (“green
                            results”); difference: in greenfox also observations can be produced,
                            results unrelated to constraint checking (“blue results”) </entry>
                    </row>
                    <row>
                        <entry align="left"><para>Extension language:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>XPath/XQuery expression</para>
                                </listitem>
                                <listitem>
                                    <para>foxpath expression</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Extension language:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>SPARQL SELECT queries</para>
                                </listitem>
                                <listitem>
                                    <para>SPARQL ASK queries</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Common view: extension of functionality is based on an
                            expression language for mapping resources to values and values to a
                            result</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Mediatype integration:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Common data model</para>
                                </listitem>
                                <listitem>
                                    <para>Common navigation model</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">-</entry>
                        <entry align="left">Difference: in contrast to SHACL, greenfox faces a
                            heterogeneous collection of validation targets, calling for integration
                            concepts</entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
    </appendix>
    <appendix xml:id="appendix-validation-result-model">
        <title>Appendix A3: Validation result model</title>
        <para>bla</para>
    </appendix>
    <bibliography>
        <biblioentry xml:id="basex">
            <abbrev>1</abbrev>
            <title>BaseX</title>
            <date>2019</date>
            <publisher>
                <publishername>BaseX GmbH</publishername>
            </publisher>
            <biblioid class="uri">http:// basex.org</biblioid>
        </biblioentry>
        <biblioentry xml:id="drugbank">
            <abbrev>2</abbrev>
            <title>DrugBank 5.0: a major update to the DrugBank database for 2018.</title>
            <date>2017</date>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>DS</firstname>
                        <surname>Wishart</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>YD</firstname>
                        <surname>Feunang</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>AC</firstname>
                        <surname>Guo</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>EJ</firstname>
                        <surname>Lo</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>A</firstname>
                        <surname>Marcu</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>JR</firstname>
                        <surname>Grant</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>T</firstname>
                        <surname>Sajed</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>D</firstname>
                        <surname>Johnson</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>C</firstname>
                        <surname>Li</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Z</firstname>
                        <surname>Sayeeda</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>N</firstname>
                        <surname>Assempour</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>I</firstname>
                        <surname>Iynkkaran</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Y</firstname>
                        <surname>Liu</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>A</firstname>
                        <surname>Maciejewski</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>N</firstname>
                        <surname>Gale</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>A</firstname>
                        <surname>Wilson</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>L</firstname>
                        <surname>Chin</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>R</firstname>
                        <surname>Cummings</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>D</firstname>
                        <surname>Le</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>A</firstname>
                        <surname>Pon</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>C</firstname>
                        <surname>Knox</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>M</firstname>
                        <surname>Wilson</surname>
                    </personname>
                </author>
            </authorgroup>
            <publisher>
                <publishername>Nucleic Acids Res. 2017 Nov 8.</publishername>
            </publisher>
            <biblioid class="uri">https://www.drugbank.ca/</biblioid>
            <biblioid class="doi">10.1093/nar/gkx1037</biblioid>
        </biblioentry>
        <biblioentry xml:id="graphql">
            <abbrev>3</abbrev>
            <title>GraphQL</title>
            <date>2017</date>
            <publisher>
                <publishername>Facebook Inc.</publishername>
            </publisher>
            <biblioid class="uri">http://graphql.org/</biblioid>
        </biblioentry>
        <biblioentry xml:id="jsonld">
            <abbrev>4</abbrev>
            <title>JSON-LD 1.0. A JSON-based Serialization for Linked Data</title>
            <date>2014</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/json-ld/</biblioid>
        </biblioentry>
        <biblioentry xml:id="location-trees">
            <abbrev>5</abbrev>
            <title>Location trees enable XSD based tool development.</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2017</date>
            <biblioid class="uri"
                >http://xmllondon.com/2017/xmllondon-2017-proceedings.pdf</biblioid>
        </biblioentry>
        <biblioentry xml:id="rdfa">
            <abbrev>6</abbrev>
            <title>RDFa Core 1.1 – Third Edition.</title>
            <date>2015</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/rdfa-core/</biblioid>
        </biblioentry>
        <biblioentry xml:id="turtle">
            <abbrev>7</abbrev>
            <title>RDF 1.1 Turtle</title>
            <date>2014</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/turtle/</biblioid>
        </biblioentry>
        <biblioentry xml:id="shax">
            <abbrev>8</abbrev>
            <title>A SHAX processor, transforming SHAX models into SHACL, XSD and JSON
                Schema.</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2017</date>
            <biblioid class="uri">https://github.com/hrennau/shax</biblioid>
        </biblioentry>
        <biblioentry xml:id="xpath31">
            <abbrev>9</abbrev>
            <title>XML Path Language (XPath) 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xpathfunctions31">
            <abbrev>10</abbrev>
            <title>XPath and XQuery Functions and Operators 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-functions-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xdm31">
            <abbrev>11</abbrev>
            <title>XQuery and XPath Data Model 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-datamodel-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xquery31">
            <abbrev>12</abbrev>
            <title>XQuery 3.1: An XML Query Language</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xquery-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xsdplus">
            <abbrev>13</abbrev>
            <title>xsdplus - a toolkit for XSD based tool development</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2017</date>
            <biblioid class="uri">https://github.com/hrennau/xsdplus</biblioid>
        </biblioentry>
    </bibliography>
</article>
