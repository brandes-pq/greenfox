<?xml-model href='http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng' schematypens='http://relaxng.org/ns/structure/1.0'?><?xml-model href='http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng' type='application/xml' schematypens='http://purl.oclc.org/dsdl/schematron'?>
<article xmlns="http://docbook.org/ns/docbook" version="5.0">
    <info>
        <title>Greenfox – a schema language for validating file systems</title>
        <author>
            <personname>Hans-Juergen Rennau</personname>
            <email>hans-juergen.rennau@parsqube.de</email>
            <personblurb>
                <para/>
            </personblurb>
            <affiliation>
                <orgname>parsQube GmbH</orgname>
            </affiliation>
        </author>
        <keywordset>
            <keyword>Validation, SHACL, XSD, JSON Schema, Schematron</keyword>
        </keywordset>
        <abstract>
            <para>Greenfox is a schema language for validating file systems. One key feature is an
                abstract validation model inspired by the SHACL language. Another key feature is a
                view of the file system which is based on the XDM data model and thus supports a set
                of powerful expression languages (XPath, foxpath, XQuery). Using their expressions
                as basic building blocks, the schema language unifies navigation within and between
                resources and access to the structured contents of files with different mediatypes.
            </para>
        </abstract>
    </info>
    <section xml:id="introduction">
        <title>Introduction</title>
        <para>How to validate data against expectations? Major options are visual inspection,
            programatic checking and validation against a schema document (e.g. XSD, RelaxNG,
            Schematron, JSON Schema) or a schema graph (e.g. SHACL). Schema validation is in many
            scenarios the superior approach, as it is automated and declarative. But there are also
            limitations worth considering when thinking about validation in general. </para>
        <para>First, schema languages describe instances of a particular format or mediatype only
            (e.g. XML, JSON, RDF), whereas typical projects involve a mixture of mediatypes.
            Therefore schema validation tends to describe the state of resources which are pieces
            from a jigsaw puzzle, and the question arises how to integrate the results into a
            coherent whole. </para>
        <para>Second, several schema languages of key importance are grammar based and therefore do
            not support “incremental validation” – starting with a minimum of constraints, and
            adding more along the way. We cannot use XSD, RelaxNG or JSON Schema in order to express
            some very specific key expectation, without saying many things about the document as a
            whole, which may be a task requiring disproportional effort. Rule based schema languages
            (like Schematron) do support incremental validation, but they are inappropriate for
            comprehensive validation as accomplished by grammar based languages.</para>
        <para>As a consequence, schema validation enables isolated acts of resource validation, but
            it cannot accomplish the integration of validation results. Put differently, schema
            validation may contribute to, but cannot accomplish, system validation. The situation
            might change in an interesting way if we had a schema language for validating <emphasis
                role="ital">file system contents</emphasis> – arbitrary trees of files and folders.
            This simple abstraction suffices to accommodate any software project, and it can
            accommodate system representations of very large complexity. </para>
        <para>This document describes an early version of <emphasis role="bold">greenfox</emphasis>,
            a schema language for validating file system contents. By implication, it can also be
            viewed as a schema language for the validation of <emphasis role="ital"
                >systems</emphasis>. Such a claim presupposes that a meaningful reflection of system
            properties, state and behaviour can be represented by a collection of data (log data,
            measurement results, test results, configurations, …) distributed over a set of files
            arranged in a tree of folders. It might then sometimes be possible to translate
            meaningful definitions of system validity into constraints on file system contents. At
            other times it may not be possible, for example if the assessment of validity requires a
            tracking of realtime data.</para>
        <para>The notion of system validation implies that extensibility must be a key feature of
            the language. The language must not only offer a scope of expressiveness which is
            immediately useful. It must at the same time serve as a <emphasis role="ital"
                >framework</emphasis>, within which current capabilities, future extensions and
            third-party contributions are uniform parts of a coherent whole. The approach we took is
            a generalization of the key concepts underlying SHACL [x], a validation language for RDF
            data. These concepts serve as the building blocks of a simple metamodel of validation,
            which offers guidance for extension work.</para>
        <para>Validation relies on the key operations of navigation and comparison. File system
            validation must accomplish them in the face of divers mediatypes and the necessity to
            combine navigation within as well as between resources. In response to this challenge,
            greenfox is based on a <emphasis role="ital">unified data model</emphasis> (XDM) [x] and
            a <emphasis role="ital">unified navigation model</emphasis> (foxpath/XPath) [x] [x] [x]
            [x] built upon it. </para>
        <para>Validation produces results, and the more complex the system, the more important it
            may become to produce results in a form which combines maximum precision with optimal
            conditions for integration with other resources. This goal is best served by a <emphasis
                role="ital">vocabulary</emphasis> for expressing validation results and schema
            contents in a way which does not require any context for being understood. We choose an
            RDF based definition of validation schema and validation results, combined with a
            bidirectional mapping between RDF and more intuitive representations, XML and JSON. For
            practical purposes, we assume the XML representation to be the form most frequently
            used.</para>
        <para>Before providing a more detailed overview of the greenfox language, a detailed example
            should give a first impression of how the language can be used.</para>
    </section>
    <section xml:id="getting-started">
        <title>Getting started with greenfox</title>
        <para>This section illustrates the development of a greenfox schema designed for validating
            a file system tree against a set of expections. Such a validation can also be viewed as
            validation of the system “behind” the file system tree, represented by its
            contents.</para>
        <section>
            <title>The system – system S</title>
            <para>Consider <emphasis role="bold">system S</emphasis> – an imaginary system which is
                a collection of web services. We are going to validate a <emphasis role="ital">file
                    system representation</emphasis> which is essentially a set of test results,
                accompanied by resources supporting validation (XSDs, codelists and data about
                expected response messages). The following listing shows a file system tree which is
                a representation of system S, as observed at a certain point in time:</para>
            <programlisting><![CDATA[
system-s
. resources
. . codelists
. . . codelist-foo-article.xml
. . xsd
. . . schema-foo-article.xsd
. testcases
. . test-t1
. . . config
. . . . msg-config.xml
. . . input
. . . . getFooRQ*.xml
. . . output
. . . . getFooRS*.xml
. . +test-t2   (contents: see test-t1)
. . usecases
. . . usecase-u1
. . . . usecase-u1a
. . . . . +test-t3   (contents: see test-t1)]]></programlisting>
            <para>The concrete file system tree must be distinguished from the <emphasis role="ital"
                    >expected file system</emphasis> tree, which is described by the following
                rules.</para>
            <table xml:id="table-1">
                <title>Rules defining "validity" of the considered file system.</title>
                <titleabbrev xml:id="table-1-shorttitle">Validity rules</titleabbrev>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="2*"/>
                    <colspec colname="c2" colnum="2" colwidth="4*"/>
                    <colspec colname="c3" colnum="3" colwidth="11*"/>
                    <thead>
                        <row>
                            <entry align="left">File or folder</entry>
                            <entry align="left">File path</entry>
                            <entry align="left">Expectation</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">resources/codelists</entry>
                            <entry align="left">Contains one or more codelist files</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">resources/codelists/*</entry>
                            <entry align="left">A <emphasis role="bold">codelist file</emphasis>;
                                name not constrained; must be an XML document containing
                                    <code>&lt;codelist></code> elements with a @name attribute and
                                    <code>&lt;entry></code> children</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">resources/xsd</entry>
                            <entry align="left">Contains one or more XSDs describing services
                                messages</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">resources/xsd/*</entry>
                            <entry align="left">An <emphasis role="bold">XSD schema file</emphasis>;
                                name not constrained</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*</entry>
                            <entry align="left">A test case folder, containing <code>input</code>,
                                    <code>output</code> and <code>config</code> folders; apart from
                                these only optional <code>log-*</code> files are allowed </entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*/config</entry>
                            <entry align="left">Test case config folder, containing file
                                    <code>msg-config.csv</code></entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">.//test-*/config/msg-config.csv</entry>
                            <entry align="left">A <emphasis role="bold">message configuration
                                    file</emphasis>; CSV file with three columns: request file name,
                                response file name, expected return code</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*/input</entry>
                            <entry align="left">Test case input folder, containg request
                                messages</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">.//test-*/input/*</entry>
                            <entry align="left">A <emphasis role="bold">request message
                                    file</emphasis>; name extension <code>.xml</code> or
                                    <code>.json</code>; mediatype corresponding to name
                                extension</entry>
                        </row>
                        <row>
                            <entry align="left">folder</entry>
                            <entry align="left">.//test-*/output</entry>
                            <entry align="left">Test case output folder, containing response
                                messages</entry>
                        </row>
                        <row>
                            <entry align="left">file</entry>
                            <entry align="left">.//test-*/output/*</entry>
                            <entry align="left">A <emphasis role="bold">response message
                                    file</emphasis>; name extension <code>.xml</code> or
                                    <code>.json</code>; mediatype corresponding to name
                                extension</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>The number and location of testcase folders (<code>test-*</code>) are
                unconstrained. This means that the testcase folders may be grouped and wrapped in
                any way, although they must not be nested. So the use of a <code>testcases</code>
                folder wrapping all testcase folders - and the use of <code>usecase*</code> folders
                adding additional substructure - is allowed, but must not be expected. The placing
                of XSDs in folder <code>resources/xsd</code>, on the other hand, is obligatory, and
                likewise the placing of codelist documents in folder
                    <code>resources/codelists</code>. The names of XSD and codelist files are not
                constrained. </para>
            <para>Apart from these static constraints, the presence of some files implies the
                presence of other files:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>For every request message, there must be a response message with a name
                        derived from the request file name (replacing substring <code>RQ</code> with
                            <code>RS</code>).</para>
                </listitem>
            </itemizedlist>
            <para>Expectations are not limited to the presence of files and folders - they include
                details of file contents, in some cases relating the contents of different files
                with different mediatypes: </para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>For every response message in XML format, there is exactly one XSD against
                        which it can be validated</para>
                </listitem>
                <listitem>
                    <para>Every response message in XML format is valid against the appropriate
                        XSD</para>
                </listitem>
                <listitem>
                    <para>Response message items (XML elements or JSON fields) with a particular
                        name (e.g. <code>fooValue</code>) must be found in the appropriate XML
                        codelist discovered in a set of codelist files</para>
                </listitem>
                <listitem>
                    <para>Response message return codes (contained by XML and JSON documents) must
                        be as configured by the corresponding row in a CSV table</para>
                </listitem>
            </itemizedlist>
        </section>
        <section>
            <title>Building a greenfox schema "system S"</title>
            <para>Now we create a greenfox schema which enables us to validate the file system
                against these expectations. An initial version only checks the existence of
                non-empty XSD and codelists folders:</para>
            <programlisting>
&lt;greenfox greenfoxURI="http://www.greenfox.org/ns/schema-examples/system-s"
          xmlns="http://www.greenfox.org/ns/schema">
          
  &lt;!-- *** System file tree *** -->    
  &lt;<emphasis role="bold">domain</emphasis> path="\tt\greenfox\resources\example-system\system-s" 
          name="system-s">    
        
      &lt;!-- *** System root folder shape *** -->
      &lt;<emphasis role="bold">folder</emphasis> foxpath="." id="systemRootFolderShape">
            
        &lt;!-- *** XSD folder shape -->
        &lt;<emphasis role="bold">folder</emphasis> foxpath="<emphasis role="bold">.\\resources\xsd</emphasis>" id="xsdFolderShape">
            &lt;targetSize msg="No XSD folder found" count="1"/>
            &lt;<emphasis role="bold">file</emphasis> foxpath="<emphasis role="bold">*.xsd</emphasis>" id="xsdFileShape">
                &lt;targetSize msg="No XSDs found" minCount="1"
            &lt;/file>
        &lt;/folder>                

        &lt;!-- *** Codelist folder shape -->
        &lt;<emphasis role="bold">folder</emphasis> foxpath="<emphasis role="bold">.\\resources\codelists</emphasis>" id="codelistFolderShape">
            &lt;targetSize msg="No codelist folder found" count="1"/>
            &lt;<emphasis role="bold">file</emphasis> foxpath="<emphasis role="bold">*[is-xml(.)]</emphasis>" id="codelistFileShape">
                &lt;targetSize msg="No codelist files found" minCount="1"
            &lt;/file>
        &lt;/folder          
      &lt;/folder>                
  &lt;/domain>    
&lt;/greenfox></programlisting>
            <para>The <code>&lt;domain></code> element represents the root folder of a <emphasis
                    role="bold">file system tree</emphasis> to be validated. The folder is
                identified by a mandatory @path attribute.</para>
            <para>A <code>&lt;folder></code> element describes a set of folders selected by a
                    <emphasis role="ital">target declaration</emphasis>. Here, the target
                declaration is a foxpath expression, given by a @foxpath attribute. Foxpath [x] [x]
                [x] is an extended version of XPath 3.0 which supports file system navigation, node
                tree navigation and a mixing of file system and node tree navigation within a single
                path expression. Note that file system navigaton steps are connected by a backslash
                operator, rather than a slash, which is used for node tree navigation steps. The
                foxpath expression is evaluated in the context of a folder selected by the target
                declaration of the <emphasis role="ital">containing</emphasis>
                <code>&lt;folder></code> element (or <code>&lt;domain></code>, if there is no
                containing <code>&lt;folder></code>). Evaluation “in the context of a folder” means
                that the initial context item is the file path of that folder, so that relative file
                system path expressions are resolved in this context (see [x], [x] for details). For
                example, the expression</para>
            <programlisting>  .\\resources\xsd</programlisting>
            <para>resolves to the <code>xsd</code> folders contained by a <code>resources</code>
                folder found at any depth under the context folder, which here is
                    <code>system-s</code>. Similarly, a <code>&lt;file></code> element describes the
                set of files selected by its <emphasis role="ital">target declaration</emphasis>,
                which is a foxpath expression (e.g. <code>*.xsd</code>) evaluated in the context of
                a folder selected by the containing <code>&lt;folder></code> element’s target
                declaration (e.g. <code>.\\resources\xsd</code>). </para>
            <para>A <code>&lt;folder></code> element represents a <emphasis role="bold">folder
                    shape</emphasis>, which is a set of <emphasis role="bold">constraints</emphasis>
                applying to a <emphasis role="bold">target</emphasis>. The target is a (possibly
                empty) set of folders, selected by a <emphasis role="bold">target
                    declaration</emphasis>, e.g. a foxpath expression. The constraints of a folder
                shape are declared by child elements of the shape element.</para>
            <para>Likewise, a <code>&lt;file></code> element represents a <emphasis role="bold">file
                    shape</emphasis>, defining a set of constraints applying to a target, which is a
                set of files selected by a target declaration. Folder shapes and file shapes are
                collectively called <emphasis role="bold">resource shapes</emphasis>.</para>
            <para>The expected number of folders or files belonging to the target of a shape can be
                expressed by declaring a <emphasis role="bold">constraint</emphasis>. A constraint
                has a kind (called the <emphasis role="bold">constraint component</emphasis>) and a
                set of arguments passed to the <emphasis role="bold">constraint
                    parameters</emphasis>. Every kind of constraint has a "signature", a
                characteristic set of mandatory and optional constraint parameters, defined in terms
                of name, type and cardinality. A <emphasis role="ital">constraint
                    component</emphasis> can therefore be thought of as a library function, and a
                    <emphasis role="ital">constraint declaration</emphasis> is like a function call,
                represented by elements and/or attributes. Here, we declare a
                    <code>TargetMinCount</code> constraint, represented by a @minCount attribute on
                a <code>&lt;targetSize></code> element. When a resource is validated against a
                constraint, the imaginary function consumes the constraint parameter values,
                inspects the resource and returns a validation result. If the constraint is
                violated, the validation result is a <code>&lt;gx:red></code> element which contains
                an optional message (either supplied by an attribute or constructed by the
                processor), along with a set of information items identifying the violating resource
                (@filePath), the constraint (@constraintComp and @constraintID) and its parameter
                values (@minCount). In the case of a <code>TargetMinCount</code> constraint, the
                violating resource is the folder providing the context when evaluating the target
                declaration. Example result:</para>
            <programlisting>
&lt;<emphasis role="bold">gx:red</emphasis> msg="No XSDs found"             
    filePath="C:/tt/greenfox/resources/example-system/system-s/resources/xsd"
    constraintComp="TargetMinCount" 
    constraintID="TargetSize_2-minCount" 
    resourceShapeID="xsdFileShape" 
    minCount="1" 
    actCount="0" 
    targetFoxpath="*.xsd"</programlisting>
            <para>In a second step we extend our schema with a folder shape whose target consists of
                    <emphasis role="ital">all testcase folders in the system</emphasis>:</para>
            <programlisting>&lt;!-- *** Testcase folder shape *** -->
&lt;<emphasis role="bold">folder</emphasis> foxpath="<emphasis role="bold">.\\test-*[input][output][config]</emphasis>" id="testcaseFolderShape">
  &lt;<emphasis role="bold">targetSize</emphasis> msg="No testcase folders found" minCount="1"
  
  &lt;!-- # Check - test folder content ok? -->
  &lt;<emphasis role="bold">folderContent</emphasis> 
       closedMsg="Testcase member(s) other than input/output/config, log-*." 
       closed="true">
    &lt;memberFolders names="input, output, config"/>
    &lt;memberFiles names="log-*" minCount="0" maxCount="*"/>
  &lt;/folderContent>
    …
&lt;/folder></programlisting>
            <para>The target includes all folders found at any depth under the current context
                folder (<code>system-s</code>), matching the name pattern <code>test-*</code> and
                having (at least) three members <code>input</code>, <code>output</code> and
                    <code>config</code>. The <code>TargetMinCount</code> constraint checks that the
                system contains at least one such folder. The <code>&lt;folderContent></code>
                element declares several constraints which are checked for each folder in the
                target, thus for each testcase folder. There must be three subfolders
                    <code>input</code>, <code>output</code> and <code>config</code>, and there may
                be any number of <code>log-*</code> elements. Any additional members are disallowed
                    (<code>FolderContentClosed</code> constraint).</para>
            <para>We proceed with a file shape which targets the <code>msg-config.csv</code> file in
                the <code>config</code> folder of the test case:</para>
            <programlisting>&lt;!-- *** msg config file shape *** -->
&lt;<emphasis role="bold">file</emphasis> foxpath="<emphasis role="bold">config\msg-config.csv</emphasis>" id="msgConfigFileShape" ...>
  &lt;targetSize msg="Config file missing" count="1"/>
  ...
&lt;/file></programlisting>
            <para>The <code>TargetCount</code> constraint makes this file mandatory, but we want to
                be more specific: to constrain the <emphasis role="ital">file contents</emphasis>.
                The file must be a CSV file, and the third column (which according to the header row
                is called <code>returnCode</code>) must contain a value which is <code>OK</code> or
                    <code>NOFIND</code> or matches the pattern <code>ERROR_*</code>. We add
                attributes to the <code>&lt;file></code> element which specify how to <emphasis
                    role="bold">parse the CSV file into an XML representation</emphasis>
                (@mediatype, @csv.separator, @csv.header). As with other non-XML mediatypes (e.g.
                JSON or HTML), an XML view enables us to leverage XPath and <emphasis role="ital"
                    >express</emphasis> a selection of content items, preparing the data material
                for meaningful and fine-grained validation. </para>
            <para>We add to the file shape an <code>&lt;xpath></code> element which describes a
                    <emphasis role="ital">selection</emphasis> of content items and defines a
                    <emphasis role="ital">constrait</emphasis> which these items must satisfy
                (expressed by the <code>&lt;in></code> child element): </para>
            <programlisting>&lt;!-- *** msg config file shape -->
&lt;<emphasis role="bold">file</emphasis> foxpath="config\msg-config.csv" id="msgConfigFileShape" 
      <emphasis role="bold">mediatype</emphasis>="csv" <emphasis role="bold">csv.separator</emphasis>="," <emphasis role="bold">csv.withHeader</emphasis>="yes">
  ...
  &lt;!-- # Check - configured return codes ok? -->
  &lt;<emphasis role="bold">xpath</emphasis> expr="<emphasis role="bold">//returnCode</emphasis>"
         inMsg="Config file contains unknown return code">
    &lt;<emphasis role="bold">in</emphasis>>
      &lt;eq>OK&lt;/eq>
      &lt;eq>NOFIND&lt;/eq>
      &lt;like>ERROR_*&lt;/like>
    &lt;/in>                                
  &lt;/xpath>                    
&lt;/file></programlisting>
            <para>The item selection is defined by an XPath expression (provided by @expr), and an
                    <code>XPathValueIn</code> constraint is specified by the <code>&lt;in></code>
                child element: an item must either be equal to one of the strings “OK” or “NOFIND”,
                or it must match the glob pattern “ERROR_*”. </para>
            <para>It is important to understand that the XPath expression is evaluated in the
                context of the <emphasis role="bold">document node</emphasis> of the document
                obtained by parsing the file. Here comes an example of a conformant message
                definition file:</para>
            <programlisting><![CDATA[request,response,returnCode
getFooRQ1.xml,getFooRS1.xml,OK
getFooRQ2.xml,getFooRS2.xml,NOFIND
getFooRQ3.xml,getFooRS3.xml,ERROR_SYSTEM]]></programlisting>
            <para>while this example violates the <code>XPathValueIn</code> constraint:</para>
            <programlisting><![CDATA[request,response,returnCode
getFooRQ1.xml,getFooRS1.xml,OK
getFooRQ2.xml,getFooRS2.xml,NOFIND
getFooRQ3.xml,getFooRS3.xml,ERROR-SYSTEM]]></programlisting>
            <para>According to the conceptual framework of greenfox, the <code>&lt;xpath></code>
                element does not, as one might expect, represent a constraint, but a <emphasis
                    role="bold">value shape</emphasis>. A value shape is a container combining a
                single <emphasis role="bold">value mapper</emphasis> with a set of constraints: the
                value mapper maps the focus resource to a value (“resource value”), which is
                validated against each one of the constraints. Greenfox supports two kinds of value
                mapper – XPath expression and foxpath expression, and accordingly there are two
                variants of a value shape – <emphasis role="bold">XPath value shape</emphasis>
                (represented by an <code>&lt;xpath></code> element) and <emphasis role="bold"
                    >Foxpath value shape</emphasis> (<code>&lt;foxpath></code>). See section “Schema
                building blocks” for detailed information about value shapes.</para>
            <para>Now we are going to check <emphasis role="ital">request message files</emphasis>:
                for each such file, there must be a response file in the <code>output</code> folder,
                with a name derived from the request file name (replacing the last occurrence of
                substring “RQ” with “RS”). This is a constraint which does not depend on file
                contents, but on file system contents found “around” the focus resource. A check
                requires navigation of the file system, rather than file contents. We solve the
                problem with a Foxpath value shape:</para>
            <programlisting><!-- *** Request file shape *** -->
&lt;<emphasis role="bold">file</emphasis> foxpath="input\(*.xml, *.json)" id="requestFileShape">
  ...
  &lt;!-- # Check - request with response ? -->
  &lt;<emphasis role="bold">foxpath</emphasis> expr="<emphasis role="bold">..\..\output\*\file-name(.)</emphasis>"
      <emphasis role="bold">containsXPath</emphasis>="$fileName ! 
                     replace(., '(.*)RQ(.*)$', '$1RS$2')"
      containsXPathMsg="Request without response"
  ...
&lt;file></programlisting>
            <para>A Foxpath value shape combines a foxpath expression (@expr) with a set of
                constraints. The expression maps the focus resource to a value, which is validated
                against all constraints. Here we have an expression which maps the focus resource to
                a list of file names found in the <code>output</code> folder. A single constraint,
                represented by the @containsXPath attribute, requires the expression value to
                contain the value of an XPath expression, which maps the request file name to the
                response file name. The constraint is satisfied if and only if the response file is
                present in the <code>output</code> folder.</para>
            <para>As with XPath value shapes, it is important to be aware of the evaluation context.
                We have already seen that in an XPath value shape the initial context item is the
                    <emphasis role="ital">document node</emphasis> obtained by parsing the text of
                the focus resource into an XML representation. In a Foxpath value shape the initial
                context item is the <emphasis role="ital">file path</emphasis> of the focus
                resource, which here is the file path of a request file. The foxpath expression
                starts with two steps along the parent axis (<code>..\..</code>) which lead to the
                enclosing <code>testcase</code> folder, from which navigation to the response files
                and their mapping to file names is trivial: </para>
            <programlisting><![CDATA[  ..\..\output\*\file-name(.)]]></programlisting>
            <para>A Foxpath value shape does not require the focus resource to be parsed into a
                document, as the context is a file path, rather than a document node. Therefore, a
                Foxpath value shape can also be used in a folder shape. We use this possibility in
                order to constrain the <code>codelists</code> folder to contain
                    <code>&lt;codelist></code> elements with a @name attribute and at least one
                    <code>&lt;entry></code> child:</para>
            <programlisting><!-- *** Codelist folder shape -->
&lt;<emphasis role="bold">folder</emphasis> foxpath=".\\resources\codelists" id="codelistFolderShape">
    ...
    &lt;!-- # Check - folder contains codelists? -->
    &lt;<emphasis role="bold">foxpath</emphasis> expr="<emphasis role="bold">*.xml/codelist[entry]/@name</emphasis>"  
             <emphasis role="bold">minCount</emphasis>="1"
             minCoutMsg="Codelist folder without codelists"
    ...
&lt;/folder></programlisting>
            <para>Note the aggregative view enabled by the foxpath language: we do not bother with
                individual files but perform a “mixed” navigation, starting with file system
                navigation to all *.xml files, continuing within their collected content (<code>…
                    /codelist[entry]/@name</code>), arriving at @name attributes on non-empty
                    <code>&lt;codelist></code> elements.</para>
            <para>Now we turn to the <emphasis role="ital">response message files</emphasis>. They
                must be “fresh”, that is, have a timestamp of last modification which is after a
                limit timestamp provided by a call parameter of the system validation. This is
                accomplised by a <code>LastModified</code> constraint, which references the
                parameter value. Besides, response files must not be empty (<code>FileSize</code>
                constraint):</para>
            <programlisting>&lt;!-- *** Response file shape *** -->                
&lt;<emphasis role="bold">file</emphasis> foxpath="output\(*.xml, *.json)" mediatype="xml-or-json">
    ...                    
    &lt;!-- # Check - response fresh? *** -->
    &lt;<emphasis role="bold">lastModified</emphasis> ge="${lastModified}"
                  geMsg="Stale output file"

    &lt;!-- # Check - response non-empty? *** -->
    &lt;<emphasis role="bold">fileSize</emphasis> gt="0" 
              gtMsg="Empty output file"
    ...
&lt;/file></programlisting>
            <para>The placeholder <code>${lastModified}</code> is substituted with the value passed
                to the greenfox processor as input parameter and declared in the schema as a
                    <emphasis role="ital">context parameter</emphasis>:</para>
            <programlisting>&lt;<emphasis role="bold">greenfox</emphasis> ... >
  &lt;!-- *** External context *** -->
  &lt;<emphasis role="bold">context</emphasis>>
    &lt;<emphasis role="bold">field</emphasis> name="lastModified"
  &lt;/context>    
  ...
&lt;/greenfox></programlisting>
            <para>We have several expecations related to the contents of response files. If the
                response is an XML document (rather than JSON), it must be valid valid against some
                XSD found in the XSD folder. XSD validation is triggered by an <code>XSDValid</code>
                constraint, with a foxpath expression locating the XSD(s) to be used:</para>
            <programlisting>&lt;!-- *** Response file shape *** -->                
&lt;<emphasis role="bold">file</emphasis> foxpath="output\(*.xml, *.json)" <emphasis role="bold">mediatype="xml-or-json</emphasis>">
    ...
    &lt;!-- # Check - schema valid? (only if XML) -->
    &lt;<emphasis role="bold">ifMediatype</emphasis> eq="xml">
        &lt;<emphasis role="bold">xsdValid</emphasis> msg="Response msg not XSD valid" 
                  xsdFoxpath="<emphasis role="bold">$domain\resources\xsd\\*.xsd</emphasis>"/>  
    &lt;/ifMediatype>
    ...
&lt;/file></programlisting>
            <para>It is not necessary to specify an individual XSD – the greenfox processor inspects
                all XSDs matching the expression and selects for each file to be validated the
                appropriate XSD. This is achieved by comparing name and namespace of the root
                element with local name and target namespace of all element declarations found in
                the XSDs selected by the foxpath expression. If not exactly one element declaration
                is found, an error is reported, otherwise XSD validation is performed. Note the
                variable reference <code>$domain</code>, which can be referenced in any XPath or
                foxpath expression and which provides the file path of the domain folder. </para>
            <para>The next condition to be checked is that certain values from the response
                (selected by XPath <code>//*:fooValue</code>) are found in a particular codelist.
                Here we use an XPath value shape with an <code>ExprValueEqFoxpath</code> constraint,
                represented by the @eqFoxpath attribute:</para>
            <programlisting>&lt;!-- *** Response file shape *** -->                
&lt;<emphasis role="bold">file</emphasis> foxpath="output\(*.xml, *.json)" <emphasis role="bold">mediatype="xml-or-json</emphasis>">
    ...
   &lt;!-- # Check - known article number? -->
   &lt;<emphasis role="bold">xpath</emphasis> expr="//*:fooValue"
          <emphasis role="bold">eqFoxpath</emphasis>="$domain\\codelists\*.xml
                     /codelist[@name eq 'foo-article']/entry/@code"
          eqFoxpathMsg="Unknown foo article number"/>
&lt;/file></programlisting>
            <para>As always with an XPath value shape, the XPath expression (@expr) selects the
                content items to be checked. The <code>ExprValueEqFoxpath</code> constraint works as
                follows: it evaluates the foxpath expression provided by constraint parameter
                    <code>eqFoxpath</code> and checks that every item of the value to be checked
                also occurs in the value of the foxpath expression. As here the foxpath expression
                returns all entries of the appropriate codelist, the constraint is satisfied if and
                only if every <code>fooValue</code> element in the response contains a string found
                in the codelist.</para>
            <para>Note that this value shape works properly for both, XML and JSON responses. Due to
                the @mediatype annotation on the file shape, which is set to
                    <code>xml-or-json</code>, the greenfox processor first attempts to parse the
                file as an XML document. If this does not succeed, it attempts to parse the file as
                a JSON document and transform it into an equivalent XML representation. In either
                case, the XPath expression is evaluated in the context of the document node of the
                resulting XDM node tree. In such cases one has to make sure, of course, that the
                XPath expression can be used in both structures, original XML and XML capturing the
                JSON content, which is the case in our example.</para>
            <para>As a last constraint, we want to check the return code of a response. The expected
                value can be retrieved from the message config file, a CSV file in the
                    <code>config</code> folder: it is the value found in the third column (named
                    <code>returnCode</code>) of the row in which the second column (named
                    <code>response</code>) contains the file name of the response file. We use a
                Foxpath value shape with an expression fetching the expected return value from the
                CSV file. This is accomplished by a mixed navigation, starting with file system
                navigation leading to the CSV file, then drilling down into the file and fetching
                the item of interest. The value against which to compare is retrieved by a trivial
                XPath expression (@eqXPath):</para>
            <programlisting>&lt;!-- *** Response file shape *** -->                
&lt;<emphasis role="bold">file</emphasis> foxpath="output\(*.xml, *.json)" mediatype="xml-or-json">
    ...
    &lt;!-- # Check - return code expected? *** -->
    &lt;<emphasis role="bold">foxpath</emphasis> expr="..\..\config\msg-config.csv\csv-doc(., ',', 'yes')
                   //record[response eq $fileName]/returnCode"
             <emphasis role="bold">eqXPath</emphasis>="//*:returnCode"
             eqXPathMsg="Return code not the configured value"                   
&lt;/file></programlisting>
            <para>The complete schema is shown in the appendix A1. To summarize, we have developed a
                schema which constrains the presence and contents of folders, the presence and
                contents of files, and relationships between contents of different files, in some
                cases belonging to different mediatypes. The development of the schema demanded
                familiarity with XPath, but no programming skills beyond that. </para>
        </section>
    </section>
    <section>
        <title>Basic principles</title>
        <para>The "Getting started" section has familiarized you with the basic building blocks and
            principles of greenfox schemas. They can be summarized as follows.</para>
        <itemizedlist spacing="compact">
            <listitem>
                <para>A file system is thought of as containing two kinds of resources, <emphasis
                        role="bold">folders</emphasis> and <emphasis role="bold"
                    >files</emphasis></para>
            </listitem>
            <listitem>
                <para>Resources are validated against <emphasis role="bold">resource
                        shapes</emphasis></para>
            </listitem>
            <listitem>
                <para>There are two kinds of resource shapes – <emphasis role="bold">folder
                        shapes</emphasis> and <emphasis role="bold">file shapes</emphasis></para>
            </listitem>
            <listitem>
                <para>A resource shape is a set of <emphasis role="bold">constraints</emphasis>
                    which apply to a resource being validated</para>
            </listitem>
            <listitem>
                <para>Every violation of a constraint produces a <emphasis role="bold">validation
                        result</emphasis> describing the violation and identifying resource and
                    constraint</para>
            </listitem>
            <listitem>
                <para>The resources validated against a shape are called its <emphasis role="bold"
                        >focus resources</emphasis></para>
            </listitem>
            <listitem>
                <para>A resource shape may have a <emphasis role="bold">target
                        declaration</emphasis> which selects a set of focus resources</para>
            </listitem>
            <listitem>
                <para>A target declaration of a resource shape can be a resource name, a relative
                    file path or a foxpath expression</para>
            </listitem>
            <listitem>
                <para>Constraints can apply to <emphasis role="bold">resource properties</emphasis>
                    like the last modification time or the file size</para>
            </listitem>
            <listitem>
                <para>Constraints can apply to a <emphasis role="bold">resource value</emphasis>,
                    which is a value to which the resource is mapped by an expression, or by a chain
                    of expression.</para>
            </listitem>
            <listitem>
                <para>A <emphasis role="bold">value shape</emphasis> combines an expression mapping
                    the focus resource to a resource value, or a resource value to another resource
                    value, and a set of constraints against which to validate the resource
                    value</para>
            </listitem>
            <listitem>
                <para>The expression used by a value shape may be an <emphasis role="bold">XPath
                        expression</emphasis> or a <emphasis role="bold">foxpath
                        expression</emphasis></para>
            </listitem>
            <listitem>
                <para>The <emphasis role="bold">foxpath context item</emphasis> used by a value
                    shape mapping a focus resource to a resource value is the file path of the focus
                    resource. The foxpath context item used by a value shape mapping a preceding
                    resource value to another resource value is a single item of the preceding
                    resource value. </para>
            </listitem>
            <listitem>
                <para>The <emphasis role="bold">XPath context item</emphasis> used by a value shape
                    mapping a focus resource to a resource value is the root of an XDM node tree
                    representing the content of the focus resource, or the file path of the focus
                    resource if an XDM node tree could not be constructed. The XPath context item
                    used by a value shape mapping a preceding resource value to another resource
                    value is a single item of the preceding resource value.</para>
            </listitem>
            <listitem>
                <para><emphasis role="bold">XDM node tree representations</emphasis> of file
                    resources can be controlled by mediatype related attributes on a file
                    shape</para>
            </listitem>
            <listitem>
                <para>When validating resources against resource shapes, the heterogeneity of
                    mediatypes can be hidden by a <emphasis role="bold">unified representation as
                        XDM node trees</emphasis></para>
            </listitem>
            <listitem>
                <para>When validating resources against resource shapes, the heterogeneity of
                    navigation (within resource contents and between resources) can be hidden by a
                        <emphasis role="bold">unified navigation language</emphasis>
                    (foxpath)</para>
            </listitem>
        </itemizedlist>

    </section>
    <section>
        <title>Information model</title>
        <para>This section describes the information model underlying the operations of
            greenfox.</para>
        <section>
            <title>Part 1: resource model</title>
            <para>A <emphasis role="bold">file system tree</emphasis> is a tree whose nodes are file
                system resources – folders and files.</para>
            <para>A <emphasis role="bold">file system resource</emphasis> has an identity, resource
                properties, derived resource properties and resource values.</para>
            <para>The <emphasis role="bold">resource identity</emphasis> of a file system resource
                can be expressed by a combination of file system identity and a file path locating
                the resource within the file system.</para>
            <para>A <emphasis role="bold">resource property</emphasis> has a name and a value which
                can be represented by an XDM value.</para>
            <para>A <emphasis role="bold">derived resource property</emphasis> is a property of a
                resource property value, or of a derived resource property value, which can be
                represented by an XDM value.</para>
            <para>A <emphasis role="bold">resource value</emphasis> is the XDM value of an
                expression evaluated in the context of a resource property, or of a derived resource
                property, or of a resource value.</para>
            <section>
                <title>Folder resources</title>
                <para>The table below summarizes the <emphasis role="bold">resource
                        properties</emphasis> of a folder resource, as currently evaluated by
                    greenfox. More properties may be added in the future, e.g. representing access
                    rights.</para>
                <table xml:id="table-102">
                    <title>Resource properties of a folder resource.</title>
                    <titleabbrev xml:id="table-102-shorttitle">Folder resource
                        properties</titleabbrev>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="3*"/>
                        <colspec colname="c2" colnum="2" colwidth="4*"/>
                        <colspec colname="c3" colnum="3" colwidth="11*"/>
                        <thead>
                            <row>
                                <entry align="left">Property name</entry>
                                <entry align="left">Value type</entry>
                                <entry align="left">Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry align="left">[name]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">The folder name; optional – the file system root
                                    folder does not have a name</entry>
                            </row>
                            <row>
                                <entry align="left">[parent]</entry>
                                <entry align="left">Folder resource</entry>
                                <entry align="left">The XDM representation of resource identity is
                                    its file path</entry>
                            </row>
                            <row>
                                <entry align="left">[children]</entry>
                                <entry align="left">Folder and file resources</entry>
                                <entry align="left">The XDM representation of resource identity is
                                    its file path</entry>
                            </row>
                            <row>
                                <entry align="left">[last-modified]</entry>
                                <entry align="left"><code>xsd:dateTime</code></entry>
                                <entry align="left">May be out of sync when comparing values of
                                    resources from different machines</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para>A folder has the following <emphasis role="bold">derived resource
                        properties</emphasis>.</para>
                <table xml:id="table-103">
                    <title>Derived resource properties of a folder resource.</title>
                    <titleabbrev xml:id="table-103-shorttitle">Derived folder resource
                        properties</titleabbrev>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="3*"/>
                        <colspec colname="c2" colnum="2" colwidth="4*"/>
                        <colspec colname="c3" colnum="3" colwidth="11*"/>
                        <thead>
                            <row>
                                <entry align="left">Property name</entry>
                                <entry align="left">Value type</entry>
                                <entry align="left">Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry align="left">[filepath]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">The names of all ancestor folders and the folder
                                    itself, separated by a slash</entry>
                            </row>
                            <row>
                                <entry align="left">[foxpath-value]</entry>
                                <entry align="left">Mapping: foxpath expression string => XDM value </entry>
                                <entry align="left">A mapping of foxpath expressions to an XDM
                                    value, which is the value obtained by evaluating the expression
                                    in the context of the resource folder’s [filepath] value</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para><emphasis role="bold">Resource values</emphasis> are obtained by applying
                    [foxpath-value] to the text of a foxpath expression.</para>
            </section>
            <section>
                <title>File resources</title>
                <para>A file has the following <emphasis role="bold">resource properties</emphasis>,
                    as currently evaluated by greenfox.</para>
                <table xml:id="table-104">
                    <title>Resource properties of a file resource.</title>
                    <titleabbrev xml:id="table-104-shorttitle">File resource
                        properties</titleabbrev>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="3*"/>
                        <colspec colname="c2" colnum="2" colwidth="4*"/>
                        <colspec colname="c3" colnum="3" colwidth="11*"/>
                        <thead>
                            <row>
                                <entry align="left">Property name</entry>
                                <entry align="left">Value type</entry>
                                <entry align="left">Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry align="left">[name]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">Mandatory – a file must have a name</entry>
                            </row>
                            <row>
                                <entry align="left">[parent]</entry>
                                <entry align="left">Folder resource</entry>
                                <entry align="left">The XDM representation of resource identity is
                                    its file path</entry>
                            </row>
                            <row>
                                <entry align="left">[last-modified]</entry>
                                <entry align="left"><code>xsd:dateTime</code></entry>
                                <entry align="left">May be out of sync when comparing values of
                                    resources from different machines</entry>
                            </row>
                            <row>
                                <entry align="left">[size]</entry>
                                <entry align="left"><code>xsd:integer</code></entry>
                                <entry align="left">File size, in bytes</entry>
                            </row>
                            <row>
                                <entry align="left">[sha1]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">SHA-1 hash value of file contents</entry>
                            </row>
                            <row>
                                <entry align="left">[sha256]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">SHA-256 hash value of file contents</entry>
                            </row>
                            <row>
                                <entry align="left">[md5]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">MD5 hash value of file contents</entry>
                            </row>

                            <row>
                                <entry align="left">[text]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">The text content of the file (empty if not a
                                    text file)</entry>
                            </row>
                            <row>
                                <entry align="left">[encoding]</entry>
                                <entry align="left"><code>xsd:anyURI</code></entry>
                                <entry align="left">The encoding of the text content of the file
                                    (empty if not a text file)</entry>
                            </row>
                            <row>
                                <entry align="left">[octets]</entry>
                                <entry align="left"><code>xsd:base64Binary</code></entry>
                                <entry align="left">The binary file content</entry>
                            </row>
                            <row>
                                <entry align="left">[xmldoc]</entry>
                                <entry align="left"><code>document-node()</code></entry>
                                <entry align="left">The result of parsing [text] into an XML
                                    document</entry>
                            </row>
                            <row>
                                <entry align="left">[jsondoc-basex]</entry>
                                <entry align="left"><code>document-node()</code></entry>
                                <entry align="left">The result of parsing [text] into a JSON
                                    document represented by a document-node in accordance with the
                                    rules defined by BaseX documentation</entry>
                            </row>
                            <row>
                                <entry align="left">[jsondoc-w3c]</entry>
                                <entry align="left"><code>document-node()</code></entry>
                                <entry align="left">The result of parsing [text] into a JSON
                                    document represented by a document-node in accordance with XPath
                                    function <code>fn:json-to-xml</code></entry>
                            </row>
                            <row>
                                <entry align="left">[htmldoc]</entry>
                                <entry align="left"><code>document-node()</code></entry>
                                <entry align="left">The result of parsing [text] into an XML
                                    document represented by a document-node in accordance with the
                                    rules defined by TagSoup documentation</entry>
                            </row>
                            <row>
                                <entry align="left">[csvdoc]</entry>
                                <entry align="left"><code>document-node()</code></entry>
                                <entry align="left">The result of parsing [text] into an XML
                                    document represented by a document-node, as controlled by the
                                    CSV parsing parameter values derived from a file shape, in
                                    accordance with the rules defined by BaseX documentation
                                </entry>
                            </row>
                            <row>
                                <entry align="left">[csvdocs]</entry>
                                <entry align="left">Mapping: csv-parse-parameters => document-node() </entry>
                                <entry align="left">The mapping result is a CSV document represented
                                    by a document-node as controlled by given CSV parsing parameter
                                    values, in accordance with the rules defined by BaseX
                                    documentation </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para>A file has the following <emphasis role="bold">derived resource
                        properties</emphasis>, as currently evaluated by greenfox.</para>
                <table xml:id="table-105">
                    <title>Derived resource properties of a file resource.</title>
                    <titleabbrev xml:id="table-105-shorttitle">Derived folder resource
                        properties</titleabbrev>
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1" colwidth="5*"/>
                        <colspec colname="c2" colnum="2" colwidth="5*"/>
                        <colspec colname="c3" colnum="3" colwidth="11*"/>
                        <thead>
                            <row>
                                <entry align="left">Property name</entry>
                                <entry align="left">Value type</entry>
                                <entry align="left">Description</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry align="left">[filepath]</entry>
                                <entry align="left"><code>xsd:string</code></entry>
                                <entry align="left">The names of all ancestor folders and the folder
                                    itself, separated by a slash</entry>
                            </row>
                            <row>
                                <entry align="left">[xmldoc.xpath]</entry>
                                <entry align="left">Mapping: XPath expression string => XDM value </entry>
                                <entry align="left">A mapping of XPath expressions to an XDM value,
                                    which is the value obtained by evaluating the expression in the
                                    context of [xmldoc]</entry>
                            </row>
                            <row>
                                <entry align="left">[jsondoc-basex.xpath]</entry>
                                <entry align="left">Mapping: XPath expression string => XDM value </entry>
                                <entry align="left">A mapping of XPath expressions to an XDM value,
                                    which is the value obtained by evaluating the expression in the
                                    context of [jsondoc-basex]</entry>
                            </row>
                            <row>
                                <entry align="left">[jsondoc-w3c.xpath]</entry>
                                <entry align="left">Mapping: XPath expression string => XDM value </entry>
                                <entry align="left">A mapping of XPath expressions to an XDM value,
                                    which is the value obtained by evaluating the expression in the
                                    context of [jsondoc-w3c]</entry>
                            </row>
                            <row>
                                <entry align="left">[htmldoc.xpath]</entry>
                                <entry align="left">Mapping: XPath expression string => XDM value </entry>
                                <entry align="left">A mapping of XPath expressions to an XDM value,
                                    which is the value obtained by evaluating the expression in the
                                    context of [htmldoc]</entry>
                            </row>
                            <row>
                                <entry align="left">[csvdoc.xpath]</entry>
                                <entry align="left">Mapping: ( csv-parse-parameters, XPath
                                    expression string ) => XDM value </entry>
                                <entry align="left">A mapping of CSV parsing parameter values and an
                                    XPath expression to an XDM value, which is the value obtained by
                                    evaluating the expression in the context of a document node from
                                    [csv-docs], obtained for the parsing parameter values</entry>
                            </row>
                            <row>
                                <entry align="left">[foxpath-value]</entry>
                                <entry align="left">Mapping: foxpath expression string => XDM value </entry>
                                <entry align="left">A mapping of foxpath expressions to an XDM
                                    value, which is the value obtained by evaluating the expression
                                    in the context of [filepath]</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para><emphasis role="bold">Resource values</emphasis> are obtained by applying
                    [foxpath-value] to the text of a foxpath expression, or one of the mappings
                    [*-xpath] to the text of an XPath expression.</para>
                <para>For information about CSV parsing parameters, see [x], section
                        <code>#wiki/CSV_Module</code>.</para>
            </section>
        </section>
        <section>
            <title>Part 2: schema model</title>
            <para>File system validation is a mapping of a file system tree and a greenfox schema to
                a set of greenfox validation results.</para>
            <para>A <emphasis role="bold">greenfox schema</emphasis> is a set of shapes.</para>
            <para>A <emphasis role="bold">shape</emphasis> is a resource shape or a value
                shape.</para>
            <para>A <emphasis role="bold">resource shape</emphasis> is a set of constraints
                applicable to a file system resource. It has an optional target declaration.</para>
            <para>A <emphasis role="bold">target declaration</emphasis> specifies the selection of a
                target.</para>
            <para>A <emphasis role="bold">target</emphasis> is a set of focus resources, or a focus
                value.</para>
            <para>A <emphasis role="bold">focus resource</emphasis> is a resource to be validated
                against a resource shape.</para>
            <para>A <emphasis role="bold">focus value</emphasis> is a resource value to be validated
                against a value shape.</para>
            <para>A resource shape is a <emphasis role="bold">folder shape</emphasis> or a <emphasis
                    role="bold">file shape</emphasis>.</para>
            <para>A <emphasis role="bold">value shape</emphasis> is a mapping of a focus resource,
                or of a resource value, to a resource value and a set of constraints.</para>
            <para>A <emphasis role="bold">constraint</emphasis> maps a resource property or a
                resource value to a validation result.</para>
            <para>A constraint is declared by a shape. It identifies a constraint component and
                assigns values to the constraint parameters.</para>
            <para>A <emphasis role="bold">constraint component</emphasis> is a set of constraint
                parameter definitions and a validator.</para>
            <para>A <emphasis role="bold">constraint parameter</emphasis> is defined by the
                specification of a constraint component. The definition includes a name, a type, the
                value semantics and whether the parameter is mandatory or optional.</para>
            <para>A <emphasis role="bold">validator</emphasis> is a set of rules how a resource
                property or a resource value and the arguments bound to the constraint parameters
                are mapped to a validation result.</para>
            <para>A <emphasis role="bold">validation result</emphasis> is a boolean value signaling
                conformance of a resource property or a resource value against a constraint,
                accompanied by additional information identifying the resource and the constraint,
                as well as further items of information with names and semantics as prescribed by
                the constraint component.</para>
        </section>
        <section>
            <title>Part 3: validation model</title>
            <para><emphasis role="bold">File system validation</emphasis> is a mapping of a
                    <emphasis role="underline">file system tree</emphasis> and a <emphasis
                    role="underline">greenfox schema</emphasis> to a set of <emphasis
                    role="underline">validation result</emphasis>s, as defined in the following
                paragraphs.</para>
            <para><emphasis role="bold">Validation of a file system tree against a greenfox
                    schema</emphasis>: Given a <emphasis role="underline">file system
                    tree</emphasis> and a <emphasis role="underline">greenfox schema</emphasis>, the
                    <emphasis role="underline">validation result</emphasis>s are the union of
                results of the validation of the <emphasis role="underline">file system
                    tree</emphasis> against all <emphasis role="underline">shape</emphasis>s in the
                    <emphasis role="underline">greenfox schema</emphasis>. </para>
            <para><emphasis role="bold">Validation of a file system tree against a shape</emphasis>:
                Given a <emphasis role="underline">file system tree</emphasis> and a <emphasis
                    role="underline">shape</emphasis> in the <emphasis role="underline">greenfox
                    schema</emphasis>, the <emphasis role="underline">validation result</emphasis>s
                are the union of the results of the validation of all <emphasis role="underline"
                    >focus resource</emphasis>s that are in the <emphasis role="underline"
                    >target</emphasis> of the <emphasis role="underline">shape</emphasis>. </para>
            <para><emphasis role="bold">Validation of a resource against a shape</emphasis>: Given a
                    <emphasis role="underline">focus resource</emphasis> in the <emphasis
                    role="underline">file system tree</emphasis> and a <emphasis role="underline"
                    >shape</emphasis> in the <emphasis role="underline">greenfox schema</emphasis>,
                the <emphasis role="underline">validation result</emphasis>s are the union of the
                results of the validation of the <emphasis role="underline">focus
                    resource</emphasis> against all <emphasis role="underline"
                >constraint</emphasis>s declared by the <emphasis role="underline">shape</emphasis>,
                unless the <emphasis role="underline">shape</emphasis> has been deactivated, in
                which case the <emphasis role="underline">validation result</emphasis>s are empty. </para>
            <para><emphasis role="bold">Validation of a focus resource against a
                    constraint</emphasis>: Given a <emphasis role="underline">focus
                    resource</emphasis> in the <emphasis role="underline">file system
                    tree</emphasis> and a <emphasis role="underline">constraint</emphasis> of kind C
                in the <emphasis role="underline">greenfox schema</emphasis>, the <emphasis
                    role="underline">validation result</emphasis>s are defined by the <emphasis
                    role="underline">validator</emphasis> of the <emphasis role="underline"
                    >constraint component</emphasis> C. The <emphasis role="underline"
                    >validator</emphasis> typically takes as input a <emphasis role="underline"
                    >resource property</emphasis> or a <emphasis role="underline">resource
                    value</emphasis> of the <emphasis role="underline">focus resource</emphasis> and
                the arguments supplied to the <emphasis role="underline">constraint
                    parameter</emphasis>s. </para>
        </section>
    </section>
    <section>
        <title>Schema building blocks</title>
        <para>This section summarizes the <emphasis role="bold">building blocks</emphasis> of a
            greenfox schema. Building blocks are the parts of which a serialized schema is composed.
            The serialized schema should be distinguished from the logical schema, which is
            independent of a serialization and can be defined as a set of logical components (as
            defined by the information model) and parameter bindings. </para>
        <para>Each building block is represented by XML elements with a particular name. Note that
            there need not be a one-to-one correspondence between building blocks and logical
            components as defined by the information model. An Import declaration, for example, is a
            building block without corresponding logical component. Constraints, on the other hand,
            are logical components which in many cases are not represented by a separate building
            block, but by attributes attached to a building block. Note also that the information
            model includes logical components built into the greenfox language and without
            representation in any given schema (e.g. validators).</para>
        <table xml:id="table-201">
            <title>The building blocks of a greenfox schema.</title>
            <titleabbrev xml:id="table-201-shorttitle">Greenfox building blocks</titleabbrev>
            <tgroup cols="3">
                <colspec colname="c1" colnum="1" colwidth="4*"/>
                <colspec colname="c2" colnum="2" colwidth="11*"/>
                <colspec colname="c3" colnum="3" colwidth="5*"/>
                <thead>
                    <row>
                        <entry align="left">Building block</entry>
                        <entry align="left">Role</entry>
                        <entry align="left">XML representation</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left">Import declaration</entry>
                        <entry align="left">Declares the import of another greenfox schema so that
                            its contents are included in the current schema</entry>
                        <entry align="left"><code>gx:import</code></entry>
                    </row>
                    <row>
                        <entry align="left">Context declaration</entry>
                        <entry align="left">Declares external schema variables, the values of which
                            can be supplied by the agent launching the validation. Each variable is
                            represented by a <code>gx:field</code> child element.</entry>
                        <entry align="left"><code>gx:context</code></entry>
                    </row>
                    <row>
                        <entry align="left">Shapes library</entry>
                        <entry align="left">A collection of shapes without target declaration, which
                            can be referenced by other shapes</entry>
                        <entry align="left"><code>gx:shapes</code></entry>
                    </row>
                    <row>
                        <entry align="left">Constraints library</entry>
                        <entry align="left">A collection of constraint declaration nodes, which can
                            be referenced by shapes</entry>
                        <entry align="left"><code>gx:constraints</code></entry>
                    </row>
                    <row>
                        <entry align="left">Constraint components library</entry>
                        <entry align="left">A collection of constraint component definitions, for
                            which constraints can be declared</entry>
                        <entry align="left"><code>gx:contraint-Components/*</code></entry>
                    </row>
                    <row>
                        <entry align="left">Constraint component definition</entry>
                        <entry align="left">A user-defined constraint component. It declares the
                            constraint parameters and provides a validator. Parameters are
                            represented by <code>gx:param</code> child elements, the validator by a
                                <code>gx:xpath</code> or <code>gx:foxpath</code> child
                            element</entry>
                        <entry align="left"><code>gx:constraint-Component</code></entry>
                    </row>
                    <row>
                        <entry align="left">Domain</entry>
                        <entry align="left">A container element wrapping the shapes used for
                            validating a particular file system tree, identified by its root
                            folder</entry>
                        <entry align="left"><code>gx:domain</code></entry>
                    </row>
                    <row>
                        <entry align="left">Resource shapes</entry>
                        <entry align="left">A shape applicable to a file system folder or
                            file</entry>
                        <entry align="left">
                            <para><code>gx:folder</code></para>
                            <para><code>gx:file</code></para>
                        </entry>
                    </row>
                    <row>
                        <entry align="left">Value shape</entry>
                        <entry align="left">A shape applicable to a resource value</entry>
                        <entry align="left">
                            <para><code>gx:xpath</code></para>
                            <para><code>gx:foxpath</code></para>
                            <para><code>gx:focusNode</code></para>
                        </entry>
                    </row>
                    <row>
                        <entry align="left">Base shape declaration</entry>
                        <entry align="left">References a shape so that its contents are included in
                            the shape containing the reference</entry>
                        <entry align="left"><code>gx:baseShape</code></entry>
                    </row>
                    <row>
                        <entry align="left">Constraint declaration node</entry>
                        <entry align="left">An element representing one or several constraints
                            declared by a shape. Constraint parameters are represented by attributes
                            and/or child elements</entry>
                        <entry align="left">
                            <para><code>gx:targetSize</code></para>
                            <para><code>gx:folderContent</code></para>
                            <para><code>gx:mediaType</code></para>
                            <para><code>gx:fileSize</code></para>
                            <para><code>gx:lastModified</code></para>
                            <para><code>gx:name</code></para>
                            <para><code>gx:hashCode</code></para>
                        </entry>
                    </row>
                    <row>
                        <entry align="left">Conditional node</entry>
                        <entry align="left">A set of building blocks associated with a condition, so
                            that the building blocks are only used if the condition is met</entry>
                        <entry align="left"><code>gx:ifMediatype</code></entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
    </section>
    <section>
        <title>Schema language extension</title>
        <para>This section describes <emphasis role="bold">user-defined constraint
                components</emphasis>. Such components are defined within a greenfox schema by a
                <code>gx:constraintComponent</code> element, which specifies the constraint
            component name, declares the constraint parameters and provides an implementation. The
            implementation is an XPath or a foxpath expression, which accesses the parameter values
            as pre-bound variables. User-defined constraint components are used like built-in
            components: a constraint is declared by an element with attributes (or child elements)
            providing the parameter values and optional messages.</para>
        <para>As an illustrative example, consider the creation of a new constraint component
            characterized as follows.</para>
        <para><emphasis role="bold">Constraint component IRI</emphasis>: <code>ex:grep</code></para>
        <para><emphasis role="bold">Constraint parameters</emphasis>:</para>
        <informaltable xml:id="table-301">
            <tgroup cols="5">
                <colspec colname="c1" colnum="1" colwidth="5*"/>
                <colspec colname="c2" colnum="2" colwidth="10*"/>
                <colspec colname="c3" colnum="3" colwidth="10*"/>
                <colspec colname="c4" colnum="4" colwidth="10*"/>
                <colspec colname="c5" colnum="5" colwidth="10*"/>
                <thead>
                    <row>
                        <entry align="left">Name</entry>
                        <entry align="left">Type</entry>
                        <entry align="left">Meaning</entry>
                        <entry align="left">Mandatory?</entry>
                        <entry align="left">Default value</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left">regex</entry>
                        <entry align="left"><code>xsd:string</code></entry>
                        <entry align="left">A regular expression</entry>
                        <entry>+</entry>
                        <entry>-</entry>
                    </row>
                    <row>
                        <entry align="left">flags</entry>
                        <entry align="left"><code>xsd:string</code></entry>
                        <entry align="left">Evaluation flags</entry>
                        <entry>-</entry>
                        <entry>Zero-length string</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        <para><emphasis role="bold">Semantics</emphasis>:</para>
        <para>"A constraint is satisfied if the focus resource is a text file containing a line
            matching regular expression <code>$regex</code>, as controlled by the regex evaluation
                <code>flags</code> given by $flags (e.g. case-insensitively)"</para>
        <para>The <emphasis role="bold">implementation</emphasis> may be provided by the following
            element, which must be a child element of <code>gx:constraintComponents</code>:</para>
        <programlisting>&lt;<emphasis role="bold">constraintComponent</emphasis> constraintElementName="<emphasis role="bold">ex:grep</emphasis>">
    &lt;param name="<emphasis role="bold">pattern</emphasis>" type="xs:string"/>
    &lt;param name="<emphasis role="bold">flags</emphasis>" type="xs:string?"/>
    &lt;<emphasis role="bold">xpathExpr</emphasis>>
        <emphasis role="ital">exists(unparsed-text-lines(.)[matches(., $pattern, $flags)])</emphasis>
    &lt;/xpathExpr>
&lt;/constraintComponent>
</programlisting>
        <para>The constraint can be used like this:</para>
        <programlisting>&lt;<emphasis role="bold">ex:grep </emphasis><emphasis role="bold">pattern</emphasis>="fbIx?" <emphasis role="bold">flags</emphasis>="i"
         msg="File does not contain string '$pattern'."
         msgOK="File contains string '$pattern'."/></programlisting>
        <para>Note the variable references in the message text, which are replaced by parameter
            values.</para>
    </section>
    <section>
        <title>Validation results</title>
        <para>This section describes the results produced by a greenfox validation.</para>
        <section>
            <title>Validation reports and representations</title>
            <para>The primary result of a greenfox validation is an RDF graph called the <emphasis
                    role="bold">white validation report</emphasis>. This is mapped to the <emphasis
                    role="bold">red validation report</emphasis>, an RDF graph obtained by removing
                from a white report all triples not related to constraint violations. For red and
                white validation reports a <emphasis role="bold">canonical XML
                    representation</emphasis> is defined. Apart from that there are <emphasis
                    role="bold">derived representations</emphasis>, implementation-dependent reports
                which may use any data model and mediatype.</para>
            <para>The <emphasis role="bold">white validation report</emphasis> is an RDF graph with
                exactly one instance of <code>gx:ValidationReport</code>. The instance has the
                following properties:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para><code>gx:conforms</code>, with an <code>xsd:boolean</code> value
                        indicating conformance</para>
                </listitem>
                <listitem>
                    <para><code>gx:result</code>, with one value ...</para>
                    <itemizedlist spacing="compact">
                        <listitem>
                            <para>for each constraint violation (“red and yellow values”)</para>
                        </listitem>
                        <listitem>
                            <para>for each constraint check which did not produce a violation
                                (“green values”)</para>
                        </listitem>
                        <listitem>
                            <para>for each observation, which is a result triggered by a value shape
                                in order to record a resource value not related to constraint
                                checking (“blue values”)</para>
                        </listitem>
                    </itemizedlist>
                </listitem>
            </itemizedlist>
            <para>The <emphasis role="bold">red validation report</emphasis> is an RDF graph
                obtained by removing from the white validation report all green and blue result
                values. Note that the validation report defined by the SHACL language [x]
                corresponds to the red validation report defined by greenfox.</para>
            <para>The <emphasis role="bold">canonical XML representation</emphasis> of a white or
                red validation report is an XML document with a
                    <code>&lt;gx:validationReport></code> root element, which has for each
                    <code>gx:result</code> value from the RDF graph one child element, which is a
                    <code>&lt;gx:red></code>, <code>&lt;gx:yellow></code>,
                    <code>&lt;gx:green></code> or <code>&lt;gx:blue></code> element, according to
                the <code>gx:result/gx:severity</code> property value being
                    <code>gx:Violation</code>, <code>gx:Warning</code>, <code>gx:Info</code> or
                    <code>gx:Observation</code>). </para>
            <para>A <emphasis role="bold">derived representation</emphasis> is any kind of data
                structure, using any mediatype, representing information content from the white or
                red validation report in an implementation-defined way.</para>
        </section>
        <section>
            <title>Validation result</title>
            <para>A <emphasis role="bold">validation result</emphasis> is a unit of information
                which describes the outcome of validating a focus resource against a constraint:
                either constraint violation (“red” or “yellow” result), or conformance (“green”
                result).</para>
            <para>A validation result is an RDF resource with several properties as described below.
                Key features of the result model:</para>
            <itemizedlist spacing="compact">
                <listitem>
                    <para>Every result is related to an individual file system resource (file or
                        folder)</para>
                </listitem>
                <listitem>
                    <para>Every result is related to an individual constraint (and, by implication,
                        a shape)</para>
                </listitem>
            </itemizedlist>
            <para>This allows for meaningfull aggregation by resource, by constraint and by shape
                and, by implication, any combination of aggregated resources, constraints and
                shapes. Such aggregation may, for example, be useful for integrating validation
                results into a graphical representation of the file system and for analysis of
                impact.</para>
            <para>A detailed description of the validation result model – RDF properties, SHACL
                equivalent and XML representation – is found in appendix A3.</para>
        </section>
    </section>
    <section>
        <title>Implementation</title>
        <para>An implementation of a greenfox processor is available on github [x]. The processor is
            provided as a command line tool (<code>greenfox.bat</code>, <code>greenfox.sh</code>).
            Example call:</para>
        <programlisting>greenfox "val?gfox=/projects/greenfox/examples/gfox-system-s.xml,
      domain=/projects/greenfox/examples/system-s"</programlisting>
        <para>The implementation is written in XQuery and requires the use of the BaseX [x] XQuery
            processor. </para>
    </section>
    <section>
        <title>Discussion</title>
        <para>To be added.</para>
    </section>


    <appendix xml:id="appendix-greenfox-schema-s1">
        <title>Appendix A1: greenfox schema for system S</title>
        <para>This appendix lists the complete schema developed in section “Getting started with
            greenfox”.</para>
        <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<greenfox greenfoxURI="http://www.greenfox.org/ns/schema-examples/system-s"
    xmlns="http://www.greenfox.org/ns/schema">

    <!-- *** External context *** -->
    <context>
        <field name="lastModified" value="2019-12-01"/>
    </context>

    <!-- *** System file tree *** -->
    <domain path="\tt\greenfox\resources\example-system\system-s" name="system-s">

        <!-- *** System root folder shape *** -->
        <folder foxpath="." id="systemRootFolderShape">
            <!-- *** XSD folder shape *** -->
            <folder foxpath=".\\resources\xsd" id="xsdFolderShape">
                <targetSize countMsg="No XSD folder found" count="1"/>
                <file foxpath="*.xsd" id="xsdFileShape">
                    <targetSize minCountMsg="No XSDs found" minCount="1"/>
                </file>
            </folder>

            <!-- *** Codelist folder shape *** -->
            <folder foxpath=".\\resources\codelists" id="codelistFolderShape">
                <targetSize countMsg="No codelist folder found" count="1"/>

                <!-- # Check - folder contains codelists? -->
                <foxpath 
                    expr="*.xml/codelist[entry/@code[string()]]/@name"
                    minCount="1"
                    minCountMsg="Codelist folder without codelists"/>
                <file foxpath="*[is-xml(.)]" id="codelistFileShape">
                    <targetSize minCountMsg="No codelist files found" minCount="1"/>
                </file>
            </folder>

            <!-- *** Testcase folder shape *** -->
            <folder foxpath=".\\test-*[input][output][config]" id="testcaseFolderShape">
                <targetSize minCountMsg="No testcase folders found" minCount="1"/>
                <!-- # Check - test folder content ok? -->
                <folderContent
                    closedMsg="Testcase contains member other than input, output, config, log-*."
                    closed="true">
                    <memberFolders names="input, output, config"/>
                    <memberFiles names="log-*" count="*"/>
                </folderContent>

                <!-- *** msg config shape *** -->
                <file foxpath="config\msg-config.csv" id="msgConfigFileShape"
                      mediatype="csv" csv.separator="," csv.withHeader="yes">
                    <targetSize countMsg="Config file missing" count="1"/>

                    <!-- # Check - configured return codes expected? -->
                    <xpath expr="//returnCode" 
                           inMsg="Config file contains unknown return code">
                        <in>
                            <eq>OK</eq>
                            <eq>NOFIND</eq>
                            <like>ERROR_*</like>
                        </in>
                    </xpath>
                </file>

                <!-- *** Request file shape *** -->
                <file foxpath="input\(*.xml, *.json)" id="requestFileShape">
                    <targetSize minCountMsg="Input folder without request msgs" minCount="1"/>

                        <!-- # Check - request with response? -->
                    <foxpath 
                        expr="..\..\output\*\file-name(.)"
                        containsXPath="$fileName ! replace(., '(.*)RQ(.*)$', '$1RS$2')"
                        containsXPathMsg="Request without response"/>
                </file>

                <!-- *** Response file shape *** -->
                <file foxpath="output\(*.xml, *.json)" id="responseFileShape"
                      mediatype="xml-or-json">
                    <targetSize minCountMsg="Output folder without request msgs" minCount="1"/>

                    <!-- # Check - response fresh? -->
                    <lastModified geMsg="Stale output file" ge="${lastModified}"/>

                    <!-- # Check - response non-empty? -->
                    <fileSize gtMsg="Empty output file" gt="0"/>

                    <!-- # Check - schema valid? (only if XML) -->
                    <ifMediatype eq="xml">
                        <xsdValid xsdFoxpath="$domain\resources\xsd\\*.xsd"
                                  msg="Response msg not XSD valid"/>
                                  
                    </ifMediatype>

                    <!-- # Check - known article number? -->
                    <xpath 
                        expr="//*:fooValue"
                        eqFoxpath="$domain\\codelists\*.xml/codelist[@name eq 'foo-article']/entry/@code"
                        eqFoxpathMsg="Unknown foo article number" id="articleNumberValueShape"/>

                    <!-- # Check - return code ok? -->
                    <foxpath 
                        expr="..\..\config\msg-config.csv\csv-doc(., ',', 'yes')
                              //record[response eq $fileName]/returnCode"
                        eqXPath="//*:returnCode"                                   
                        eqXPathMsg="Return code not the configured value"/>                                   
    
                </file>

            </folder>
        </folder>
    </domain>
</greenfox>]]></programlisting>
    </appendix>
    <appendix xml:id="appendix-alignment-greenfox-shacl">
        <title>Appendix A2: Alignment of key concepts between greenfox and SHACL</title>
        <para>This appendix summarizes the conceptual alignment between greenfox and SHACL. The
            striking correspondence reflects our decision to use SHACL as a blueprint for the
            conceptual framework underlying the greenfox language. Greenfox can be thought of as a
            combination of SHACL’s abstract validation model with a view of the file system through
            the prism of a unified value and expression model (XDM, XPath/XQuery + foxpath). </para>
        <para>The alignment is described in two tables. The first table provides an aligned
            definition of the validation process as a decomposable operation as defined by greenfox
            and SHACL. The second table is an aligned enumeration of some building blocks of the
            conceptual framework underlying greenfox and SHACL. </para>
        <table xml:id="appendix-a2-alignment-table-1">
            <title>Greenfox/SHACL alignment, part 1: validation model</title>
            <titleabbrev xml:id="appendix-a2-alignment-table-1-shorttitle">Alignment 1</titleabbrev>
            <tgroup cols="2">
                <colspec colname="c1" colnum="1" colwidth="4*"/>
                <colspec colname="c2" colnum="2" colwidth="4*"/>
                <thead>
                    <row>
                        <entry align="left">Greenfox operation</entry>
                        <entry align="left">SHACL operaration</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left">Validation of a file system against a greenfox schema </entry>
                        <entry align="left">Validation of a data graph against a shapes graph
                        </entry>
                    </row>
                    <row>
                        <entry align="left">= Union of the results of the validation of the file
                            system against all shapes</entry>
                        <entry align="left">= Union of the results of the validation of the data
                            graph against all shapes</entry>
                    </row>
                    <row>
                        <entry align="left">Validation of a file system against a shape</entry>
                        <entry align="left">Validation of a data graph against a shape</entry>
                    </row>
                    <row>
                        <entry align="left">= Union of the results of all focus resources in the
                            target of the shape</entry>
                        <entry align="left">= Union of the results of all focus nodes in the target
                            of the shape</entry>
                    </row>
                    <row>
                        <entry align="left">Validation of a focus resource against a shape = Union
                            of the results of the validation of the focus resource against all
                            constraints declared by the shape </entry>
                        <entry align="left">Validation of a focus node against a shape = Union of
                            the results of the validation of the focus node against all constraints
                            declared by the shape</entry>
                    </row>
                    <row>
                        <entry align="left">Validation of a focus node against a constraint =
                            function( constraint parameters , focus resource, resource values? </entry>
                        <entry align="left">Validation of a focus node against a constraint =
                            function( constraint parameters , focus node, property values? </entry>
                    </row>
                    <row>
                        <entry align="left">Resource values = XPath(resource) | foxpath
                            (resource)</entry>
                        <entry align="left">Property values = SPARQL property path (node)</entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
        <table xml:id="appendix-a2-alignment-table-2">
            <title>Greenfox/SHACL alignment, part 2: conceptual building blocks</title>
            <titleabbrev xml:id="appendix-a2-alignment-table-2-shorttitle">Alignment 2</titleabbrev>
            <tgroup cols="3">
                <colspec colname="c1" colnum="1" colwidth="4*"/>
                <colspec colname="c2" colnum="2" colwidth="4*"/>
                <colspec colname="c3" colnum="3" colwidth="6*"/>
                <thead>
                    <row>
                        <entry align="left">Greenfox concept</entry>
                        <entry align="left">SHACL</entry>
                        <entry align="left">Remark</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left"><para>Resource shape:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Folder shape</para>
                                </listitem>
                                <listitem>
                                    <para>File shape</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Node shape</entry>
                        <entry align="left">Common key concept: shape = set of constraints for a set
                            of resources </entry>
                    </row>
                    <row>
                        <entry align="left">Focus resource</entry>
                        <entry align="left">Focus node</entry>
                        <entry align="left">Common view: validation can be decomposed into instances
                            of validation of a single focus against a single shape </entry>
                    </row>
                    <row>
                        <entry align="left"><para>Target declaration</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Foxpath expression</para>
                                </listitem>
                                <listitem>
                                    <para>Literal file system path</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">
                            <para>Target declaration</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Class members</para>
                                </listitem>
                                <listitem>
                                    <para>Subjects of predicate IRI</para>
                                </listitem>
                                <listitem>
                                    <para>Objects of predicate IRI</para>
                                </listitem>
                                <listitem>
                                    <para>Literal IRI (node target)</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Difference: in greenfox a target declaration is
                            essentially a navigation result, in SHACL it tends to be derived from
                            class membership (ontological)</entry>
                    </row>
                    <row>
                        <entry align="left">Resource value</entry>
                        <entry align="left">Value node</entry>
                        <entry align="left">Common view: non-trivial validation requires mapping
                            resources to values</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Mapping resource to value:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>XPath expression</para>
                                </listitem>
                                <listitem>
                                    <para>Foxpath expression</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Mapping resource to property:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>SPARQL property path</para>
                                </listitem>
                            </itemizedlist></entry>
                        <entry align="left">Common view: the mapping of a resource to a value is an
                            expression</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Value shape:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>XPath shape</para>
                                </listitem>
                                <listitem>
                                    <para>Foxpath shape</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Property shape</entry>
                        <entry align="left">Common view: usefulness of an entity combining a
                                <emphasis role="ital">single</emphasis> mapping of the focus
                            resource to a value with a <emphasis role="ital">set of
                                constraints</emphasis> for that value</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Constraint declaration</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Constraint component</para>
                                </listitem>
                                <listitem>
                                    <para>Constraint parameters</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Constraint declaration</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Constraint component</para>
                                </listitem>
                                <listitem>
                                    <para>Constraint parameters</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Common view: a constraint declaration can be thought of
                            as a function call</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Constraint component</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Signature</para>
                                </listitem>
                                <listitem>
                                    <para>Mapping semantic</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Constraint component</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Signature</para>
                                </listitem>
                                <listitem>
                                    <para>Mapping semantic</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Common view: a constraint component can be thought of as
                            a library function</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Validation report</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Constraint violations</para>
                                </listitem>
                                <listitem>
                                    <para>Constraint passes</para>
                                </listitem>
                                <listitem>
                                    <para>Observations</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Validation report</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Constraint violations</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Common view: a result is an RDF resource; difference: in
                            greenfox also successful constraint checks produce results (“green
                            results”); difference: in greenfox also observations can be produced,
                            results unrelated to constraint checking (“blue results”) </entry>
                    </row>
                    <row>
                        <entry align="left"><para>Extension language:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>XPath/XQuery expression</para>
                                </listitem>
                                <listitem>
                                    <para>foxpath expression</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left"><para>Extension language:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>SPARQL SELECT queries</para>
                                </listitem>
                                <listitem>
                                    <para>SPARQL ASK queries</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">Common view: extension of functionality is based on an
                            expression language for mapping resources to values and values to a
                            result</entry>
                    </row>
                    <row>
                        <entry align="left"><para>Mediatype integration:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para>Common data model</para>
                                </listitem>
                                <listitem>
                                    <para>Common navigation model</para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                        <entry align="left">-</entry>
                        <entry align="left">Difference: in contrast to SHACL, greenfox faces a
                            heterogeneous collection of validation targets, calling for integration
                            concepts</entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
    </appendix>
    <appendix xml:id="appendix-validation-result-model">
        <title>Appendix A3: Validation result model</title>
        <para>This appendix gives a detailed account of the validation result model.</para>
        <para>In the table below, the XML representation is rendered as an XPath expression to be
            evaluated in the context of the XML element representing the result, which is a
                <code>&lt;gx:red></code>, <code>&lt;gx:yellow></code>, <code>&lt;gx:green></code> or
                <code>&lt;gx:blue></code> element. Apart from the values shown in the table,
            individual constraint components may define additional values.</para>
        <table xml:id="appendix-a3-validation-result-model">
            <title>The validation result model – RDF properties, description, corresponding SHACL
                result property and XML representation. </title>
            <titleabbrev xml:id="appendix-a3-validation-result-model-shorttitle">Validation result
                model</titleabbrev>
            <tgroup cols="4">
                <colspec colname="c1" colnum="1" colwidth="6*"/>
                <colspec colname="c2" colnum="2" colwidth="6*"/>
                <colspec colname="c3" colnum="3" colwidth="6*"/>
                <colspec colname="c4" colnum="4" colwidth="6*"/>
                <thead>
                    <row>
                        <entry align="left">RDF property</entry>
                        <entry align="left">Description</entry>
                        <entry align="left">SHACL result property</entry>
                        <entry align="left">XML representation</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry align="left"><code>gx:severity</code></entry>
                        <entry align="left">
                            <para>The possible values:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para><code>gx:Violation</code></para>
                                </listitem>
                                <listitem>
                                    <para><code>gx:Warning</code></para>
                                </listitem>
                                <listitem>
                                    <para><code>gx:Pass</code></para>
                                </listitem>
                                <listitem>
                                    <para><code>gx:Observation</code></para>
                                </listitem>
                            </itemizedlist>
                            <para> While <code>gx:Observation</code> is a value not related to a
                                constraint check, the other ones represent constraint violations or
                                a successful check </para></entry>
                        <entry align="left"><code>sh:severity</code></entry>
                        <entry align="left">
                            <para>Local name of the result representing element:</para>
                            <itemizedlist spacing="compact">
                                <listitem>
                                    <para><code>red = gx:Violation</code></para>
                                </listitem>
                                <listitem>
                                    <para><code>yellow = gx:Warning</code></para>
                                </listitem>
                                <listitem>
                                    <para><code>green = gx:Pass</code></para>
                                </listitem>
                                <listitem>
                                    <para><code>bluen = gx:Observation</code></para>
                                </listitem>
                            </itemizedlist>
                        </entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:fileSystem</code></entry>
                        <entry align="left">Identifies the file system validated</entry>
                        <entry align="left">An aspect of <code>sh:focusNode</code></entry>
                        <entry align="left"><code>ancestor:: gx:validation-Report/ @fileSystemURI
                            </code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:focusResource</code></entry>
                        <entry align="left">File path of a file or folder resource</entry>
                        <entry align="left">An aspect of <code>sh:focusNode</code></entry>
                        <entry align="left"><code>@filePath</code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:focusNode</code></entry>
                        <entry align="left">XPath of a node within an XDM node tree representing the
                            contents of a file resource</entry>
                        <entry align="left"><code>sh:focusNode</code></entry>
                        <entry align="left"><code>@nodePath</code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:xpath</code></entry>
                        <entry align="left">The XPath expression of a value shape</entry>
                        <entry align="left"><code>sh:resultPath</code></entry>
                        <entry align="left"><code>@expr</code> or <code>./expr</code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:foxpath</code></entry>
                        <entry align="left">The foxpath expression of a value shape</entry>
                        <entry align="left"><code>sh:resultPath</code></entry>
                        <entry align="left"><code>@expr</code> or <code>./expr</code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:value</code></entry>
                        <entry align="left">A resource value, or single item of a resource value,
                            causing a violation</entry>
                        <entry align="left"><code>gx:value</code></entry>
                        <entry align="left"><para><code>@value</code> or
                                <code>value</code></para><para>A value consisting of several items
                                is represented by a sequence of &lt;value> child
                            elements</para></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:valueCount</code></entry>
                        <entry align="left">Number of resources in a target, or of resource value
                            items, causing a violation</entry>
                        <entry align="left">-</entry>
                        <entry align="left"><para><code>@valueCount</code></para></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:sourceShape</code></entry>
                        <entry align="left">The value shape or resource shape defining the
                            constraint; the value is the @id value on the shape element in the
                            schema if present, or a value assigned by the greenfox processor
                            otherwise </entry>
                        <entry align="left"><code>gx:sourceShape</code></entry>
                        <entry align="left"><code>@shapeID</code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:constraint-Component</code></entry>
                        <entry align="left">Identifies the kind of constraint</entry>
                        <entry align="left"><code>sh:constraint-Component</code></entry>
                        <entry align="left"><code>@constraint-Component</code></entry>
                    </row>
                    <row>
                        <entry align="left"><code>gx:message</code></entry>
                        <entry align="left">A message communicating details to humans; the value is
                            the @msg or @...Msg or <code>&lt;msg></code> or <code>&lt;...Msg></code>
                            value on the shape or constraint element in the schema, or a value
                            assigned by the greenfox processor. In the above, … is a prefix
                            identifying the constraint to which the message relates. Examples:
                            @minCountMsg, @exprValueEqMsg. </entry>
                        <entry align="left"><code>sh:message</code></entry>
                        <entry align="left"><code>@msg or ./msg</code> with
                                <code>./msg/@xml:lang</code></entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

    </appendix>
    <bibliography>
        <biblioentry xml:id="basex">
            <abbrev>1</abbrev>
            <title>BaseX</title>
            <date>2020</date>
            <publisher>
                <publishername>BaseX GmbH</publishername>
            </publisher>
            <biblioid class="uri">http:// basex.org</biblioid>
        </biblioentry>
        <biblioentry xml:id="foxpath">
            <abbrev>2</abbrev>
            <title>FOXpath - an expression language for selecting files and folders.</title>
            <date>2016</date>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <biblioid class="uri">http://www.balisage.net/Proceedings/vol17/html/
                Rennau01/BalisageVol17-Rennau01.html</biblioid>
        </biblioentry>
        <biblioentry xml:id="foxpath2">
            <abbrev>3</abbrev>
            <title>FOXpath navigation of physical, virtual and literal file systems.</title>
            <date>2016</date>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <biblioid class="uri"
                >https://archive.xmlprague.cz/2017/files/xmlprague-2017-proceedings.pdf</biblioid>
        </biblioentry>
        <biblioentry xml:id="foxpath3">
            <abbrev>4</abbrev>
            <title>foxpath - an extended version of XPath 3.0 supporting file system
                navigation.</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2017</date>
            <biblioid class="uri">https://github.com/hrennau/shax</biblioid>
        </biblioentry>
        <biblioentry xml:id="greenfox">
            <abbrev>5</abbrev>
            <title>Greenfox - a schema language for validating file system contents and, by
                implication, real-world systems.</title>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Hans-Juergen</firstname>
                        <surname>Rennau</surname>
                    </personname>
                </author>
            </authorgroup>
            <date>2020</date>
            <biblioid class="uri">https://github.com/hrennau/greenfox</biblioid>
        </biblioentry>
        <biblioentry xml:id="xpath31">
            <abbrev>6</abbrev>
            <title>XML Path Language (XPath) 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xpathfunctions31">
            <abbrev>7</abbrev>
            <title>XPath and XQuery Functions and Operators 3.1</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xpath-functions-31/</biblioid>
        </biblioentry>
        <biblioentry xml:id="xquery31">
            <abbrev>8</abbrev>
            <title>XQuery 3.1: An XML Query Language</title>
            <date>2017</date>
            <publisher>
                <publishername>World Wide Web Consortium (W3C)</publishername>
            </publisher>
            <biblioid class="uri">https://www.w3.org/TR/xquery-31/</biblioid>
        </biblioentry>
    </bibliography>
</article>
